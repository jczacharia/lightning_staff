
Stotem_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000126  00800100  000055c8  0000565c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000055c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000039f  00800226  00800226  00005782  2**0
                  ALLOC
  3 .comment      00000060  00000000  00000000  00005782  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000057e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00001068  00000000  00000000  00005820  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00030bf9  00000000  00000000  00006888  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000592d  00000000  00000000  00037481  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000a8d0  00000000  00000000  0003cdae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00003934  00000000  00000000  00047680  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000a3a4  00000000  00000000  0004afb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00018e40  00000000  00000000  00055358  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001250  00000000  00000000  0006e198  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 da 03 	jmp	0x7b4	; 0x7b4 <__dtors_end>
       4:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
       8:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
       c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      10:	0c 94 e1 0a 	jmp	0x15c2	; 0x15c2 <__vector_4>
      14:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      18:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      1c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      20:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      24:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      28:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      2c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      30:	0c 94 87 18 	jmp	0x310e	; 0x310e <__vector_12>
      34:	0c 94 e7 17 	jmp	0x2fce	; 0x2fce <__vector_13>
      38:	0c 94 31 19 	jmp	0x3262	; 0x3262 <__vector_14>
      3c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      40:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      44:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      48:	0c 94 8f 23 	jmp	0x471e	; 0x471e <__vector_18>
      4c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      50:	0c 94 e5 21 	jmp	0x43ca	; 0x43ca <__vector_20>
      54:	0c 94 17 22 	jmp	0x442e	; 0x442e <__vector_21>
      58:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      5c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      60:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      64:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      68:	0c 94 87 1f 	jmp	0x3f0e	; 0x3f0e <__vector_26>
      6c:	0c 94 02 04 	jmp	0x804	; 0x804 <__bad_interrupt>
      70:	74 11       	cpse	r23, r4
      72:	8c 11       	cpse	r24, r12
      74:	a4 11       	cpse	r26, r4
      76:	aa 11       	cpse	r26, r10
      78:	ce 11       	cpse	r28, r14
      7a:	d1 11       	cpse	r29, r1
      7c:	d4 11       	cpse	r29, r4
      7e:	d7 11       	cpse	r29, r7
      80:	f8 11       	cpse	r31, r8
      82:	ea 12       	cpse	r14, r26
      84:	ed 12       	cpse	r14, r29
      86:	f0 12       	cpse	r15, r16
      88:	06 13       	cpse	r16, r22
      8a:	0a 13       	cpse	r16, r26
      8c:	0c 13       	cpse	r16, r28
      8e:	0e 13       	cpse	r16, r30
      90:	10 13       	cpse	r17, r16
      92:	12 13       	cpse	r17, r18
      94:	14 13       	cpse	r17, r20
      96:	01 13       	cpse	r16, r17
      98:	04 13       	cpse	r16, r20
      9a:	fe 12       	cpse	r15, r30
      9c:	16 13       	cpse	r17, r22
      9e:	fb 12       	cpse	r15, r27
      a0:	19 13       	cpse	r17, r25
      a2:	1c 13       	cpse	r17, r28
      a4:	1f 13       	cpse	r17, r31
      a6:	22 13       	cpse	r18, r18
      a8:	2e 13       	cpse	r18, r30

000000aa <__trampolines_end>:
      aa:	21 00       	.word	0x0021	; ????
      ac:	7f 22       	and	r7, r31
      ae:	00 07       	cpc	r16, r16

000000b0 <_ZL9initTable>:
      b0:	ae d5 80 a8 3f d3 00 40 8d 14 20 00 a1 c8 da 12     ....?..@.. .....
      c0:	81 cf d9 f1 db 40 a4 a6 af                          .....@...

000000c9 <_ZL4fTbl>:
      c9:	24 02 d7 00 00 00 00 00 00 00 00 00 00 00           $.............

000000d7 <_ZL5font3>:
      d7:	fe 01 ec 01 c1 01 9f 01 85 01 6b 01 4b 01 36 01     ..........k.K.6.
      e7:	12 01 eb 00                                         ....

000000eb <_ZL4f3_9>:
      eb:	44 f8 fc fe 8e 87 07 44 8e fe fc f8 01 82 03 41     D......D.......A
      fb:	07 83 0e 48 8e ce ee fe ff 7f 3f 07 02 83 1c 46     ...H......?....F
     10b:	1e 1f 0f 07 03 01 04                                .......

00000112 <_ZL4f3_8>:
     112:	44 f8 fc fe 8e 87 07 44 8e fe fc f8 44 e0 f1 fb     D......D....D...
     122:	3f 87 0e 44 3f fb f1 e0 44 03 07 0f 0e 87 1c 44     ?..D?...D......D
     132:	0e 0f 07 03                                         ....

00000136 <_ZL4f3_7>:
     136:	88 07 47 87 c7 e7 f7 7f 3f 1f 06 41 fe c2 82 01     ..G.....?..A....
     146:	04 06 83 1f 06                                      .....

0000014b <_ZL4f3_6>:
     14b:	44 f8 fc fe 0e 87 07 44 0e 3e 3c 38 c3 88 0e 44     D......D.><8...D
     15b:	1c fc f8 f0 44 03 07 0f 0e 87 1c 44 0e 0f 07 03     ....D......D....

0000016b <_ZL4f3_5>:
     16b:	c3 88 c7 82 87 82 07 83 81 88 01 41 03 c3 44 03     ...........A..D.
     17b:	07 0f 0e 87 1c 44 0e 0f 07 03                       .....D....

00000185 <_ZL4f3_4>:
     185:	02 47 80 c0 e0 f0 78 3c 1e c3 03 45 7e 7f 7f 73     .G....x<...E~..s
     195:	71 84 70 c3 83 70 09 83 1f 03                       q.p..p....

0000019f <_ZL4f3_3>:
     19f:	44 38 3c 3e 0e 87 07 44 06 fe fc f8 83 80 04 84     D8<>...D........
     1af:	0e 44 3f ff f1 e0 44 03 07 0f 0e 87 1c 44 0e 0f     .D?...D......D..
     1bf:	07 03                                               ..

000001c1 <_ZL4f3_2>:
     1c1:	44 38 3c 3e 0e 87 07 44 06 fe fc f8 03 4c 80 c0     D8<>...D.....L..
     1d1:	e0 f0 78 3c 1e 0f 07 03 01 00 42 1c 1e 83 1f 41     ..x<......B....A
     1e1:	1d 89 1c 1c 1c 1c 1c 1c 1c 1c 1c                    ...........

000001ec <_ZL4f3_1>:
     1ec:	03 43 08 0c 0e c3 06 06 c3 06 03 83 1c 83 1f 83     .C..............
     1fc:	1c 03                                               ..

000001fe <_ZL4f3_0>:
     1fe:	44 f8 fc fe 0e 85 07 46 87 c7 ee fe fc f8 c3 48     D......F.......H
     20e:	e0 70 38 1c 0e 07 03 01 01 c3 44 03 07 0f 0e 87     .p8.......D.....
     21e:	1c 44 0e 0f 07 03                                   .D....

00000224 <_ZL5font2>:
     224:	dc 02 cd 02 b8 02 a3 02 93 02 81 02 6d 02 60 02     ............m.`.
     234:	4c 02 38 02                                         L.8.

00000238 <_ZL4f2_9>:
     238:	43 3c 7e e7 84 c3 43 e7 fe fc 02 82 30 46 38 1c     C<~...C.....0F8.
     248:	0e 07 03 01                                         ....

0000024c <_ZL4f2_8>:
     24c:	43 3c fe e7 84 c3 43 e7 fe 3c 43 0f 1f 39 84 30     C<....C..<C..9.0
     25c:	43 39 1f 0f                                         C9..

00000260 <_ZL4f2_7>:
     260:	84 03 46 c3 e3 73 3b 1f 0f 04 82 3f 04              ..F..s;....?.

0000026d <_ZL4f2_6>:
     26d:	43 fc fe c7 84 c3 43 c7 8e 0c 43 0f 1f 38 84 30     C.....C...C..8.0
     27d:	43 39 1f 0f                                         C9..

00000281 <_ZL4f2_5>:
     281:	82 3f 85 33 43 73 e3 c3 43 0c 1c 38 84 30 43 38     .?.3Cs..C..8.0C8
     291:	1f 0f                                               ..

00000293 <_ZL4f2_4>:
     293:	46 c0 e0 70 38 1c 0e c2 02 86 03 44 3f 3f 03 03     F..p8......D??..

000002a3 <_ZL4f2_3>:
     2a3:	4a 0c 0e 07 03 03 c3 c3 c7 fe 3c 43 0c 1c 38 84     J.........<C..8.
     2b3:	30 43 38 1f 0f                                      0C8..

000002b8 <_ZL4f2_2>:
     2b8:	4a 0c 0e 07 03 03 83 c3 e7 7e 3c 47 30 38 3c 3e     J........~<G08<>
     2c8:	37 33 31 83 30                                      731.0

000002cd <_ZL4f2_1>:
     2cd:	02 42 0c 0e c2 04 02 46 30 30 3f 3f 30 30 02        .B.....F00??00.

000002dc <_ZL4f2_0>:
     2dc:	4a fc fe 07 83 c3 e3 73 3f fe fc 4a 0f 1f 3f 33     J......s?..J..?3
     2ec:	31 30 30 38 1f 0f                                   1008..

000002f2 <_ZL4font>:
     2f2:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 7f     ......._........
     302:	7f 7f 7f 7f 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
     312:	56 20 50 00 08 07 03 00 00 1c 22 41 00 00 41 22     V P......."A..A"
     322:	1c 00 2a 1c 7f 1c 2a 08 08 3e 08 08 00 80 70 30     ..*...*..>....p0
     332:	00 08 08 08 08 08 00 40 00 00 00 20 10 08 04 02     .......@... ....
     342:	3e 51 49 45 3e 00 42 7f 40 00 72 49 49 49 46 21     >QIE>.B.@.rIIIF!
     352:	41 49 4d 33 18 14 12 7f 10 27 45 45 45 39 3c 4a     AIM3.....'EEE9<J
     362:	49 49 31 41 21 11 09 07 36 49 49 49 36 46 49 49     II1A!...6III6FII
     372:	29 1e 00 14 00 00 00 00 40 34 00 00 08 1c 36 63     ).......@4....6c
     382:	41 14 14 14 14 14 41 63 36 1c 08 02 01 59 09 06     A.....Ac6....Y..
     392:	3e 41 5d 59 4e 7c 12 11 12 7c 7f 49 49 49 36 3e     >A]YN|...|.III6>
     3a2:	41 41 41 22 7f 41 41 41 3e 7f 49 49 49 41 7f 09     AAA".AAA>.IIIA..
     3b2:	09 09 01 3e 41 41 51 73 7f 08 08 08 7f 00 41 7f     ...>AAQs......A.
     3c2:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     3d2:	40 7f 02 1c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     3e2:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 26     .....>AQ!^...)F&
     3f2:	49 49 49 32 03 01 7f 01 03 3f 40 40 40 3f 1f 20     III2.....?@@@?. 
     402:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 03 04 78     @ .?@8@?c...c..x
     412:	04 03 61 59 49 4d 43 00 7f 41 41 41 02 04 08 10     ..aYIMC..AAA....
     422:	20 00 41 41 41 7f 04 02 01 02 04 40 40 40 40 40      .AAA......@@@@@
     432:	08 1c 3e 1c 08 20 54 54 78 40 7f 28 44 44 38 38     ..>.. TTx@.(DD88
     442:	44 44 44 28 38 44 44 28 7f 38 54 54 54 18 00 08     DDD(8DD(.8TTT...
     452:	7e 09 02 18 a4 a4 9c 78 7f 08 04 04 78 00 44 7d     ~......x....x.D}
     462:	40 00 20 40 40 3d 00 7f 10 28 44 00 00 41 7f 40     @. @@=...(D..A.@
     472:	00 7c 04 78 04 78 7c 08 04 04 78 38 44 44 44 38     .|.x.x|...x8DDD8
     482:	fc 18 24 24 18 18 24 24 18 fc 7c 08 04 04 08 48     ..$$..$$..|....H
     492:	54 54 54 24 04 04 3f 44 24 3c 40 40 20 7c 1c 20     TTT$..?D$<@@ |. 
     4a2:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 4c 90 90     @ .<@0@<D(.(DL..
     4b2:	90 7c 44 64 54 4c 44 00 08 36 41 00 00 00 77 00     .|DdTLD..6A...w.
     4c2:	00 00 41 36 08 00 08 04 08 10 08 02 05 02 00 00     ..A6............
     4d2:	0e 11 11 11 0e                                      .....

000004d7 <_ZL19BrightnessMenu_PROG>:
     4d7:	b3 05 d3 05 cb 05                                   ......

000004dd <_ZL19AnimationsMenu_PROG>:
     4dd:	d3 05 a5 05 9d 05 98 05 8e 05 85 05 7f 05 77 05     ..............w.
     4ed:	6c 05 57 05 51 05 48 05 40 05 30 05 2b 05 25 05     l.W.Q.H.@.0.+.%.
     4fd:	1e 05 13 05 0b 05 05 05                             ........

00000505 <_ZL13SubMenu_STACK>:
     505:	53 74 61 63 6b 00                                   Stack.

0000050b <_ZL15SubMenu_FLICKER>:
     50b:	46 6c 69 63 6b 65 72 00                             Flicker.

00000513 <_ZL17SubMenu_WAVERACER>:
     513:	57 61 76 65 20 52 61 63 65 72 00                    Wave Racer.

0000051e <_ZL14SubMenu_CLOUDS>:
     51e:	43 6c 6f 75 64 73 00                                Clouds.

00000525 <_ZL13SubMenu_COMET>:
     525:	43 6f 6d 65 74 00                                   Comet.

0000052b <_ZL12SubMenu_PONG>:
     52b:	50 6f 6e 67 00                                      Pong.

00000530 <_ZL22SubMenu_RAINBOWGLITTER>:
     530:	52 61 69 6e 62 6f 77 20 47 6c 69 74 74 65 72 00     Rainbow Glitter.

00000540 <_ZL15SubMenu_RAINBOW>:
     540:	52 61 69 6e 62 6f 77 00                             Rainbow.

00000548 <_ZL16SubMenu_SPECTRUM>:
     548:	53 70 65 63 74 72 75 6d 00                          Spectrum.

00000551 <_ZL13SubMenu_WONKA>:
     551:	57 6f 6e 6b 61 00                                   Wonka.

00000557 <_ZL15SubMenu_P_1940S>:
     557:	31 39 34 30 73 50 73 79 63 68 65 64 65 6c 69 63     1940sPsychedelic
     567:	52 75 73 68 00                                      Rush.

0000056c <_ZL17SubMenu_WHITEWAVE>:
     56c:	57 68 69 74 65 20 57 61 76 65 00                    White Wave.

00000577 <_ZL15SubMenu_SEIZURE>:
     577:	53 65 69 7a 75 72 65 00                             Seizure.

0000057f <_ZL13SubMenu_JOKER>:
     57f:	4a 6f 6b 65 72 00                                   Joker.

00000585 <_ZL16SubMenu_SKITTLES>:
     585:	53 6b 69 74 74 6c 65 73 00                          Skittles.

0000058e <_ZL16SubMenu_ACIDRAIN>:
     58e:	41 63 69 64 20 52 61 69 6e 00                       Acid Rain.

00000598 <_ZL12SubMenu_FADE>:
     598:	46 61 64 65 00                                      Fade.

0000059d <_ZL15SubMenu_LANTERN>:
     59d:	4c 61 6e 74 65 72 6e 00                             Lantern.

000005a5 <_ZL13SubMenu_TORCH>:
     5a5:	54 6f 72 63 68 00                                   Torch.

000005ab <_ZL13RootMenu_PROG>:
     5ab:	e9 05 d3 05 bf 05 b3 05                             ........

000005b3 <_ZL19RootMenu_Item2_PROG>:
     5b3:	2f 42 72 69 67 68 74 6e 65 73 73 00                 /Brightness.

000005bf <_ZL19RootMenu_Item1_PROG>:
     5bf:	2f 41 6e 69 6d 61 74 69 6f 6e 73 00                 /Animations.

000005cb <_ZL9BACK_PROG>:
     5cb:	3c 2d 20 42 41 43 4b 00                             <- BACK.

000005d3 <_ZL11Dashes_PROG>:
     5d3:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     5e3:	2d 2d 2d 2d 2d 00                                   -----.

000005e9 <_ZL13RootDash_PROG>:
     5e9:	2f 00                                               /.

000005eb <HeatColors_p>:
     5eb:	00 00 00 00 00 00 33 00 00 00 66 00 00 00 99 00     ......3...f.....
     5fb:	00 00 cc 00 00 00 ff 00 00 33 ff 00 00 66 ff 00     .........3...f..
     60b:	00 99 ff 00 00 cc ff 00 00 ff ff 00 33 ff ff 00     ............3...
     61b:	66 ff ff 00 99 ff ff 00 cc ff ff 00 ff ff ff 00     f...............

0000062b <PartyColors_p>:
     62b:	ab 00 55 00 7c 00 84 00 4b 00 b5 00 1b 00 e5 00     ..U.|...K.......
     63b:	00 17 e8 00 00 47 b8 00 00 77 ab 00 00 ab ab 00     .....G...w......
     64b:	00 55 ab 00 00 22 dd 00 0e 00 f2 00 3e 00 c2 00     .U..."......>...
     65b:	71 00 8f 00 a1 00 5f 00 d0 00 2f 00 f9 07 00 00     q....._.../.....

0000066b <RainbowStripeColors_p>:
     66b:	00 00 ff 00 00 00 00 00 00 55 ab 00 00 00 00 00     .........U......
     67b:	00 ab ab 00 00 00 00 00 00 ff 00 00 00 00 00 00     ................
     68b:	55 ab 00 00 00 00 00 00 ff 00 00 00 00 00 00 00     U...............
     69b:	ab 00 55 00 00 00 00 00 55 00 ab 00 00 00 00 00     ..U.....U.......

000006ab <RainbowColors_p>:
     6ab:	00 00 ff 00 00 2a d5 00 00 55 ab 00 00 7f ab 00     .....*...U......
     6bb:	00 ab ab 00 00 d5 56 00 00 ff 00 00 2a d5 00 00     ......V.....*...
     6cb:	55 ab 00 00 aa 56 00 00 ff 00 00 00 d5 00 2a 00     U....V........*.
     6db:	ab 00 55 00 81 00 7f 00 55 00 ab 00 2b 00 d5 00     ..U.....U...+...

000006eb <CloudColors_p>:
     6eb:	ff 00 00 00 8b 00 00 00 8b 00 00 00 8b 00 00 00     ................
     6fb:	8b 00 00 00 8b 00 00 00 8b 00 00 00 8b 00 00 00     ................
     70b:	ff 00 00 00 8b 00 00 00 eb ce 87 00 eb ce 87 00     ................
     71b:	e6 d8 ad 00 ff ff ff 00 e6 d8 ad 00 eb ce 87 00     ................

0000072b <digital_pin_to_timer_PGM>:
     72b:	00 00 00 01 02 00 00 00 00 00 00 00 04 03 08 07     ................
	...

0000074b <digital_pin_to_bit_mask_PGM>:
     74b:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 40 80     ..... @...... @.
     75b:	01 02 04 08 10 20 40 80 80 40 20 10 08 04 02 01     ..... @..@ .....

0000076b <digital_pin_to_port_PGM>:
     76b:	02 02 02 02 02 02 02 02 04 04 04 04 04 04 04 04     ................
     77b:	03 03 03 03 03 03 03 03 01 01 01 01 01 01 01 01     ................

0000078b <port_to_input_PGM>:
     78b:	00 00 20 00 23 00 26 00 29 00                       .. .#.&.).

00000795 <port_to_output_PGM>:
     795:	00 00 22 00 25 00 28 00 2b 00                       ..".%.(.+.

0000079f <port_to_mode_PGM>:
     79f:	00 00 21 00 24 00 27 00 2a 00 00                    ..!.$.'.*..

000007aa <__ctors_start>:
     7aa:	dc 16       	cp	r13, r28
     7ac:	b8 1d       	adc	r27, r8
     7ae:	df 21       	and	r29, r15
     7b0:	47 22       	and	r4, r23

000007b2 <__ctors_end>:
     7b2:	fc 16       	cp	r15, r28

000007b4 <__dtors_end>:
     7b4:	11 24       	eor	r1, r1
     7b6:	1f be       	out	0x3f, r1	; 63
     7b8:	cf ef       	ldi	r28, 0xFF	; 255
     7ba:	d0 e1       	ldi	r29, 0x10	; 16
     7bc:	de bf       	out	0x3e, r29	; 62
     7be:	cd bf       	out	0x3d, r28	; 61

000007c0 <__do_copy_data>:
     7c0:	12 e0       	ldi	r17, 0x02	; 2
     7c2:	a0 e0       	ldi	r26, 0x00	; 0
     7c4:	b1 e0       	ldi	r27, 0x01	; 1
     7c6:	e8 ec       	ldi	r30, 0xC8	; 200
     7c8:	f5 e5       	ldi	r31, 0x55	; 85
     7ca:	02 c0       	rjmp	.+4      	; 0x7d0 <__do_copy_data+0x10>
     7cc:	05 90       	lpm	r0, Z+
     7ce:	0d 92       	st	X+, r0
     7d0:	a6 32       	cpi	r26, 0x26	; 38
     7d2:	b1 07       	cpc	r27, r17
     7d4:	d9 f7       	brne	.-10     	; 0x7cc <__do_copy_data+0xc>

000007d6 <__do_clear_bss>:
     7d6:	25 e0       	ldi	r18, 0x05	; 5
     7d8:	a6 e2       	ldi	r26, 0x26	; 38
     7da:	b2 e0       	ldi	r27, 0x02	; 2
     7dc:	01 c0       	rjmp	.+2      	; 0x7e0 <.do_clear_bss_start>

000007de <.do_clear_bss_loop>:
     7de:	1d 92       	st	X+, r1

000007e0 <.do_clear_bss_start>:
     7e0:	a5 3c       	cpi	r26, 0xC5	; 197
     7e2:	b2 07       	cpc	r27, r18
     7e4:	e1 f7       	brne	.-8      	; 0x7de <.do_clear_bss_loop>

000007e6 <__do_global_ctors>:
     7e6:	13 e0       	ldi	r17, 0x03	; 3
     7e8:	c9 ed       	ldi	r28, 0xD9	; 217
     7ea:	d3 e0       	ldi	r29, 0x03	; 3
     7ec:	04 c0       	rjmp	.+8      	; 0x7f6 <__do_global_ctors+0x10>
     7ee:	21 97       	sbiw	r28, 0x01	; 1
     7f0:	fe 01       	movw	r30, r28
     7f2:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <__tablejump2__>
     7f6:	c5 3d       	cpi	r28, 0xD5	; 213
     7f8:	d1 07       	cpc	r29, r17
     7fa:	c9 f7       	brne	.-14     	; 0x7ee <__do_global_ctors+0x8>
     7fc:	0e 94 76 22 	call	0x44ec	; 0x44ec <main>
     800:	0c 94 d7 2a 	jmp	0x55ae	; 0x55ae <__do_global_dtors>

00000804 <__bad_interrupt>:
     804:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000808 <_ZN7ADXL345C1Ev>:
    if((bw_code < ADXL345_BW_3) || (bw_code > ADXL345_BW_1600)){
        status = false;
        error_code = ADXL345_BAD_ARG;
    }
    else{
        writeTo(ADXL345_BW_RATE, bw_code);
     808:	fc 01       	movw	r30, r24
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	80 83       	st	Z, r24
     80e:	11 82       	std	Z+1, r1	; 0x01
     810:	83 ec       	ldi	r24, 0xC3	; 195
     812:	9b ea       	ldi	r25, 0xAB	; 171
     814:	a6 e7       	ldi	r26, 0x76	; 118
     816:	bb e3       	ldi	r27, 0x3B	; 59
     818:	82 83       	std	Z+2, r24	; 0x02
     81a:	93 83       	std	Z+3, r25	; 0x03
     81c:	a4 83       	std	Z+4, r26	; 0x04
     81e:	b5 83       	std	Z+5, r27	; 0x05
     820:	88 ed       	ldi	r24, 0xD8	; 216
     822:	9b e6       	ldi	r25, 0x6B	; 107
     824:	a6 e7       	ldi	r26, 0x76	; 118
     826:	bb e3       	ldi	r27, 0x3B	; 59
     828:	86 83       	std	Z+6, r24	; 0x06
     82a:	97 83       	std	Z+7, r25	; 0x07
     82c:	a0 87       	std	Z+8, r26	; 0x08
     82e:	b1 87       	std	Z+9, r27	; 0x09
     830:	82 ef       	ldi	r24, 0xF2	; 242
     832:	94 ee       	ldi	r25, 0xE4	; 228
     834:	a4 e6       	ldi	r26, 0x64	; 100
     836:	bb e3       	ldi	r27, 0x3B	; 59
     838:	82 87       	std	Z+10, r24	; 0x0a
     83a:	93 87       	std	Z+11, r25	; 0x0b
     83c:	a4 87       	std	Z+12, r26	; 0x0c
     83e:	b5 87       	std	Z+13, r27	; 0x0d
     840:	08 95       	ret

00000842 <_ZN7ADXL3457writeToEhh>:
     842:	cf 93       	push	r28
     844:	df 93       	push	r29
     846:	d6 2f       	mov	r29, r22
     848:	c4 2f       	mov	r28, r20
     84a:	63 e5       	ldi	r22, 0x53	; 83
     84c:	70 e0       	ldi	r23, 0x00	; 0
     84e:	89 ec       	ldi	r24, 0xC9	; 201
     850:	94 e0       	ldi	r25, 0x04	; 4
     852:	0e 94 60 21 	call	0x42c0	; 0x42c0 <_ZN7TwoWire17beginTransmissionEi>
     856:	6d 2f       	mov	r22, r29
     858:	89 ec       	ldi	r24, 0xC9	; 201
     85a:	94 e0       	ldi	r25, 0x04	; 4
     85c:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN7TwoWire5writeEh>
     860:	6c 2f       	mov	r22, r28
     862:	89 ec       	ldi	r24, 0xC9	; 201
     864:	94 e0       	ldi	r25, 0x04	; 4
     866:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN7TwoWire5writeEh>
     86a:	89 ec       	ldi	r24, 0xC9	; 201
     86c:	94 e0       	ldi	r25, 0x04	; 4
     86e:	df 91       	pop	r29
     870:	cf 91       	pop	r28
     872:	0c 94 dc 21 	jmp	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>

00000876 <_ZN7ADXL3457powerOnEv>:
     876:	cf 93       	push	r28
     878:	df 93       	push	r29
     87a:	ec 01       	movw	r28, r24
     87c:	89 ec       	ldi	r24, 0xC9	; 201
     87e:	94 e0       	ldi	r25, 0x04	; 4
     880:	0e 94 4c 21 	call	0x4298	; 0x4298 <_ZN7TwoWire5beginEv>
     884:	40 e0       	ldi	r20, 0x00	; 0
     886:	6d e2       	ldi	r22, 0x2D	; 45
     888:	ce 01       	movw	r24, r28
     88a:	0e 94 21 04 	call	0x842	; 0x842 <_ZN7ADXL3457writeToEhh>
     88e:	40 e1       	ldi	r20, 0x10	; 16
     890:	6d e2       	ldi	r22, 0x2D	; 45
     892:	ce 01       	movw	r24, r28
     894:	0e 94 21 04 	call	0x842	; 0x842 <_ZN7ADXL3457writeToEhh>
     898:	48 e0       	ldi	r20, 0x08	; 8
     89a:	6d e2       	ldi	r22, 0x2D	; 45
     89c:	ce 01       	movw	r24, r28
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	0c 94 21 04 	jmp	0x842	; 0x842 <_ZN7ADXL3457writeToEhh>

000008a6 <_ZN7ADXL3458readFromEhiPh>:
    Wire.write(val);                 // send value to write
    Wire.endTransmission();         // end transmission
}

// Reads num bytes starting from address register on device in to _buff array
void ADXL345::readFrom(byte address, int num, byte _buff[]) {
     8a6:	af 92       	push	r10
     8a8:	bf 92       	push	r11
     8aa:	cf 92       	push	r12
     8ac:	df 92       	push	r13
     8ae:	ef 92       	push	r14
     8b0:	ff 92       	push	r15
     8b2:	0f 93       	push	r16
     8b4:	1f 93       	push	r17
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	8c 01       	movw	r16, r24
     8bc:	c6 2f       	mov	r28, r22
     8be:	7a 01       	movw	r14, r20
     8c0:	69 01       	movw	r12, r18
    Wire.beginTransmission(ADXL345_DEVICE); // start transmission to device 
     8c2:	63 e5       	ldi	r22, 0x53	; 83
     8c4:	70 e0       	ldi	r23, 0x00	; 0
     8c6:	89 ec       	ldi	r24, 0xC9	; 201
     8c8:	94 e0       	ldi	r25, 0x04	; 4
     8ca:	0e 94 60 21 	call	0x42c0	; 0x42c0 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write(address);             // sends address to read from
     8ce:	6c 2f       	mov	r22, r28
     8d0:	89 ec       	ldi	r24, 0xC9	; 201
     8d2:	94 e0       	ldi	r25, 0x04	; 4
     8d4:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN7TwoWire5writeEh>
    Wire.endTransmission();         // end transmission
     8d8:	89 ec       	ldi	r24, 0xC9	; 201
     8da:	94 e0       	ldi	r25, 0x04	; 4
     8dc:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>
    
    Wire.beginTransmission(ADXL345_DEVICE); // start transmission to device
     8e0:	63 e5       	ldi	r22, 0x53	; 83
     8e2:	70 e0       	ldi	r23, 0x00	; 0
     8e4:	89 ec       	ldi	r24, 0xC9	; 201
     8e6:	94 e0       	ldi	r25, 0x04	; 4
     8e8:	0e 94 60 21 	call	0x42c0	; 0x42c0 <_ZN7TwoWire17beginTransmissionEi>
    Wire.requestFrom(ADXL345_DEVICE, num);    // request 6 bytes from device
     8ec:	a7 01       	movw	r20, r14
     8ee:	63 e5       	ldi	r22, 0x53	; 83
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	89 ec       	ldi	r24, 0xC9	; 201
     8f4:	94 e0       	ldi	r25, 0x04	; 4
     8f6:	0e 94 d9 21 	call	0x43b2	; 0x43b2 <_ZN7TwoWire11requestFromEii>
     8fa:	e6 01       	movw	r28, r12
     8fc:	5e 01       	movw	r10, r28
     8fe:	ac 18       	sub	r10, r12
     900:	bd 08       	sbc	r11, r13
    
    int i = 0;
    while(Wire.available())         // device may send less than requested (abnormal)
     902:	89 ec       	ldi	r24, 0xC9	; 201
     904:	94 e0       	ldi	r25, 0x04	; 4
     906:	0e 94 b4 20 	call	0x4168	; 0x4168 <_ZN7TwoWire9availableEv>
     90a:	89 2b       	or	r24, r25
     90c:	31 f0       	breq	.+12     	; 0x91a <_ZN7ADXL3458readFromEhiPh+0x74>
    { 
        _buff[i] = Wire.read();    // receive a byte
     90e:	89 ec       	ldi	r24, 0xC9	; 201
     910:	94 e0       	ldi	r25, 0x04	; 4
     912:	0e 94 bc 20 	call	0x4178	; 0x4178 <_ZN7TwoWire4readEv>
     916:	89 93       	st	Y+, r24
    
    Wire.beginTransmission(ADXL345_DEVICE); // start transmission to device
    Wire.requestFrom(ADXL345_DEVICE, num);    // request 6 bytes from device
    
    int i = 0;
    while(Wire.available())         // device may send less than requested (abnormal)
     918:	f1 cf       	rjmp	.-30     	; 0x8fc <_ZN7ADXL3458readFromEhiPh+0x56>
    { 
        _buff[i] = Wire.read();    // receive a byte
        i++;
    }
    if(i != num){
     91a:	ea 14       	cp	r14, r10
     91c:	fb 04       	cpc	r15, r11
     91e:	21 f0       	breq	.+8      	; 0x928 <_ZN7ADXL3458readFromEhiPh+0x82>
        status = ADXL345_ERROR;
     920:	f8 01       	movw	r30, r16
     922:	10 82       	st	Z, r1
        error_code = ADXL345_READ_ERROR;
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	81 83       	std	Z+1, r24	; 0x01
    }
    Wire.endTransmission();         // end transmission
     928:	89 ec       	ldi	r24, 0xC9	; 201
     92a:	94 e0       	ldi	r25, 0x04	; 4
}
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	df 90       	pop	r13
     93a:	cf 90       	pop	r12
     93c:	bf 90       	pop	r11
     93e:	af 90       	pop	r10
    }
    if(i != num){
        status = ADXL345_ERROR;
        error_code = ADXL345_READ_ERROR;
    }
    Wire.endTransmission();         // end transmission
     940:	0c 94 dc 21 	jmp	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>

00000944 <_ZN7ADXL3457readXYZEPiS0_S0_>:

// Reads the acceleration into three variable x, y and z
void ADXL345::readAccel(int *xyz){
    readXYZ(xyz, xyz + 1, xyz + 2);
}
void ADXL345::readXYZ(int *x, int *y, int *z) {
     944:	cf 92       	push	r12
     946:	df 92       	push	r13
     948:	ef 92       	push	r14
     94a:	ff 92       	push	r15
     94c:	0f 93       	push	r16
     94e:	1f 93       	push	r17
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	ec 01       	movw	r28, r24
     956:	6b 01       	movw	r12, r22
     958:	7a 01       	movw	r14, r20
     95a:	89 01       	movw	r16, r18
    readFrom(ADXL345_DATAX0, ADXL345_TO_READ, _buff); //read the acceleration data from the ADXL345
     95c:	9c 01       	movw	r18, r24
     95e:	22 5f       	subi	r18, 0xF2	; 242
     960:	3f 4f       	sbci	r19, 0xFF	; 255
     962:	46 e0       	ldi	r20, 0x06	; 6
     964:	50 e0       	ldi	r21, 0x00	; 0
     966:	62 e3       	ldi	r22, 0x32	; 50
     968:	0e 94 53 04 	call	0x8a6	; 0x8a6 <_ZN7ADXL3458readFromEhiPh>
    *x = (short)((((unsigned short)_buff[1]) << 8) | _buff[0]);   
     96c:	8e 85       	ldd	r24, Y+14	; 0x0e
     96e:	9f 85       	ldd	r25, Y+15	; 0x0f
     970:	f6 01       	movw	r30, r12
     972:	91 83       	std	Z+1, r25	; 0x01
     974:	80 83       	st	Z, r24
    *y = (short)((((unsigned short)_buff[3]) << 8) | _buff[2]);
     976:	88 89       	ldd	r24, Y+16	; 0x10
     978:	99 89       	ldd	r25, Y+17	; 0x11
     97a:	f7 01       	movw	r30, r14
     97c:	91 83       	std	Z+1, r25	; 0x01
     97e:	80 83       	st	Z, r24
    *z = (short)((((unsigned short)_buff[5]) << 8) | _buff[4]);
     980:	8a 89       	ldd	r24, Y+18	; 0x12
     982:	9b 89       	ldd	r25, Y+19	; 0x13
     984:	f8 01       	movw	r30, r16
     986:	91 83       	std	Z+1, r25	; 0x01
     988:	80 83       	st	Z, r24
}
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	1f 91       	pop	r17
     990:	0f 91       	pop	r16
     992:	ff 90       	pop	r15
     994:	ef 90       	pop	r14
     996:	df 90       	pop	r13
     998:	cf 90       	pop	r12
     99a:	08 95       	ret

0000099c <_ZN13AnimationMenuD1Ev>:
		}
		if (i == _itemCount - 1) {
			break;
		}
	}
}
     99c:	08 95       	ret

0000099e <_ZN13AnimationMenu10MenuActionEh>:
     99e:	fc 01       	movw	r30, r24
     9a0:	84 a9       	ldd	r24, Z+52	; 0x34
     9a2:	88 23       	and	r24, r24
     9a4:	b9 f0       	breq	.+46     	; 0x9d4 <_ZN13AnimationMenu10MenuActionEh+0x36>
     9a6:	83 81       	ldd	r24, Z+3	; 0x03
     9a8:	61 30       	cpi	r22, 0x01	; 1
     9aa:	11 f4       	brne	.+4      	; 0x9b0 <_ZN13AnimationMenu10MenuActionEh+0x12>
     9ac:	8f 5f       	subi	r24, 0xFF	; 255
     9ae:	03 c0       	rjmp	.+6      	; 0x9b6 <_ZN13AnimationMenu10MenuActionEh+0x18>
     9b0:	62 30       	cpi	r22, 0x02	; 2
     9b2:	11 f4       	brne	.+4      	; 0x9b8 <_ZN13AnimationMenu10MenuActionEh+0x1a>
     9b4:	81 50       	subi	r24, 0x01	; 1
     9b6:	83 83       	std	Z+3, r24	; 0x03
     9b8:	83 89       	ldd	r24, Z+19	; 0x13
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 17       	cp	r24, r25
     9be:	10 f4       	brcc	.+4      	; 0x9c4 <_ZN13AnimationMenu10MenuActionEh+0x26>
     9c0:	91 e0       	ldi	r25, 0x01	; 1
     9c2:	93 83       	std	Z+3, r25	; 0x03
     9c4:	93 81       	ldd	r25, Z+3	; 0x03
     9c6:	91 11       	cpse	r25, r1
     9c8:	01 c0       	rjmp	.+2      	; 0x9cc <_ZN13AnimationMenu10MenuActionEh+0x2e>
     9ca:	83 83       	std	Z+3, r24	; 0x03
     9cc:	63 30       	cpi	r22, 0x03	; 3
     9ce:	c1 f4       	brne	.+48     	; 0xa00 <_ZN13AnimationMenu10MenuActionEh+0x62>
     9d0:	83 81       	ldd	r24, Z+3	; 0x03
     9d2:	08 95       	ret
     9d4:	62 30       	cpi	r22, 0x02	; 2
     9d6:	49 f4       	brne	.+18     	; 0x9ea <_ZN13AnimationMenu10MenuActionEh+0x4c>
     9d8:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
     9dc:	8d 30       	cpi	r24, 0x0D	; 13
     9de:	18 f4       	brcc	.+6      	; 0x9e6 <_ZN13AnimationMenu10MenuActionEh+0x48>
     9e0:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
     9e4:	0d c0       	rjmp	.+26     	; 0xa00 <_ZN13AnimationMenu10MenuActionEh+0x62>
     9e6:	8c 50       	subi	r24, 0x0C	; 12
     9e8:	09 c0       	rjmp	.+18     	; 0x9fc <_ZN13AnimationMenu10MenuActionEh+0x5e>
     9ea:	61 30       	cpi	r22, 0x01	; 1
     9ec:	49 f4       	brne	.+18     	; 0xa00 <_ZN13AnimationMenu10MenuActionEh+0x62>
     9ee:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
     9f2:	84 3f       	cpi	r24, 0xF4	; 244
     9f4:	10 f0       	brcs	.+4      	; 0x9fa <_ZN13AnimationMenu10MenuActionEh+0x5c>
     9f6:	8f ef       	ldi	r24, 0xFF	; 255
     9f8:	01 c0       	rjmp	.+2      	; 0x9fc <_ZN13AnimationMenu10MenuActionEh+0x5e>
     9fa:	84 5f       	subi	r24, 0xF4	; 244
     9fc:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
     a00:	cf 01       	movw	r24, r30
     a02:	01 90       	ld	r0, Z+
     a04:	f0 81       	ld	r31, Z
     a06:	e0 2d       	mov	r30, r0
     a08:	01 90       	ld	r0, Z+
     a0a:	f0 81       	ld	r31, Z
     a0c:	e0 2d       	mov	r30, r0
     a0e:	09 95       	icall
     a10:	08 95       	ret

00000a12 <_ZN13AnimationMenuD0Ev>:
     a12:	0c 94 87 22 	jmp	0x450e	; 0x450e <_ZdlPv>

00000a16 <_ZN4Menu7prependEPcPKc>:
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	eb 01       	movw	r28, r22
     a24:	8a 01       	movw	r16, r20
     a26:	fa 01       	movw	r30, r20
     a28:	01 90       	ld	r0, Z+
     a2a:	00 20       	and	r0, r0
     a2c:	e9 f7       	brne	.-6      	; 0xa28 <_ZN4Menu7prependEPcPKc+0x12>
     a2e:	31 97       	sbiw	r30, 0x01	; 1
     a30:	7f 01       	movw	r14, r30
     a32:	e4 1a       	sub	r14, r20
     a34:	f5 0a       	sbc	r15, r21
     a36:	fb 01       	movw	r30, r22
     a38:	01 90       	ld	r0, Z+
     a3a:	00 20       	and	r0, r0
     a3c:	e9 f7       	brne	.-6      	; 0xa38 <_ZN4Menu7prependEPcPKc+0x22>
     a3e:	af 01       	movw	r20, r30
     a40:	46 1b       	sub	r20, r22
     a42:	57 0b       	sbc	r21, r23
     a44:	cb 01       	movw	r24, r22
     a46:	8e 0d       	add	r24, r14
     a48:	9f 1d       	adc	r25, r15
     a4a:	0e 94 74 2a 	call	0x54e8	; 0x54e8 <memmove>
     a4e:	f8 01       	movw	r30, r16
     a50:	e0 0e       	add	r14, r16
     a52:	f1 1e       	adc	r15, r17
     a54:	ee 15       	cp	r30, r14
     a56:	ff 05       	cpc	r31, r15
     a58:	19 f0       	breq	.+6      	; 0xa60 <_ZN4Menu7prependEPcPKc+0x4a>
     a5a:	81 91       	ld	r24, Z+
     a5c:	89 93       	st	Y+, r24
     a5e:	fa cf       	rjmp	.-12     	; 0xa54 <_ZN4Menu7prependEPcPKc+0x3e>
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	1f 91       	pop	r17
     a66:	0f 91       	pop	r16
     a68:	ff 90       	pop	r15
     a6a:	ef 90       	pop	r14
     a6c:	08 95       	ret

00000a6e <_ZN13AnimationMenu8ShowMenuEv>:
/**********************Animation**********************/
/*****************************************************/
/*****************************************************/


void AnimationMenu::ShowMenu() {
     a6e:	8f 92       	push	r8
     a70:	9f 92       	push	r9
     a72:	af 92       	push	r10
     a74:	bf 92       	push	r11
     a76:	cf 92       	push	r12
     a78:	df 92       	push	r13
     a7a:	ef 92       	push	r14
     a7c:	ff 92       	push	r15
     a7e:	0f 93       	push	r16
     a80:	1f 93       	push	r17
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	ec 01       	movw	r28, r24
	_oled.clear();
     a88:	4c 01       	movw	r8, r24
     a8a:	84 e0       	ldi	r24, 0x04	; 4
     a8c:	88 0e       	add	r8, r24
     a8e:	91 1c       	adc	r9, r1
     a90:	c4 01       	movw	r24, r8
     a92:	0e 94 8c 06 	call	0xd18	; 0xd18 <_ZN4OLED5clearEv>
	//_oled.setCursor(0, 0);
	//strcpy_P(tempBuffer, (char*)pgm_read_word(&(getCurrentMenu()[0])));
	//_oled.write(tempBuffer);
	
	_brightBuf = map(getBrightness(), 0, 255, 0, SCREEN_CHAR_MAX_LENGTH_SIZE_1);
     a96:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
     a9a:	70 e0       	ldi	r23, 0x00	; 0
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	1f 92       	push	r1
     aa2:	1f 92       	push	r1
     aa4:	1f 92       	push	r1
     aa6:	25 e1       	ldi	r18, 0x15	; 21
     aa8:	2f 93       	push	r18
     aaa:	a1 2c       	mov	r10, r1
     aac:	b1 2c       	mov	r11, r1
     aae:	65 01       	movw	r12, r10
     ab0:	e1 2c       	mov	r14, r1
     ab2:	f1 2c       	mov	r15, r1
     ab4:	87 01       	movw	r16, r14
     ab6:	ea 94       	dec	r14
     ab8:	20 e0       	ldi	r18, 0x00	; 0
     aba:	30 e0       	ldi	r19, 0x00	; 0
     abc:	a9 01       	movw	r20, r18
     abe:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <_Z3maplllll>
     ac2:	6e ab       	std	Y+54, r22	; 0x36
	_oled.setCursor(0, 0);
     ac4:	40 e0       	ldi	r20, 0x00	; 0
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	c4 01       	movw	r24, r8
     aca:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
	strcpy(tempBuffer, "");
     ace:	8e 01       	movw	r16, r28
     ad0:	0c 5e       	subi	r16, 0xEC	; 236
     ad2:	1f 4f       	sbci	r17, 0xFF	; 255
     ad4:	66 e0       	ldi	r22, 0x06	; 6
     ad6:	72 e0       	ldi	r23, 0x02	; 2
     ad8:	c8 01       	movw	r24, r16
     ada:	0e 94 91 2a 	call	0x5522	; 0x5522 <strcpy>
     ade:	0f 90       	pop	r0
     ae0:	0f 90       	pop	r0
     ae2:	0f 90       	pop	r0
     ae4:	0f 90       	pop	r0
	for (byte i = 0; i < _brightBuf; i++)
     ae6:	f1 2c       	mov	r15, r1
     ae8:	8e a9       	ldd	r24, Y+54	; 0x36
     aea:	f8 16       	cp	r15, r24
     aec:	38 f4       	brcc	.+14     	; 0xafc <_ZN13AnimationMenu8ShowMenuEv+0x8e>
	{
		strcat(tempBuffer, "#");
     aee:	63 e2       	ldi	r22, 0x23	; 35
     af0:	71 e0       	ldi	r23, 0x01	; 1
     af2:	c8 01       	movw	r24, r16
     af4:	0e 94 86 2a 	call	0x550c	; 0x550c <strcat>
	//_oled.write(tempBuffer);
	
	_brightBuf = map(getBrightness(), 0, 255, 0, SCREEN_CHAR_MAX_LENGTH_SIZE_1);
	_oled.setCursor(0, 0);
	strcpy(tempBuffer, "");
	for (byte i = 0; i < _brightBuf; i++)
     af8:	f3 94       	inc	r15
     afa:	f6 cf       	rjmp	.-20     	; 0xae8 <_ZN13AnimationMenu8ShowMenuEv+0x7a>
	{
		strcat(tempBuffer, "#");
	}
	_oled.write(tempBuffer);
     afc:	b8 01       	movw	r22, r16
     afe:	c4 01       	movw	r24, r8
     b00:	0e 94 2f 06 	call	0xc5e	; 0xc5e <_ZN4OLED5writeEPKc>
	
	_oled.setCursor(1, 0);
     b04:	40 e0       	ldi	r20, 0x00	; 0
     b06:	61 e0       	ldi	r22, 0x01	; 1
     b08:	c4 01       	movw	r24, r8
     b0a:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
	strcpy_P(tempBuffer, (char*)pgm_read_word(&(getCurrentMenu()[0])));
     b0e:	e0 91 19 01 	lds	r30, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
     b12:	f0 91 1a 01 	lds	r31, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
     b16:	65 91       	lpm	r22, Z+
     b18:	74 91       	lpm	r23, Z
     b1a:	c8 01       	movw	r24, r16
     b1c:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <strcpy_P>
	_oled.write(tempBuffer);
     b20:	b8 01       	movw	r22, r16
     b22:	c4 01       	movw	r24, r8
     b24:	0e 94 2f 06 	call	0xc5e	; 0xc5e <_ZN4OLED5writeEPKc>
	if (_selectedIndex - 1 > _firstVisible + 5) {
     b28:	8b 81       	ldd	r24, Y+3	; 0x03
     b2a:	48 2f       	mov	r20, r24
     b2c:	50 e0       	ldi	r21, 0x00	; 0
     b2e:	2a 89       	ldd	r18, Y+18	; 0x12
     b30:	30 e0       	ldi	r19, 0x00	; 0
     b32:	fa 01       	movw	r30, r20
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	b9 01       	movw	r22, r18
     b38:	6b 5f       	subi	r22, 0xFB	; 251
     b3a:	7f 4f       	sbci	r23, 0xFF	; 255
     b3c:	6e 17       	cp	r22, r30
     b3e:	7f 07       	cpc	r23, r31
     b40:	14 f4       	brge	.+4      	; 0xb46 <_ZN13AnimationMenu8ShowMenuEv+0xd8>
		_firstVisible = _selectedIndex - 1 - 5;
     b42:	86 50       	subi	r24, 0x06	; 6
     b44:	04 c0       	rjmp	.+8      	; 0xb4e <_ZN13AnimationMenu8ShowMenuEv+0xe0>
	}
	else if (_selectedIndex - 1 < _firstVisible) {
     b46:	24 17       	cp	r18, r20
     b48:	35 07       	cpc	r19, r21
     b4a:	14 f0       	brlt	.+4      	; 0xb50 <_ZN13AnimationMenu8ShowMenuEv+0xe2>
		_firstVisible = _selectedIndex - 1;
     b4c:	81 50       	subi	r24, 0x01	; 1
     b4e:	8a 8b       	std	Y+18, r24	; 0x12
	}
	byte p = 5;
	if (p > (_itemCount - _firstVisible + 1)) {
     b50:	db 88       	ldd	r13, Y+19	; 0x13
     b52:	2a 89       	ldd	r18, Y+18	; 0x12
     b54:	8d 2d       	mov	r24, r13
     b56:	90 e0       	ldi	r25, 0x00	; 0
     b58:	82 1b       	sub	r24, r18
     b5a:	91 09       	sbc	r25, r1
     b5c:	04 97       	sbiw	r24, 0x04	; 4
     b5e:	1c f4       	brge	.+6      	; 0xb66 <_ZN13AnimationMenu8ShowMenuEv+0xf8>
		p = _itemCount - _firstVisible + 1;
     b60:	d3 94       	inc	r13
     b62:	d2 1a       	sub	r13, r18
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <_ZN13AnimationMenu8ShowMenuEv+0xfc>
		_firstVisible = _selectedIndex - 1 - 5;
	}
	else if (_selectedIndex - 1 < _firstVisible) {
		_firstVisible = _selectedIndex - 1;
	}
	byte p = 5;
     b66:	95 e0       	ldi	r25, 0x05	; 5
     b68:	d9 2e       	mov	r13, r25
	if (p > (_itemCount - _firstVisible + 1)) {
		p = _itemCount - _firstVisible + 1;
	}
	for (byte i = 0; i <= p; i++) {
     b6a:	c1 2c       	mov	r12, r1
		_oled.setCursor(i + 2, 0);
     b6c:	40 e0       	ldi	r20, 0x00	; 0
     b6e:	62 e0       	ldi	r22, 0x02	; 2
     b70:	6c 0d       	add	r22, r12
     b72:	c4 01       	movw	r24, r8
     b74:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
		strcpy_P(tempBuffer,
			(char*)pgm_read_word(&(getCurrentMenu()[i + _firstVisible + 1])));
     b78:	ec 2c       	mov	r14, r12
     b7a:	f1 2c       	mov	r15, r1
     b7c:	8a 89       	ldd	r24, Y+18	; 0x12
     b7e:	f7 01       	movw	r30, r14
     b80:	e8 0f       	add	r30, r24
     b82:	f1 1d       	adc	r31, r1
     b84:	31 96       	adiw	r30, 0x01	; 1
     b86:	ee 0f       	add	r30, r30
     b88:	ff 1f       	adc	r31, r31
     b8a:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
     b8e:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
     b92:	e8 0f       	add	r30, r24
     b94:	f9 1f       	adc	r31, r25
     b96:	65 91       	lpm	r22, Z+
     b98:	74 91       	lpm	r23, Z
     b9a:	c8 01       	movw	r24, r16
     b9c:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <strcpy_P>
		if (getMenuWithAni() == getCurrentMenu()
			&& i == _currentAni - 1 - _firstVisible) {
     ba0:	40 91 17 01 	lds	r20, 0x0117	; 0x800117 <_ZN4Menu11MenuWithAniE>
     ba4:	50 91 18 01 	lds	r21, 0x0118	; 0x800118 <_ZN4Menu11MenuWithAniE+0x1>
     ba8:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
     bac:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
     bb0:	2a 89       	ldd	r18, Y+18	; 0x12
     bb2:	48 17       	cp	r20, r24
     bb4:	59 07       	cpc	r21, r25
     bb6:	e9 f4       	brne	.+58     	; 0xbf2 <_ZN13AnimationMenu8ShowMenuEv+0x184>
     bb8:	8d a9       	ldd	r24, Y+53	; 0x35
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	01 97       	sbiw	r24, 0x01	; 1
     bbe:	82 1b       	sub	r24, r18
     bc0:	91 09       	sbc	r25, r1
     bc2:	e8 16       	cp	r14, r24
     bc4:	f9 06       	cpc	r15, r25
     bc6:	a9 f4       	brne	.+42     	; 0xbf2 <_ZN13AnimationMenu8ShowMenuEv+0x184>
			prepend(tempBuffer, "`");
     bc8:	45 e2       	ldi	r20, 0x25	; 37
     bca:	51 e0       	ldi	r21, 0x01	; 1
		else if (i == _selectedIndex - 1 - _firstVisible) {
			prepend(tempBuffer, ">");
			_oled.write(tempBuffer);
		}
		else if (i < _itemCount) {
			prepend(tempBuffer, " ");
     bcc:	b8 01       	movw	r22, r16
     bce:	ce 01       	movw	r24, r28
     bd0:	0e 94 0b 05 	call	0xa16	; 0xa16 <_ZN4Menu7prependEPcPKc>
			_oled.write(tempBuffer);
     bd4:	b8 01       	movw	r22, r16
     bd6:	c4 01       	movw	r24, r8
     bd8:	0e 94 2f 06 	call	0xc5e	; 0xc5e <_ZN4OLED5writeEPKc>
		}
		if (i == _itemCount - 1) {
     bdc:	8b 89       	ldd	r24, Y+19	; 0x13
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	e8 16       	cp	r14, r24
     be4:	f9 06       	cpc	r15, r25
     be6:	b1 f0       	breq	.+44     	; 0xc14 <_ZN13AnimationMenu8ShowMenuEv+0x1a6>
	}
	byte p = 5;
	if (p > (_itemCount - _firstVisible + 1)) {
		p = _itemCount - _firstVisible + 1;
	}
	for (byte i = 0; i <= p; i++) {
     be8:	c3 94       	inc	r12
     bea:	dc 14       	cp	r13, r12
     bec:	08 f0       	brcs	.+2      	; 0xbf0 <_ZN13AnimationMenu8ShowMenuEv+0x182>
     bee:	be cf       	rjmp	.-132    	; 0xb6c <_ZN13AnimationMenu8ShowMenuEv+0xfe>
     bf0:	11 c0       	rjmp	.+34     	; 0xc14 <_ZN13AnimationMenu8ShowMenuEv+0x1a6>
		if (getMenuWithAni() == getCurrentMenu()
			&& i == _currentAni - 1 - _firstVisible) {
			prepend(tempBuffer, "`");
			_oled.write(tempBuffer);
		}
		else if (i == _selectedIndex - 1 - _firstVisible) {
     bf2:	8b 81       	ldd	r24, Y+3	; 0x03
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	01 97       	sbiw	r24, 0x01	; 1
     bf8:	82 1b       	sub	r24, r18
     bfa:	91 09       	sbc	r25, r1
     bfc:	e8 16       	cp	r14, r24
     bfe:	f9 06       	cpc	r15, r25
     c00:	19 f4       	brne	.+6      	; 0xc08 <_ZN13AnimationMenu8ShowMenuEv+0x19a>
			prepend(tempBuffer, ">");
     c02:	4f e1       	ldi	r20, 0x1F	; 31
     c04:	51 e0       	ldi	r21, 0x01	; 1
     c06:	e2 cf       	rjmp	.-60     	; 0xbcc <_ZN13AnimationMenu8ShowMenuEv+0x15e>
			_oled.write(tempBuffer);
		}
		else if (i < _itemCount) {
     c08:	8b 89       	ldd	r24, Y+19	; 0x13
     c0a:	c8 16       	cp	r12, r24
     c0c:	38 f7       	brcc	.-50     	; 0xbdc <_ZN13AnimationMenu8ShowMenuEv+0x16e>
			prepend(tempBuffer, " ");
     c0e:	41 e2       	ldi	r20, 0x21	; 33
     c10:	51 e0       	ldi	r21, 0x01	; 1
     c12:	dc cf       	rjmp	.-72     	; 0xbcc <_ZN13AnimationMenu8ShowMenuEv+0x15e>
	}
	/*Serial.print("selected index: ");
	Serial.println(_selectedIndex);
	Serial.print("first visible: ");
	Serial.println(_firstVisible);*/
}
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	ff 90       	pop	r15
     c1e:	ef 90       	pop	r14
     c20:	df 90       	pop	r13
     c22:	cf 90       	pop	r12
     c24:	bf 90       	pop	r11
     c26:	af 90       	pop	r10
     c28:	9f 90       	pop	r9
     c2a:	8f 90       	pop	r8
     c2c:	08 95       	ret

00000c2e <_ZN5Print17availableForWriteEv>:
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	08 95       	ret

00000c34 <_ZN5Print5flushEv>:
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     c34:	08 95       	ret

00000c36 <_ZN4OLED11EndTransferEv>:
}

/***************************************/

void OLED::EndTransfer() {
	if (!i2cIgnoreEnd)
     c36:	fc 01       	movw	r30, r24
     c38:	84 85       	ldd	r24, Z+12	; 0x0c
     c3a:	81 11       	cpse	r24, r1
     c3c:	04 c0       	rjmp	.+8      	; 0xc46 <_ZN4OLED11EndTransferEv+0x10>
	Wire.endTransmission();
     c3e:	89 ec       	ldi	r24, 0xC9	; 201
     c40:	94 e0       	ldi	r25, 0x04	; 4
     c42:	0c 94 dc 21 	jmp	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>
     c46:	08 95       	ret

00000c48 <_ZN4OLED18I2CRestartTransferEv>:
}

/***************************************/

void OLED::I2CRestartTransfer() {
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
     c4c:	ec 01       	movw	r28, r24
	Wire.endTransmission();
     c4e:	89 ec       	ldi	r24, 0xC9	; 201
     c50:	94 e0       	ldi	r25, 0x04	; 4
     c52:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>
	i2cCount = 0;
     c56:	1a 86       	std	Y+10, r1	; 0x0a
}
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <_ZN4OLED5writeEPKc>:

//------------------------------------------------------------------------------
// write(*str) - write a string of characters
//------------------------------------------------------------------------------
int OLED::write(const char* str) {
	return write((const uint8_t *)str, strlen(str));
     c5e:	fb 01       	movw	r30, r22
     c60:	01 90       	ld	r0, Z+
     c62:	00 20       	and	r0, r0
     c64:	e9 f7       	brne	.-6      	; 0xc60 <_ZN4OLED5writeEPKc+0x2>
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	af 01       	movw	r20, r30
     c6a:	46 1b       	sub	r20, r22
     c6c:	57 0b       	sbc	r21, r23
     c6e:	dc 01       	movw	r26, r24
     c70:	ed 91       	ld	r30, X+
     c72:	fc 91       	ld	r31, X
     c74:	02 80       	ldd	r0, Z+2	; 0x02
     c76:	f3 81       	ldd	r31, Z+3	; 0x03
     c78:	e0 2d       	mov	r30, r0
     c7a:	09 94       	ijmp

00000c7c <_ZN4OLED9WriteDataEh>:

inline void OLED::SelectData() { i2cControl = 0x40; }

/***************************************/

inline void OLED::WriteData(uint8_t b) {
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	16 2f       	mov	r17, r22
	if ((i2cCount == 0) || (i2cCount == (BUFFER_LENGTH - 1))) {
     c86:	8a 85       	ldd	r24, Y+10	; 0x0a
     c88:	88 23       	and	r24, r24
     c8a:	11 f0       	breq	.+4      	; 0xc90 <_ZN4OLED9WriteDataEh+0x14>
     c8c:	8f 31       	cpi	r24, 0x1F	; 31
     c8e:	81 f4       	brne	.+32     	; 0xcb0 <_ZN4OLED9WriteDataEh+0x34>
		i2cCount = 0;
     c90:	1a 86       	std	Y+10, r1	; 0x0a
		Wire.endTransmission();
     c92:	89 ec       	ldi	r24, 0xC9	; 201
     c94:	94 e0       	ldi	r25, 0x04	; 4
     c96:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <_ZN7TwoWire15endTransmissionEv>
		Wire.beginTransmission(SSD1306_I2C_ADDRESS);
     c9a:	6c e3       	ldi	r22, 0x3C	; 60
     c9c:	70 e0       	ldi	r23, 0x00	; 0
     c9e:	89 ec       	ldi	r24, 0xC9	; 201
     ca0:	94 e0       	ldi	r25, 0x04	; 4
     ca2:	0e 94 60 21 	call	0x42c0	; 0x42c0 <_ZN7TwoWire17beginTransmissionEi>
		Wire.write(i2cControl);
     ca6:	6b 85       	ldd	r22, Y+11	; 0x0b
     ca8:	89 ec       	ldi	r24, 0xC9	; 201
     caa:	94 e0       	ldi	r25, 0x04	; 4
     cac:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN7TwoWire5writeEh>
	}
	Wire.write(b);
     cb0:	61 2f       	mov	r22, r17
     cb2:	89 ec       	ldi	r24, 0xC9	; 201
     cb4:	94 e0       	ldi	r25, 0x04	; 4
     cb6:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN7TwoWire5writeEh>
	i2cCount++;
     cba:	8a 85       	ldd	r24, Y+10	; 0x0a
     cbc:	8f 5f       	subi	r24, 0xFF	; 255
     cbe:	8a 87       	std	Y+10, r24	; 0x0a
}
     cc0:	df 91       	pop	r29
     cc2:	cf 91       	pop	r28
     cc4:	1f 91       	pop	r17
     cc6:	08 95       	ret

00000cc8 <_ZN4OLED4initEv>:
void OLED::I2CRestartTransfer() {
	Wire.endTransmission();
	i2cCount = 0;
}

void OLED::init() {
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	cf 93       	push	r28
     cce:	df 93       	push	r29
     cd0:	ec 01       	movw	r28, r24
	col_ = 0;
     cd2:	1c 82       	std	Y+4, r1	; 0x04
	row_ = 0;
     cd4:	1d 82       	std	Y+5, r1	; 0x05
	textSize_ = 1;
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	8e 83       	std	Y+6, r24	; 0x06
	textSpacing_ = 1;
     cda:	8f 83       	std	Y+7, r24	; 0x07
	//#if USE_2X_FONT || USE_3X_FONT || USE_8X_FONT || SCALED_FONTS
	//	transparentSpacing_ = true;
	//#endif

	Wire.begin();
     cdc:	89 ec       	ldi	r24, 0xC9	; 201
     cde:	94 e0       	ldi	r25, 0x04	; 4
     ce0:	0e 94 4c 21 	call	0x4298	; 0x4298 <_ZN7TwoWire5beginEv>
	i2cIgnoreEnd = false;
     ce4:	1c 86       	std	Y+12, r1	; 0x0c
	#ifdef TWBR_INIT_VALUE
	TWBR = TWBR_INIT_VALUE; // set I2C clock rate (assumed prescale)
     ce6:	8c e0       	ldi	r24, 0x0C	; 12
     ce8:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
     cec:	1a 86       	std	Y+10, r1	; 0x0a
}

/***************************************/

inline void OLED::SelectCommand() { i2cControl = 0x00; }
     cee:	1b 86       	std	Y+11, r1	; 0x0b
     cf0:	00 eb       	ldi	r16, 0xB0	; 176
     cf2:	10 e0       	ldi	r17, 0x00	; 0

	// Send initialization command sequence
	StartTransfer();
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(initTable); i++)
	WriteData(pgm_read_byte(initTable + i));
     cf4:	f8 01       	movw	r30, r16
     cf6:	64 91       	lpm	r22, Z
     cf8:	ce 01       	movw	r24, r28
     cfa:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
     cfe:	0f 5f       	subi	r16, 0xFF	; 255
     d00:	1f 4f       	sbci	r17, 0xFF	; 255
	#endif

	// Send initialization command sequence
	StartTransfer();
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(initTable); i++)
     d02:	f0 e0       	ldi	r31, 0x00	; 0
     d04:	09 3c       	cpi	r16, 0xC9	; 201
     d06:	1f 07       	cpc	r17, r31
     d08:	a9 f7       	brne	.-22     	; 0xcf4 <_ZN4OLED4initEv+0x2c>
	WriteData(pgm_read_byte(initTable + i));
	EndTransfer();
     d0a:	ce 01       	movw	r24, r28
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
	// Send initialization command sequence
	StartTransfer();
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(initTable); i++)
	WriteData(pgm_read_byte(initTable + i));
	EndTransfer();
     d14:	0c 94 1b 06 	jmp	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>

00000d18 <_ZN4OLED5clearEv>:
}

void OLED::clear() {
     d18:	ef 92       	push	r14
     d1a:	ff 92       	push	r15
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	ec 01       	movw	r28, r24
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
     d26:	1a 86       	std	Y+10, r1	; 0x0a
}

/***************************************/

inline void OLED::SelectCommand() { i2cControl = 0x00; }
     d28:	1b 86       	std	Y+11, r1	; 0x0b
     d2a:	0a ea       	ldi	r16, 0xAA	; 170
     d2c:	10 e0       	ldi	r17, 0x00	; 0
     d2e:	80 eb       	ldi	r24, 0xB0	; 176
     d30:	e8 2e       	mov	r14, r24
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	f8 2e       	mov	r15, r24

void OLED::clear() {
	StartTransfer();
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(clearScreenTable); i++)
	WriteData(pgm_read_byte(clearScreenTable + i));
     d36:	f8 01       	movw	r30, r16
     d38:	64 91       	lpm	r22, Z
     d3a:	ce 01       	movw	r24, r28
     d3c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
     d40:	0f 5f       	subi	r16, 0xFF	; 255
     d42:	1f 4f       	sbci	r17, 0xFF	; 255
}

void OLED::clear() {
	StartTransfer();
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(clearScreenTable); i++)
     d44:	e0 16       	cp	r14, r16
     d46:	f1 06       	cpc	r15, r17
     d48:	b1 f7       	brne	.-20     	; 0xd36 <_ZN4OLED5clearEv+0x1e>
	WriteData(pgm_read_byte(clearScreenTable + i));
	I2CRestartTransfer();
     d4a:	ce 01       	movw	r24, r28
     d4c:	0e 94 24 06 	call	0xc48	; 0xc48 <_ZN4OLED18I2CRestartTransferEv>

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
     d50:	80 e4       	ldi	r24, 0x40	; 64
     d52:	8b 87       	std	Y+11, r24	; 0x0b
     d54:	00 e0       	ldi	r16, 0x00	; 0
     d56:	14 e0       	ldi	r17, 0x04	; 4
	for (uint8_t i = 0; i<sizeof(clearScreenTable); i++)
	WriteData(pgm_read_byte(clearScreenTable + i));
	I2CRestartTransfer();
	SelectData();
	for (uint16_t i = 0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT / 8); i++) {
		WriteData(0);
     d58:	60 e0       	ldi	r22, 0x00	; 0
     d5a:	ce 01       	movw	r24, r28
     d5c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
     d60:	01 50       	subi	r16, 0x01	; 1
     d62:	11 09       	sbc	r17, r1
	SelectCommand();
	for (uint8_t i = 0; i<sizeof(clearScreenTable); i++)
	WriteData(pgm_read_byte(clearScreenTable + i));
	I2CRestartTransfer();
	SelectData();
	for (uint16_t i = 0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT / 8); i++) {
     d64:	c9 f7       	brne	.-14     	; 0xd58 <_ZN4OLED5clearEv+0x40>
		WriteData(0);
	}
	EndTransfer();
     d66:	ce 01       	movw	r24, r28
     d68:	0e 94 1b 06 	call	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>
	col_ = 0;
     d6c:	1c 82       	std	Y+4, r1	; 0x04
	row_ = 0;
     d6e:	1d 82       	std	Y+5, r1	; 0x05
}
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	ff 90       	pop	r15
     d7a:	ef 90       	pop	r14
     d7c:	08 95       	ret

00000d7e <_ZN4OLED9setCursorEhh>:

void OLED::setCursor(uint8_t row, uint8_t col) {
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	ec 01       	movw	r28, r24
	row_ = row % (SSD1306_LCDHEIGHT / 8);
     d84:	67 70       	andi	r22, 0x07	; 7
     d86:	6d 83       	std	Y+5, r22	; 0x05
	col_ = col % SSD1306_LCDWIDTH;
     d88:	84 2f       	mov	r24, r20
     d8a:	8f 77       	andi	r24, 0x7F	; 127
     d8c:	8c 83       	std	Y+4, r24	; 0x04
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
     d8e:	1a 86       	std	Y+10, r1	; 0x0a
}

/***************************************/

inline void OLED::SelectCommand() { i2cControl = 0x00; }
     d90:	1b 86       	std	Y+11, r1	; 0x0b
	row_ = row % (SSD1306_LCDHEIGHT / 8);
	col_ = col % SSD1306_LCDWIDTH;

	StartTransfer();
	SelectCommand();
	WriteData(SSD1306_SETLOWCOLUMN | (col_ & 0XF));
     d92:	64 2f       	mov	r22, r20
     d94:	6f 70       	andi	r22, 0x0F	; 15
     d96:	ce 01       	movw	r24, r28
     d98:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
	WriteData(SSD1306_SETHIGHCOLUMN | (col_ >> 4));
     d9c:	6c 81       	ldd	r22, Y+4	; 0x04
     d9e:	65 95       	asr	r22
     da0:	65 95       	asr	r22
     da2:	65 95       	asr	r22
     da4:	65 95       	asr	r22
     da6:	60 61       	ori	r22, 0x10	; 16
     da8:	ce 01       	movw	r24, r28
     daa:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
	WriteData(SSD1306_SETSTARTPAGE | row_);
     dae:	6d 81       	ldd	r22, Y+5	; 0x05
     db0:	60 6b       	ori	r22, 0xB0	; 176
     db2:	ce 01       	movw	r24, r28
     db4:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
	EndTransfer();
     db8:	ce 01       	movw	r24, r28
}
     dba:	df 91       	pop	r29
     dbc:	cf 91       	pop	r28
	StartTransfer();
	SelectCommand();
	WriteData(SSD1306_SETLOWCOLUMN | (col_ & 0XF));
	WriteData(SSD1306_SETHIGHCOLUMN | (col_ >> 4));
	WriteData(SSD1306_SETSTARTPAGE | row_);
	EndTransfer();
     dbe:	0c 94 1b 06 	jmp	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>

00000dc2 <_ZN4OLED5writeEPKhj>:
//------------------------------------------------------------------------------
// write(*buffer, size) - write multiple characters
//
// I2C is optimized in this routine to better utilize the Wire library buffer.
//------------------------------------------------------------------------------
size_t OLED::write(const uint8_t *buffer, size_t size) {
     dc2:	cf 92       	push	r12
     dc4:	df 92       	push	r13
     dc6:	ef 92       	push	r14
     dc8:	ff 92       	push	r15
     dca:	0f 93       	push	r16
     dcc:	1f 93       	push	r17
     dce:	cf 93       	push	r28
     dd0:	df 93       	push	r29
     dd2:	8c 01       	movw	r16, r24
     dd4:	7a 01       	movw	r14, r20
     dd6:	eb 01       	movw	r28, r22
     dd8:	6b 01       	movw	r12, r22
     dda:	c4 0e       	add	r12, r20
     ddc:	d5 1e       	adc	r13, r21
	#if I2C
	i2cIgnoreEnd = true;
	#endif
	for (size_t i = 0; i<size; i++) {
     dde:	cc 15       	cp	r28, r12
     de0:	dd 05       	cpc	r29, r13
     de2:	d1 f0       	breq	.+52     	; 0xe18 <_ZN4OLED5writeEPKhj+0x56>
		char c = *buffer++;
     de4:	69 91       	ld	r22, Y+
		if (c == '\n') {
     de6:	6a 30       	cpi	r22, 0x0A	; 10
     de8:	61 f4       	brne	.+24     	; 0xe02 <_ZN4OLED5writeEPKhj+0x40>
			#if I2C
			i2cIgnoreEnd = false;
			EndTransfer();
			#endif
			setCursor(row_ + textSize_);
     dea:	d8 01       	movw	r26, r16
     dec:	15 96       	adiw	r26, 0x05	; 5
     dee:	6c 91       	ld	r22, X
     df0:	15 97       	sbiw	r26, 0x05	; 5
     df2:	16 96       	adiw	r26, 0x06	; 6
     df4:	8c 91       	ld	r24, X
     df6:	68 0f       	add	r22, r24
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
     e00:	ee cf       	rjmp	.-36     	; 0xdde <_ZN4OLED5writeEPKhj+0x1c>
			#if I2C
			i2cIgnoreEnd = true;
			#endif
		}
		else if (c != '\r')
     e02:	6d 30       	cpi	r22, 0x0D	; 13
     e04:	61 f3       	breq	.-40     	; 0xdde <_ZN4OLED5writeEPKhj+0x1c>
		write((uint8_t)c);
     e06:	d8 01       	movw	r26, r16
     e08:	ed 91       	ld	r30, X+
     e0a:	fc 91       	ld	r31, X
     e0c:	01 90       	ld	r0, Z+
     e0e:	f0 81       	ld	r31, Z
     e10:	e0 2d       	mov	r30, r0
     e12:	c8 01       	movw	r24, r16
     e14:	09 95       	icall
//------------------------------------------------------------------------------
size_t OLED::write(const uint8_t *buffer, size_t size) {
	#if I2C
	i2cIgnoreEnd = true;
	#endif
	for (size_t i = 0; i<size; i++) {
     e16:	e3 cf       	rjmp	.-58     	; 0xdde <_ZN4OLED5writeEPKhj+0x1c>
	#if I2C
	i2cIgnoreEnd = false;
	EndTransfer();
	#endif
	return size;
}
     e18:	c7 01       	movw	r24, r14
     e1a:	df 91       	pop	r29
     e1c:	cf 91       	pop	r28
     e1e:	1f 91       	pop	r17
     e20:	0f 91       	pop	r16
     e22:	ff 90       	pop	r15
     e24:	ef 90       	pop	r14
     e26:	df 90       	pop	r13
     e28:	cf 90       	pop	r12
     e2a:	08 95       	ret

00000e2c <_ZN4OLED5writeEh>:
// Custom fonts for the numeric characters (0-9) are optional for 2x, 3x, 8x.
//
// The cursor location is adjusted to where the next character would go,
// depending on the text size and text spacing
//------------------------------------------------------------------------------
size_t OLED::write(uint8_t c) {
     e2c:	3f 92       	push	r3
     e2e:	4f 92       	push	r4
     e30:	5f 92       	push	r5
     e32:	6f 92       	push	r6
     e34:	7f 92       	push	r7
     e36:	8f 92       	push	r8
     e38:	9f 92       	push	r9
     e3a:	af 92       	push	r10
     e3c:	bf 92       	push	r11
     e3e:	cf 92       	push	r12
     e40:	df 92       	push	r13
     e42:	ef 92       	push	r14
     e44:	ff 92       	push	r15
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29

	if (c == '\r') return 1;
     e4e:	6d 30       	cpi	r22, 0x0D	; 13
     e50:	09 f4       	brne	.+2      	; 0xe54 <_ZN4OLED5writeEh+0x28>
     e52:	4c c1       	rjmp	.+664    	; 0x10ec <_ZN4OLED5writeEh+0x2c0>
     e54:	26 2f       	mov	r18, r22
     e56:	ec 01       	movw	r28, r24
     e58:	1e 81       	ldd	r17, Y+6	; 0x06
	if (c == '\n') {
     e5a:	6a 30       	cpi	r22, 0x0A	; 10
     e5c:	21 f4       	brne	.+8      	; 0xe66 <_ZN4OLED5writeEh+0x3a>
		setCursor(row_ + textSize_);
     e5e:	6d 81       	ldd	r22, Y+5	; 0x05
     e60:	61 0f       	add	r22, r17
     e62:	40 e0       	ldi	r20, 0x00	; 0
     e64:	6f c0       	rjmp	.+222    	; 0xf44 <_ZN4OLED5writeEh+0x118>
		return 1;
	}

	#if PROPORTIONAL_PUNCTUATION
	uint8_t slices = (((c == '.') || (c == ':')) ? 3 : 5);	// proportional spacing
     e66:	6e 32       	cpi	r22, 0x2E	; 46
     e68:	11 f0       	breq	.+4      	; 0xe6e <_ZN4OLED5writeEh+0x42>
     e6a:	6a 33       	cpi	r22, 0x3A	; 58
     e6c:	19 f4       	brne	.+6      	; 0xe74 <_ZN4OLED5writeEh+0x48>
     e6e:	53 e0       	ldi	r21, 0x03	; 3
     e70:	e5 2e       	mov	r14, r21
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <_ZN4OLED5writeEh+0x4c>
     e74:	45 e0       	ldi	r20, 0x05	; 5
     e76:	e4 2e       	mov	r14, r20
     e78:	0c 81       	ldd	r16, Y+4	; 0x04
     e7a:	82 2f       	mov	r24, r18
     e7c:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// ----------------------------------------------------------------------------
	// Single height 5x7 font characters
	// ----------------------------------------------------------------------------
	if (textSize_ == 1) {		// dedicated code since it's faster than scaling
     e7e:	11 30       	cpi	r17, 0x01	; 1
     e80:	69 f5       	brne	.+90     	; 0xedc <_ZN4OLED5writeEh+0xb0>
		
		
		col_ += 5;	// x5 font
     e82:	0b 5f       	subi	r16, 0xFB	; 251
     e84:	0c 83       	std	Y+4, r16	; 0x04
		uint8_t *base = (uint8_t *)font + 5 * (c - 32);
     e86:	80 97       	sbiw	r24, 0x20	; 32
     e88:	25 e0       	ldi	r18, 0x05	; 5
     e8a:	28 9f       	mul	r18, r24
     e8c:	80 01       	movw	r16, r0
     e8e:	29 9f       	mul	r18, r25
     e90:	10 0d       	add	r17, r0
     e92:	11 24       	eor	r1, r1
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
     e94:	1a 86       	std	Y+10, r1	; 0x0a

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
     e96:	80 e4       	ldi	r24, 0x40	; 64
     e98:	8b 87       	std	Y+11, r24	; 0x0b
     e9a:	c1 2c       	mov	r12, r1
     e9c:	d1 2c       	mov	r13, r1
		uint8_t *base = (uint8_t *)font + 5 * (c - 32);

		StartTransfer();
		SelectData();
		for (uint8_t i = 0; i < slices; i++) {
			uint8_t b = pgm_read_byte(base + i);
     e9e:	f8 01       	movw	r30, r16
     ea0:	ec 0d       	add	r30, r12
     ea2:	fd 1d       	adc	r31, r13
     ea4:	ee 50       	subi	r30, 0x0E	; 14
     ea6:	fd 4f       	sbci	r31, 0xFD	; 253
     ea8:	64 91       	lpm	r22, Z
			WriteData(b);
     eaa:	ce 01       	movw	r24, r28
     eac:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
     eb0:	2f ef       	ldi	r18, 0xFF	; 255
     eb2:	c2 1a       	sub	r12, r18
     eb4:	d2 0a       	sbc	r13, r18
		col_ += 5;	// x5 font
		uint8_t *base = (uint8_t *)font + 5 * (c - 32);

		StartTransfer();
		SelectData();
		for (uint8_t i = 0; i < slices; i++) {
     eb6:	ce 14       	cp	r12, r14
     eb8:	90 f3       	brcs	.-28     	; 0xe9e <_ZN4OLED5writeEh+0x72>
     eba:	10 e0       	ldi	r17, 0x00	; 0
			uint8_t b = pgm_read_byte(base + i);
			WriteData(b);
		}
		for (uint8_t i = 0; i < textSpacing_; i++) {
     ebc:	8f 81       	ldd	r24, Y+7	; 0x07
     ebe:	18 17       	cp	r17, r24
     ec0:	48 f4       	brcc	.+18     	; 0xed4 <_ZN4OLED5writeEh+0xa8>
			if (col_ >= SSD1306_LCDWIDTH) break;
			col_++;
     ec2:	8c 81       	ldd	r24, Y+4	; 0x04
     ec4:	8f 5f       	subi	r24, 0xFF	; 255
     ec6:	8c 83       	std	Y+4, r24	; 0x04
			WriteData(0);	// textSpacing_ pixels of blank space between characters
     ec8:	60 e0       	ldi	r22, 0x00	; 0
     eca:	ce 01       	movw	r24, r28
     ecc:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
		SelectData();
		for (uint8_t i = 0; i < slices; i++) {
			uint8_t b = pgm_read_byte(base + i);
			WriteData(b);
		}
		for (uint8_t i = 0; i < textSpacing_; i++) {
     ed0:	1f 5f       	subi	r17, 0xFF	; 255
     ed2:	f4 cf       	rjmp	.-24     	; 0xebc <_ZN4OLED5writeEh+0x90>
			if (col_ >= SSD1306_LCDWIDTH) break;
			col_++;
			WriteData(0);	// textSpacing_ pixels of blank space between characters
		}
		EndTransfer();
     ed4:	ce 01       	movw	r24, r28
     ed6:	0e 94 1b 06 	call	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>
     eda:	08 c1       	rjmp	.+528    	; 0x10ec <_ZN4OLED5writeEh+0x2c0>
		// ----------------------------------------------------------------------------
		// Larger fonts for numeric characters ('0' - '9')
		// ----------------------------------------------------------------------------
		#if USE_2X_FONT || USE_3X_FONT || USE_8X_FONT
	}
	else if (((c >= '0') && (c <= '9')) && (pgm_read_word(&fTbl[textSize_ - 2]))) {
     edc:	20 53       	subi	r18, 0x30	; 48
     ede:	dd 80       	ldd	r13, Y+5	; 0x05
     ee0:	2a 30       	cpi	r18, 0x0A	; 10
     ee2:	08 f0       	brcs	.+2      	; 0xee6 <_ZN4OLED5writeEh+0xba>
     ee4:	33 c0       	rjmp	.+102    	; 0xf4c <_ZN4OLED5writeEh+0x120>
     ee6:	e1 2f       	mov	r30, r17
     ee8:	f0 e0       	ldi	r31, 0x00	; 0
     eea:	ee 0f       	add	r30, r30
     eec:	ff 1f       	adc	r31, r31
     eee:	9f 01       	movw	r18, r30
     ef0:	2b 53       	subi	r18, 0x3B	; 59
     ef2:	3f 4f       	sbci	r19, 0xFF	; 255
     ef4:	f9 01       	movw	r30, r18
     ef6:	45 91       	lpm	r20, Z+
     ef8:	54 91       	lpm	r21, Z
     efa:	45 2b       	or	r20, r21
     efc:	39 f1       	breq	.+78     	; 0xf4c <_ZN4OLED5writeEh+0x120>

		uint16_t ptr = pgm_read_word(pgm_read_word(&fTbl[textSize_ - 2]) + sizeof(uint16_t)*(c - '0'));
     efe:	f9 01       	movw	r30, r18
     f00:	25 91       	lpm	r18, Z+
     f02:	34 91       	lpm	r19, Z
     f04:	fc 01       	movw	r30, r24
     f06:	f0 97       	sbiw	r30, 0x30	; 48
     f08:	ee 0f       	add	r30, r30
     f0a:	ff 1f       	adc	r31, r31
     f0c:	e2 0f       	add	r30, r18
     f0e:	f3 1f       	adc	r31, r19
     f10:	e5 90       	lpm	r14, Z+
     f12:	f4 90       	lpm	r15, Z
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t columns = textSize_ * 5;
     f14:	81 2e       	mov	r8, r17
     f16:	88 0c       	add	r8, r8
     f18:	88 0c       	add	r8, r8
     f1a:	81 0e       	add	r8, r17
		uint8_t rows = (textSize_ == 8 ? textSize_ - 1 : textSize_);
     f1c:	18 30       	cpi	r17, 0x08	; 8
     f1e:	09 f4       	brne	.+2      	; 0xf22 <_ZN4OLED5writeEh+0xf6>
     f20:	17 e0       	ldi	r17, 0x07	; 7
		uint8_t b, instruction, count, columnCnt, d;
		for (uint8_t irow = 0; irow < rows; irow++) {
     f22:	91 2c       	mov	r9, r1

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
     f24:	20 e4       	ldi	r18, 0x40	; 64
     f26:	62 2e       	mov	r6, r18
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t columns = textSize_ * 5;
		uint8_t rows = (textSize_ == 8 ? textSize_ - 1 : textSize_);
		uint8_t b, instruction, count, columnCnt, d;
		for (uint8_t irow = 0; irow < rows; irow++) {
     f28:	91 12       	cpse	r9, r17
     f2a:	8b c0       	rjmp	.+278    	; 0x1042 <_ZN4OLED5writeEh+0x216>
			} // while columnCnt
			if (!transparentSpacing_)
			for (uint8_t i = 0; i<textSpacing_; i++)
			WriteData(0);
		} // for irow
		EndTransfer();
     f2c:	ce 01       	movw	r24, r28
     f2e:	0e 94 1b 06 	call	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>
		setCursor(startRow, startCol + 5 * textSize_ + textSpacing_);
     f32:	4e 81       	ldd	r20, Y+6	; 0x06
     f34:	84 2f       	mov	r24, r20
     f36:	88 0f       	add	r24, r24
     f38:	88 0f       	add	r24, r24
     f3a:	48 0f       	add	r20, r24
     f3c:	04 0f       	add	r16, r20
     f3e:	4f 81       	ldd	r20, Y+7	; 0x07
     f40:	40 0f       	add	r20, r16
			if (!transparentSpacing_)
			for (uint8_t i = 0; i<textSpacing_; i++)
			WriteData(0);
		}
		EndTransfer();
		setCursor(startRow, startCol + slices*textSize_ + textSpacing_);
     f42:	6d 2d       	mov	r22, r13
     f44:	ce 01       	movw	r24, r28
     f46:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
     f4a:	d0 c0       	rjmp	.+416    	; 0x10ec <_ZN4OLED5writeEh+0x2c0>
			if (irow > 0)
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
     f4c:	80 97       	sbiw	r24, 0x20	; 32
     f4e:	25 e0       	ldi	r18, 0x05	; 5
     f50:	28 9f       	mul	r18, r24
     f52:	50 01       	movw	r10, r0
     f54:	29 9f       	mul	r18, r25
     f56:	b0 0c       	add	r11, r0
     f58:	11 24       	eor	r1, r1
     f5a:	c1 2c       	mov	r12, r1
		uint8_t sourceSlice, targetSlice, sourceBitMask, targetBitMask, extractedBit, targetBitCount;
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t irow8, sourceBitMaskInit, targetBitCountInit;

		for (uint8_t irow = 0; irow < textSize_; irow++) {
     f5c:	f1 2c       	mov	r15, r1
			irow8 = irow * 8;
			sourceBitMaskInit = 1 << (irow8 / textSize_);
     f5e:	55 24       	eor	r5, r5
     f60:	53 94       	inc	r5

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
     f62:	90 e4       	ldi	r25, 0x40	; 64
     f64:	69 2e       	mov	r6, r25
		uint8_t sourceSlice, targetSlice, sourceBitMask, targetBitMask, extractedBit, targetBitCount;
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t irow8, sourceBitMaskInit, targetBitCountInit;

		for (uint8_t irow = 0; irow < textSize_; irow++) {
     f66:	1e 81       	ldd	r17, Y+6	; 0x06
     f68:	f1 16       	cp	r15, r17
     f6a:	08 f0       	brcs	.+2      	; 0xf6e <_ZN4OLED5writeEh+0x142>
     f6c:	60 c0       	rjmp	.+192    	; 0x102e <_ZN4OLED5writeEh+0x202>
			irow8 = irow * 8;
			sourceBitMaskInit = 1 << (irow8 / textSize_);
     f6e:	8c 2d       	mov	r24, r12
     f70:	61 2f       	mov	r22, r17
     f72:	0e 94 3a 27 	call	0x4e74	; 0x4e74 <__udivmodqi4>
     f76:	75 2c       	mov	r7, r5
     f78:	01 c0       	rjmp	.+2      	; 0xf7c <_ZN4OLED5writeEh+0x150>
     f7a:	77 0c       	add	r7, r7
     f7c:	8a 95       	dec	r24
     f7e:	ea f7       	brpl	.-6      	; 0xf7a <_ZN4OLED5writeEh+0x14e>
			targetBitCountInit = (textSize_ * 7 - irow8) % textSize_;
     f80:	f7 e0       	ldi	r31, 0x07	; 7
     f82:	1f 9f       	mul	r17, r31
     f84:	c0 01       	movw	r24, r0
     f86:	11 24       	eor	r1, r1
     f88:	8c 19       	sub	r24, r12
     f8a:	91 09       	sbc	r25, r1
     f8c:	61 2f       	mov	r22, r17
     f8e:	70 e0       	ldi	r23, 0x00	; 0
     f90:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
			if (targetBitCountInit == 0) targetBitCountInit = textSize_;
     f94:	81 11       	cpse	r24, r1
     f96:	18 2f       	mov	r17, r24
			if (irow > 0)
     f98:	ff 20       	and	r15, r15
     f9a:	31 f0       	breq	.+12     	; 0xfa8 <_ZN4OLED5writeEh+0x17c>
			setCursor(startRow + irow, startCol);
     f9c:	40 2f       	mov	r20, r16
     f9e:	6f 2d       	mov	r22, r15
     fa0:	6d 0d       	add	r22, r13
     fa2:	ce 01       	movw	r24, r28
     fa4:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
     fa8:	1a 86       	std	Y+10, r1	; 0x0a

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
     faa:	6b 86       	std	Y+11, r6	; 0x0b
     fac:	81 2c       	mov	r8, r1
     fae:	91 2c       	mov	r9, r1
			if (irow > 0)
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
     fb0:	f4 01       	movw	r30, r8
     fb2:	ea 0d       	add	r30, r10
     fb4:	fb 1d       	adc	r31, r11
     fb6:	ee 50       	subi	r30, 0x0E	; 14
     fb8:	fd 4f       	sbci	r31, 0xFD	; 253
     fba:	e4 91       	lpm	r30, Z
				targetBitMask = 0x01;
				sourceBitMask = sourceBitMaskInit;
				targetBitCount = targetBitCountInit;
				do {
					extractedBit = sourceSlice & sourceBitMask;
					for (uint8_t i = 0; i<textSize_; i++) {
     fbc:	4e 81       	ldd	r20, Y+6	; 0x06
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
				targetSlice = 0;
				targetBitMask = 0x01;
				sourceBitMask = sourceBitMaskInit;
				targetBitCount = targetBitCountInit;
     fbe:	21 2f       	mov	r18, r17
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
				targetSlice = 0;
				targetBitMask = 0x01;
				sourceBitMask = sourceBitMaskInit;
     fc0:	37 2d       	mov	r19, r7
			StartTransfer();
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
				targetSlice = 0;
				targetBitMask = 0x01;
     fc2:	81 e0       	ldi	r24, 0x01	; 1
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
				sourceSlice = pgm_read_byte(font + 5 * (c - 32) + iSlice);
				targetSlice = 0;
     fc4:	41 2c       	mov	r4, r1
				targetBitMask = 0x01;
				sourceBitMask = sourceBitMaskInit;
				targetBitCount = targetBitCountInit;
				do {
					extractedBit = sourceSlice & sourceBitMask;
     fc6:	6e 2f       	mov	r22, r30
     fc8:	63 23       	and	r22, r19
     fca:	52 2f       	mov	r21, r18
     fcc:	54 1b       	sub	r21, r20
     fce:	92 2f       	mov	r25, r18
     fd0:	25 2f       	mov	r18, r21
					for (uint8_t i = 0; i<textSize_; i++) {
     fd2:	95 17       	cp	r25, r21
     fd4:	d1 f3       	breq	.-12     	; 0xfca <_ZN4OLED5writeEh+0x19e>
						if (extractedBit != 0) targetSlice |= targetBitMask;
     fd6:	61 11       	cpse	r22, r1
     fd8:	48 2a       	or	r4, r24
						targetBitMask <<= 1;
     fda:	88 0f       	add	r24, r24
						targetBitCount--;
     fdc:	91 50       	subi	r25, 0x01	; 1
						if (targetBitCount == 0) {
     fde:	29 f4       	brne	.+10     	; 0xfea <_ZN4OLED5writeEh+0x1be>
							targetBitCount = textSize_;
							sourceBitMask <<= 1;
     fe0:	33 0f       	add	r19, r19
							break;
						}
						if (targetBitMask == 0) break;
					}
				} while (targetBitMask != 0);
     fe2:	88 23       	and	r24, r24
     fe4:	21 f0       	breq	.+8      	; 0xfee <_ZN4OLED5writeEh+0x1c2>
				targetBitMask = 0x01;
				sourceBitMask = sourceBitMaskInit;
				targetBitCount = targetBitCountInit;
				do {
					extractedBit = sourceSlice & sourceBitMask;
					for (uint8_t i = 0; i<textSize_; i++) {
     fe6:	24 2f       	mov	r18, r20
     fe8:	ee cf       	rjmp	.-36     	; 0xfc6 <_ZN4OLED5writeEh+0x19a>
						if (targetBitCount == 0) {
							targetBitCount = textSize_;
							sourceBitMask <<= 1;
							break;
						}
						if (targetBitMask == 0) break;
     fea:	81 11       	cpse	r24, r1
     fec:	f1 cf       	rjmp	.-30     	; 0xfd0 <_ZN4OLED5writeEh+0x1a4>
     fee:	31 2c       	mov	r3, r1
					}
				} while (targetBitMask != 0);
				for (uint8_t i = 0; i<textSize_; i++) {
     ff0:	8e 81       	ldd	r24, Y+6	; 0x06
     ff2:	38 16       	cp	r3, r24
     ff4:	30 f4       	brcc	.+12     	; 0x1002 <_ZN4OLED5writeEh+0x1d6>
					WriteData(targetSlice);
     ff6:	64 2d       	mov	r22, r4
     ff8:	ce 01       	movw	r24, r28
     ffa:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
							break;
						}
						if (targetBitMask == 0) break;
					}
				} while (targetBitMask != 0);
				for (uint8_t i = 0; i<textSize_; i++) {
     ffe:	33 94       	inc	r3
    1000:	f7 cf       	rjmp	.-18     	; 0xff0 <_ZN4OLED5writeEh+0x1c4>
    1002:	2f ef       	ldi	r18, 0xFF	; 255
    1004:	82 1a       	sub	r8, r18
    1006:	92 0a       	sbc	r9, r18
			if (targetBitCountInit == 0) targetBitCountInit = textSize_;
			if (irow > 0)
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			for (uint8_t iSlice = 0; iSlice<slices; iSlice++) {
    1008:	8e 14       	cp	r8, r14
    100a:	90 f2       	brcs	.-92     	; 0xfb0 <_ZN4OLED5writeEh+0x184>
				} while (targetBitMask != 0);
				for (uint8_t i = 0; i<textSize_; i++) {
					WriteData(targetSlice);
				}
			}
			if (!transparentSpacing_)
    100c:	8d 85       	ldd	r24, Y+13	; 0x0d
    100e:	81 11       	cpse	r24, r1
    1010:	0a c0       	rjmp	.+20     	; 0x1026 <_ZN4OLED5writeEh+0x1fa>
    1012:	10 e0       	ldi	r17, 0x00	; 0
			for (uint8_t i = 0; i<textSpacing_; i++)
    1014:	8f 81       	ldd	r24, Y+7	; 0x07
    1016:	18 17       	cp	r17, r24
    1018:	30 f4       	brcc	.+12     	; 0x1026 <_ZN4OLED5writeEh+0x1fa>
			WriteData(0);
    101a:	60 e0       	ldi	r22, 0x00	; 0
    101c:	ce 01       	movw	r24, r28
    101e:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
				for (uint8_t i = 0; i<textSize_; i++) {
					WriteData(targetSlice);
				}
			}
			if (!transparentSpacing_)
			for (uint8_t i = 0; i<textSpacing_; i++)
    1022:	1f 5f       	subi	r17, 0xFF	; 255
    1024:	f7 cf       	rjmp	.-18     	; 0x1014 <_ZN4OLED5writeEh+0x1e8>
		uint8_t sourceSlice, targetSlice, sourceBitMask, targetBitMask, extractedBit, targetBitCount;
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t irow8, sourceBitMaskInit, targetBitCountInit;

		for (uint8_t irow = 0; irow < textSize_; irow++) {
    1026:	f3 94       	inc	r15
    1028:	88 e0       	ldi	r24, 0x08	; 8
    102a:	c8 0e       	add	r12, r24
    102c:	9c cf       	rjmp	.-200    	; 0xf66 <_ZN4OLED5writeEh+0x13a>
			}
			if (!transparentSpacing_)
			for (uint8_t i = 0; i<textSpacing_; i++)
			WriteData(0);
		}
		EndTransfer();
    102e:	ce 01       	movw	r24, r28
    1030:	0e 94 1b 06 	call	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>
		setCursor(startRow, startCol + slices*textSize_ + textSpacing_);
    1034:	8e 81       	ldd	r24, Y+6	; 0x06
    1036:	4f 81       	ldd	r20, Y+7	; 0x07
    1038:	40 0f       	add	r20, r16
    103a:	e8 9e       	mul	r14, r24
    103c:	40 0d       	add	r20, r0
    103e:	11 24       	eor	r1, r1
    1040:	80 cf       	rjmp	.-256    	; 0xf42 <_ZN4OLED5writeEh+0x116>
		uint8_t startCol = col_;
		uint8_t columns = textSize_ * 5;
		uint8_t rows = (textSize_ == 8 ? textSize_ - 1 : textSize_);
		uint8_t b, instruction, count, columnCnt, d;
		for (uint8_t irow = 0; irow < rows; irow++) {
			if (irow  > 0)
    1042:	99 20       	and	r9, r9
    1044:	31 f0       	breq	.+12     	; 0x1052 <_ZN4OLED5writeEh+0x226>
			setCursor(startRow + irow, startCol);
    1046:	40 2f       	mov	r20, r16
    1048:	69 2d       	mov	r22, r9
    104a:	6d 0d       	add	r22, r13
    104c:	ce 01       	movw	r24, r28
    104e:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN4OLED9setCursorEhh>
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
    1052:	1a 86       	std	Y+10, r1	; 0x0a

inline void OLED::SelectCommand() { i2cControl = 0x00; }

/***************************************/

inline void OLED::SelectData() { i2cControl = 0x40; }
    1054:	6b 86       	std	Y+11, r6	; 0x0b
		for (uint8_t irow = 0; irow < rows; irow++) {
			if (irow  > 0)
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			uint8_t columnCnt = 0;
    1056:	71 2c       	mov	r7, r1
			while (columnCnt < columns) {
    1058:	78 14       	cp	r7, r8
    105a:	08 f0       	brcs	.+2      	; 0x105e <_ZN4OLED5writeEh+0x232>
    105c:	38 c0       	rjmp	.+112    	; 0x10ce <_ZN4OLED5writeEh+0x2a2>
				b = pgm_read_byte(ptr++);
    105e:	57 01       	movw	r10, r14
    1060:	8f ef       	ldi	r24, 0xFF	; 255
    1062:	a8 1a       	sub	r10, r24
    1064:	b8 0a       	sbc	r11, r24
    1066:	f7 01       	movw	r30, r14
    1068:	94 91       	lpm	r25, Z
				instruction = b & INSTRUCTION_MASK;
    106a:	89 2f       	mov	r24, r25
    106c:	80 7c       	andi	r24, 0xC0	; 192
				count = b & ~INSTRUCTION_MASK;
    106e:	9f 73       	andi	r25, 0x3F	; 63
    1070:	c9 2e       	mov	r12, r25
				if (instruction == _I) {
    1072:	80 34       	cpi	r24, 0x40	; 64
    1074:	79 f4       	brne	.+30     	; 0x1094 <_ZN4OLED5writeEh+0x268>
    1076:	f5 01       	movw	r30, r10
    1078:	51 2c       	mov	r5, r1
					for (uint8_t i = 0; i<count; i++)
    107a:	5c 14       	cp	r5, r12
    107c:	19 f1       	breq	.+70     	; 0x10c4 <_ZN4OLED5writeEh+0x298>
					WriteData(pgm_read_byte(ptr++));
    107e:	7f 01       	movw	r14, r30
    1080:	2f ef       	ldi	r18, 0xFF	; 255
    1082:	e2 1a       	sub	r14, r18
    1084:	f2 0a       	sbc	r15, r18
    1086:	64 91       	lpm	r22, Z
    1088:	ce 01       	movw	r24, r28
    108a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
			while (columnCnt < columns) {
				b = pgm_read_byte(ptr++);
				instruction = b & INSTRUCTION_MASK;
				count = b & ~INSTRUCTION_MASK;
				if (instruction == _I) {
					for (uint8_t i = 0; i<count; i++)
    108e:	53 94       	inc	r5
					WriteData(pgm_read_byte(ptr++));
    1090:	f7 01       	movw	r30, r14
			while (columnCnt < columns) {
				b = pgm_read_byte(ptr++);
				instruction = b & INSTRUCTION_MASK;
				count = b & ~INSTRUCTION_MASK;
				if (instruction == _I) {
					for (uint8_t i = 0; i<count; i++)
    1092:	f3 cf       	rjmp	.-26     	; 0x107a <_ZN4OLED5writeEh+0x24e>
					WriteData(pgm_read_byte(ptr++));
				}
				else {
					if (instruction == _0)
    1094:	88 23       	and	r24, r24
    1096:	49 f0       	breq	.+18     	; 0x10aa <_ZN4OLED5writeEh+0x27e>
					d = 0;
					else if (instruction == _F)
    1098:	80 3c       	cpi	r24, 0xC0	; 192
    109a:	49 f0       	breq	.+18     	; 0x10ae <_ZN4OLED5writeEh+0x282>
					d = 0xFF;
					else // _S
					d = pgm_read_byte(ptr++);
    109c:	82 e0       	ldi	r24, 0x02	; 2
    109e:	e8 0e       	add	r14, r24
    10a0:	f1 1c       	adc	r15, r1
    10a2:	f5 01       	movw	r30, r10
    10a4:	54 90       	lpm	r5, Z
    10a6:	57 01       	movw	r10, r14
    10a8:	04 c0       	rjmp	.+8      	; 0x10b2 <_ZN4OLED5writeEh+0x286>
					for (uint8_t i = 0; i<count; i++)
					WriteData(pgm_read_byte(ptr++));
				}
				else {
					if (instruction == _0)
					d = 0;
    10aa:	51 2c       	mov	r5, r1
    10ac:	02 c0       	rjmp	.+4      	; 0x10b2 <_ZN4OLED5writeEh+0x286>
					else if (instruction == _F)
					d = 0xFF;
    10ae:	55 24       	eor	r5, r5
    10b0:	5a 94       	dec	r5
					else // _S
					d = pgm_read_byte(ptr++);
					for (uint8_t i = 0; i<count; i++)
    10b2:	f1 2c       	mov	r15, r1
    10b4:	fc 14       	cp	r15, r12
    10b6:	41 f0       	breq	.+16     	; 0x10c8 <_ZN4OLED5writeEh+0x29c>
					WriteData(d);
    10b8:	65 2d       	mov	r22, r5
    10ba:	ce 01       	movw	r24, r28
    10bc:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
					d = 0;
					else if (instruction == _F)
					d = 0xFF;
					else // _S
					d = pgm_read_byte(ptr++);
					for (uint8_t i = 0; i<count; i++)
    10c0:	f3 94       	inc	r15
    10c2:	f8 cf       	rjmp	.-16     	; 0x10b4 <_ZN4OLED5writeEh+0x288>
    10c4:	ac 0c       	add	r10, r12
    10c6:	b1 1c       	adc	r11, r1
					WriteData(d);
				} //if else
				columnCnt += count;
    10c8:	7c 0c       	add	r7, r12
			if (irow  > 0)
			setCursor(startRow + irow, startCol);
			StartTransfer();
			SelectData();
			uint8_t columnCnt = 0;
			while (columnCnt < columns) {
    10ca:	75 01       	movw	r14, r10
    10cc:	c5 cf       	rjmp	.-118    	; 0x1058 <_ZN4OLED5writeEh+0x22c>
					for (uint8_t i = 0; i<count; i++)
					WriteData(d);
				} //if else
				columnCnt += count;
			} // while columnCnt
			if (!transparentSpacing_)
    10ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    10d0:	81 11       	cpse	r24, r1
    10d2:	0a c0       	rjmp	.+20     	; 0x10e8 <_ZN4OLED5writeEh+0x2bc>
    10d4:	c1 2c       	mov	r12, r1
			for (uint8_t i = 0; i<textSpacing_; i++)
    10d6:	8f 81       	ldd	r24, Y+7	; 0x07
    10d8:	c8 16       	cp	r12, r24
    10da:	30 f4       	brcc	.+12     	; 0x10e8 <_ZN4OLED5writeEh+0x2bc>
			WriteData(0);
    10dc:	60 e0       	ldi	r22, 0x00	; 0
    10de:	ce 01       	movw	r24, r28
    10e0:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
					WriteData(d);
				} //if else
				columnCnt += count;
			} // while columnCnt
			if (!transparentSpacing_)
			for (uint8_t i = 0; i<textSpacing_; i++)
    10e4:	c3 94       	inc	r12
    10e6:	f7 cf       	rjmp	.-18     	; 0x10d6 <_ZN4OLED5writeEh+0x2aa>
		uint8_t startRow = row_;
		uint8_t startCol = col_;
		uint8_t columns = textSize_ * 5;
		uint8_t rows = (textSize_ == 8 ? textSize_ - 1 : textSize_);
		uint8_t b, instruction, count, columnCnt, d;
		for (uint8_t irow = 0; irow < rows; irow++) {
    10e8:	93 94       	inc	r9
    10ea:	1e cf       	rjmp	.-452    	; 0xf28 <_ZN4OLED5writeEh+0xfc>
		setCursor(startRow, startCol + slices*textSize_ + textSpacing_);
	}
	#endif

	return 1;
}
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	1f 91       	pop	r17
    10f6:	0f 91       	pop	r16
    10f8:	ff 90       	pop	r15
    10fa:	ef 90       	pop	r14
    10fc:	df 90       	pop	r13
    10fe:	cf 90       	pop	r12
    1100:	bf 90       	pop	r11
    1102:	af 90       	pop	r10
    1104:	9f 90       	pop	r9
    1106:	8f 90       	pop	r8
    1108:	7f 90       	pop	r7
    110a:	6f 90       	pop	r6
    110c:	5f 90       	pop	r5
    110e:	4f 90       	pop	r4
    1110:	3f 90       	pop	r3
    1112:	08 95       	ret

00001114 <_ZN4OLED11sendCommandEh>:
}

//------------------------------------------------------------------------------
// sendCommand(c) - send a single byte command
//------------------------------------------------------------------------------
void OLED::sendCommand(uint8_t c) {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	ec 01       	movw	r28, r24
/***************************************/
/**************FUNCTIONS****************/
/***************************************/

void OLED::StartTransfer() {
	i2cCount = 0;
    111a:	1a 86       	std	Y+10, r1	; 0x0a
}

/***************************************/

inline void OLED::SelectCommand() { i2cControl = 0x00; }
    111c:	1b 86       	std	Y+11, r1	; 0x0b
// sendCommand(c) - send a single byte command
//------------------------------------------------------------------------------
void OLED::sendCommand(uint8_t c) {
	StartTransfer();
	SelectCommand();
	WriteData(c);
    111e:	0e 94 3e 06 	call	0xc7c	; 0xc7c <_ZN4OLED9WriteDataEh>
	EndTransfer();
    1122:	ce 01       	movw	r24, r28
}
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
//------------------------------------------------------------------------------
void OLED::sendCommand(uint8_t c) {
	StartTransfer();
	SelectCommand();
	WriteData(c);
	EndTransfer();
    1128:	0c 94 1b 06 	jmp	0xc36	; 0xc36 <_ZN4OLED11EndTransferEv>

0000112c <_ZN6RotaryC1Ecc>:
#endif

/*
 * Constructor. Each arg is the pin number for each encoder contact.
 */
Rotary::Rotary(char _pin1, char _pin2) {
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	ec 01       	movw	r28, r24
    1132:	86 2f       	mov	r24, r22
  // Assign variables.
  pin1 = _pin1;
    1134:	69 83       	std	Y+1, r22	; 0x01
  pin2 = _pin2;
    1136:	4a 83       	std	Y+2, r20	; 0x02
  // Set pins to input.
  pinMode(pin1, INPUT);
    1138:	60 e0       	ldi	r22, 0x00	; 0
    113a:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
  pinMode(pin2, INPUT);
    113e:	60 e0       	ldi	r22, 0x00	; 0
    1140:	8a 81       	ldd	r24, Y+2	; 0x02
    1142:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
#ifdef ENABLE_PULLUPS
  digitalWrite(pin1, HIGH);
    1146:	61 e0       	ldi	r22, 0x01	; 1
    1148:	89 81       	ldd	r24, Y+1	; 0x01
    114a:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
  digitalWrite(pin2, HIGH);
    114e:	61 e0       	ldi	r22, 0x01	; 1
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
#endif
  // Initialise state.
  state = R_START;
    1156:	18 82       	st	Y, r1
}
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	08 95       	ret

0000115e <_ZN6Rotary7processEv>:

unsigned char Rotary::process() {
    115e:	0f 93       	push	r16
    1160:	1f 93       	push	r17
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	ec 01       	movw	r28, r24
  // Grab state of input pins.
  unsigned char pinstate = (digitalRead(pin2) << 1) | digitalRead(pin1);
    1168:	8a 81       	ldd	r24, Y+2	; 0x02
    116a:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <digitalRead>
    116e:	8c 01       	movw	r16, r24
    1170:	89 81       	ldd	r24, Y+1	; 0x01
    1172:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <digitalRead>
  // Determine new state from the pins and state table.
  state = ttable[state & 0xf][pinstate];
    1176:	e8 81       	ld	r30, Y
    1178:	ef 70       	andi	r30, 0x0F	; 15
    117a:	00 0f       	add	r16, r16
    117c:	11 1f       	adc	r17, r17
    117e:	80 2b       	or	r24, r16
    1180:	94 e0       	ldi	r25, 0x04	; 4
    1182:	e9 9f       	mul	r30, r25
    1184:	f0 01       	movw	r30, r0
    1186:	11 24       	eor	r1, r1
    1188:	e8 58       	subi	r30, 0x88	; 136
    118a:	fe 4f       	sbci	r31, 0xFE	; 254
    118c:	e8 0f       	add	r30, r24
    118e:	f1 1d       	adc	r31, r1
    1190:	80 81       	ld	r24, Z
    1192:	88 83       	st	Y, r24
  // Return emit bits, ie the generated event.
  return state & 0x30;
}
    1194:	80 73       	andi	r24, 0x30	; 48
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	1f 91       	pop	r17
    119c:	0f 91       	pop	r16
    119e:	08 95       	ret

000011a0 <_ZL7scale16jj>:
		return 255 - WheelPos * 3;
	} else {
		WheelPos -= 170;
		return 0;
	}
    11a0:	9c 01       	movw	r18, r24
    11a2:	ab 01       	movw	r20, r22
    11a4:	86 9f       	mul	r24, r22
    11a6:	c0 01       	movw	r24, r0
    11a8:	37 9f       	mul	r19, r23
    11aa:	d0 01       	movw	r26, r0
    11ac:	bc 01       	movw	r22, r24
    11ae:	cd 01       	movw	r24, r26
    11b0:	e0 e0       	ldi	r30, 0x00	; 0
    11b2:	34 9f       	mul	r19, r20
    11b4:	70 0d       	add	r23, r0
    11b6:	81 1d       	adc	r24, r1
    11b8:	9e 1f       	adc	r25, r30
    11ba:	25 9f       	mul	r18, r21
    11bc:	70 0d       	add	r23, r0
    11be:	81 1d       	adc	r24, r1
    11c0:	9e 1f       	adc	r25, r30
    11c2:	11 24       	eor	r1, r1
    11c4:	08 95       	ret

000011c6 <_ZL7random8v>:
    11c6:	40 91 1d 01 	lds	r20, 0x011D	; 0x80011d <rand16seed>
    11ca:	50 91 1e 01 	lds	r21, 0x011E	; 0x80011e <rand16seed+0x1>
    11ce:	25 e0       	ldi	r18, 0x05	; 5
    11d0:	38 e0       	ldi	r19, 0x08	; 8
    11d2:	42 9f       	mul	r20, r18
    11d4:	c0 01       	movw	r24, r0
    11d6:	43 9f       	mul	r20, r19
    11d8:	90 0d       	add	r25, r0
    11da:	52 9f       	mul	r21, r18
    11dc:	90 0d       	add	r25, r0
    11de:	11 24       	eor	r1, r1
    11e0:	87 5e       	subi	r24, 0xE7	; 231
    11e2:	99 4c       	sbci	r25, 0xC9	; 201
    11e4:	90 93 1e 01 	sts	0x011E, r25	; 0x80011e <rand16seed+0x1>
    11e8:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <rand16seed>
    11ec:	89 0f       	add	r24, r25
    11ee:	08 95       	ret

000011f0 <_ZL9sin16_avrj>:
    11f0:	bc 01       	movw	r22, r24
    11f2:	9c 01       	movw	r18, r24
    11f4:	3f 73       	andi	r19, 0x3F	; 63
    11f6:	36 95       	lsr	r19
    11f8:	27 95       	ror	r18
    11fa:	36 95       	lsr	r19
    11fc:	27 95       	ror	r18
    11fe:	36 95       	lsr	r19
    1200:	27 95       	ror	r18
    1202:	76 ff       	sbrs	r23, 6
    1204:	06 c0       	rjmp	.+12     	; 0x1212 <_ZL9sin16_avrj+0x22>
    1206:	8f ef       	ldi	r24, 0xFF	; 255
    1208:	97 e0       	ldi	r25, 0x07	; 7
    120a:	ac 01       	movw	r20, r24
    120c:	42 1b       	sub	r20, r18
    120e:	53 0b       	sbc	r21, r19
    1210:	9a 01       	movw	r18, r20
    1212:	e3 2f       	mov	r30, r19
    1214:	ee 0f       	add	r30, r30
    1216:	ee 0f       	add	r30, r30
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	ed 55       	subi	r30, 0x5D	; 93
    121c:	fe 4f       	sbci	r31, 0xFE	; 254
    121e:	40 81       	ld	r20, Z
    1220:	51 81       	ldd	r21, Z+1	; 0x01
    1222:	33 27       	eor	r19, r19
    1224:	35 95       	asr	r19
    1226:	27 95       	ror	r18
    1228:	e2 81       	ldd	r30, Z+2	; 0x02
    122a:	e2 9f       	mul	r30, r18
    122c:	c0 01       	movw	r24, r0
    122e:	e3 9f       	mul	r30, r19
    1230:	90 0d       	add	r25, r0
    1232:	11 24       	eor	r1, r1
    1234:	84 0f       	add	r24, r20
    1236:	95 1f       	adc	r25, r21
    1238:	77 ff       	sbrs	r23, 7
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <_ZL9sin16_avrj+0x52>
    123c:	91 95       	neg	r25
    123e:	81 95       	neg	r24
    1240:	91 09       	sbc	r25, r1
    1242:	08 95       	ret

00001244 <_ZN14CLEDController4sizeEv>:
    1244:	fc 01       	movw	r30, r24
    1246:	85 85       	ldd	r24, Z+13	; 0x0d
    1248:	96 85       	ldd	r25, Z+14	; 0x0e
    124a:	08 95       	ret

0000124c <_ZN14CLEDController9clearLedsEi>:
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	00 d0       	rcall	.+0      	; 0x1252 <_ZN14CLEDController9clearLedsEi+0x6>
    1252:	00 d0       	rcall	.+0      	; 0x1254 <_ZN14CLEDController9clearLedsEi+0x8>
    1254:	00 d0       	rcall	.+0      	; 0x1256 <_ZN14CLEDController9clearLedsEi+0xa>
    1256:	cd b7       	in	r28, 0x3d	; 61
    1258:	de b7       	in	r29, 0x3e	; 62
    125a:	ab 01       	movw	r20, r22
    125c:	1c 82       	std	Y+4, r1	; 0x04
    125e:	1d 82       	std	Y+5, r1	; 0x05
    1260:	1e 82       	std	Y+6, r1	; 0x06
    1262:	dc 01       	movw	r26, r24
    1264:	ed 91       	ld	r30, X+
    1266:	fc 91       	ld	r31, X
    1268:	01 90       	ld	r0, Z+
    126a:	f0 81       	ld	r31, Z
    126c:	e0 2d       	mov	r30, r0
    126e:	19 82       	std	Y+1, r1	; 0x01
    1270:	1a 82       	std	Y+2, r1	; 0x02
    1272:	1b 82       	std	Y+3, r1	; 0x03
    1274:	9e 01       	movw	r18, r28
    1276:	2f 5f       	subi	r18, 0xFF	; 255
    1278:	3f 4f       	sbci	r19, 0xFF	; 255
    127a:	be 01       	movw	r22, r28
    127c:	6c 5f       	subi	r22, 0xFC	; 252
    127e:	7f 4f       	sbci	r23, 0xFF	; 255
    1280:	09 95       	icall
    1282:	26 96       	adiw	r28, 0x06	; 6
    1284:	0f b6       	in	r0, 0x3f	; 63
    1286:	f8 94       	cli
    1288:	de bf       	out	0x3e, r29	; 62
    128a:	0f be       	out	0x3f, r0	; 63
    128c:	cd bf       	out	0x3d, r28	; 61
    128e:	df 91       	pop	r29
    1290:	cf 91       	pop	r28
    1292:	08 95       	ret

00001294 <_ZNK19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE17getMaxRefreshRateEv>:
    1294:	80 e9       	ldi	r24, 0x90	; 144
    1296:	91 e0       	ldi	r25, 0x01	; 1
    1298:	08 95       	ret

0000129a <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE4initEv>:
    129a:	0c 9a       	sbi	0x01, 4	; 1
    129c:	08 95       	ret

0000129e <_ZN4CRGBpLERKS_>:
    129e:	fc 01       	movw	r30, r24
    12a0:	db 01       	movw	r26, r22
    12a2:	3c 91       	ld	r19, X
    12a4:	20 81       	ld	r18, Z
    12a6:	23 0f       	add	r18, r19
    12a8:	08 f4       	brcc	.+2      	; 0x12ac <L_297>
    12aa:	2f ef       	ldi	r18, 0xFF	; 255

000012ac <L_297>:
    12ac:	20 83       	st	Z, r18
    12ae:	11 96       	adiw	r26, 0x01	; 1
    12b0:	3c 91       	ld	r19, X
    12b2:	11 97       	sbiw	r26, 0x01	; 1
    12b4:	21 81       	ldd	r18, Z+1	; 0x01
    12b6:	23 0f       	add	r18, r19
    12b8:	08 f4       	brcc	.+2      	; 0x12bc <L_309>
    12ba:	2f ef       	ldi	r18, 0xFF	; 255

000012bc <L_309>:
    12bc:	21 83       	std	Z+1, r18	; 0x01
    12be:	12 96       	adiw	r26, 0x02	; 2
    12c0:	3c 91       	ld	r19, X
    12c2:	22 81       	ldd	r18, Z+2	; 0x02
    12c4:	23 0f       	add	r18, r19
    12c6:	08 f4       	brcc	.+2      	; 0x12ca <L_321>
    12c8:	2f ef       	ldi	r18, 0xFF	; 255

000012ca <L_321>:
    12ca:	22 83       	std	Z+2, r18	; 0x02
    12cc:	08 95       	ret

000012ce <_ZN13CRGBPalette16aSERA16_Km>:
    12ce:	cf 93       	push	r28
    12d0:	df 93       	push	r29
    12d2:	eb 01       	movw	r28, r22
    12d4:	dc 01       	movw	r26, r24
    12d6:	20 e0       	ldi	r18, 0x00	; 0
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	fe 01       	movw	r30, r28
    12dc:	e2 0f       	add	r30, r18
    12de:	f3 1f       	adc	r31, r19
    12e0:	45 91       	lpm	r20, Z+
    12e2:	55 91       	lpm	r21, Z+
    12e4:	65 91       	lpm	r22, Z+
    12e6:	74 91       	lpm	r23, Z
    12e8:	6c 93       	st	X, r22
    12ea:	11 96       	adiw	r26, 0x01	; 1
    12ec:	5c 93       	st	X, r21
    12ee:	11 97       	sbiw	r26, 0x01	; 1
    12f0:	12 96       	adiw	r26, 0x02	; 2
    12f2:	4c 93       	st	X, r20
    12f4:	12 97       	sbiw	r26, 0x02	; 2
    12f6:	2c 5f       	subi	r18, 0xFC	; 252
    12f8:	3f 4f       	sbci	r19, 0xFF	; 255
    12fa:	13 96       	adiw	r26, 0x03	; 3
    12fc:	20 34       	cpi	r18, 0x40	; 64
    12fe:	31 05       	cpc	r19, r1
    1300:	61 f7       	brne	.-40     	; 0x12da <_ZN13CRGBPalette16aSERA16_Km+0xc>
    1302:	df 91       	pop	r29
    1304:	cf 91       	pop	r28
    1306:	08 95       	ret

00001308 <_ZN8CFastLED4showEv>:
    1308:	fc 01       	movw	r30, r24
    130a:	60 81       	ld	r22, Z
    130c:	0c 94 75 1c 	jmp	0x38ea	; 0x38ea <_ZN8CFastLED4showEh>

00001310 <_Z8pciSetuph>:
    1310:	98 ee       	ldi	r25, 0xE8	; 232
    1312:	98 0f       	add	r25, r24
    1314:	98 30       	cpi	r25, 0x08	; 8
    1316:	68 f0       	brcs	.+26     	; 0x1332 <_Z8pciSetuph+0x22>
    1318:	88 30       	cpi	r24, 0x08	; 8
    131a:	80 f0       	brcs	.+32     	; 0x133c <_Z8pciSetuph+0x2c>
    131c:	20 ef       	ldi	r18, 0xF0	; 240
    131e:	28 0f       	add	r18, r24
    1320:	28 30       	cpi	r18, 0x08	; 8
    1322:	88 f0       	brcs	.+34     	; 0x1346 <_Z8pciSetuph+0x36>
    1324:	28 ef       	ldi	r18, 0xF8	; 248
    1326:	28 0f       	add	r18, r24
    1328:	28 30       	cpi	r18, 0x08	; 8
    132a:	90 f4       	brcc	.+36     	; 0x1350 <_Z8pciSetuph+0x40>
    132c:	e3 e7       	ldi	r30, 0x73	; 115
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	11 c0       	rjmp	.+34     	; 0x1354 <_Z8pciSetuph+0x44>
    1332:	eb e6       	ldi	r30, 0x6B	; 107
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	ab e6       	ldi	r26, 0x6B	; 107
    1338:	b0 e0       	ldi	r27, 0x00	; 0
    133a:	11 c0       	rjmp	.+34     	; 0x135e <_Z8pciSetuph+0x4e>
    133c:	ec e6       	ldi	r30, 0x6C	; 108
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	ac e6       	ldi	r26, 0x6C	; 108
    1342:	b0 e0       	ldi	r27, 0x00	; 0
    1344:	0c c0       	rjmp	.+24     	; 0x135e <_Z8pciSetuph+0x4e>
    1346:	ed e6       	ldi	r30, 0x6D	; 109
    1348:	f0 e0       	ldi	r31, 0x00	; 0
    134a:	ad e6       	ldi	r26, 0x6D	; 109
    134c:	b0 e0       	ldi	r27, 0x00	; 0
    134e:	07 c0       	rjmp	.+14     	; 0x135e <_Z8pciSetuph+0x4e>
    1350:	e0 e0       	ldi	r30, 0x00	; 0
    1352:	f0 e0       	ldi	r31, 0x00	; 0
    1354:	28 30       	cpi	r18, 0x08	; 8
    1356:	08 f4       	brcc	.+2      	; 0x135a <_Z8pciSetuph+0x4a>
    1358:	71 c0       	rjmp	.+226    	; 0x143c <_Z8pciSetuph+0x12c>
    135a:	a0 e0       	ldi	r26, 0x00	; 0
    135c:	b0 e0       	ldi	r27, 0x00	; 0
    135e:	2c 91       	ld	r18, X
    1360:	98 30       	cpi	r25, 0x08	; 8
    1362:	80 f4       	brcc	.+32     	; 0x1384 <_Z8pciSetuph+0x74>
    1364:	af e1       	ldi	r26, 0x1F	; 31
    1366:	b0 e0       	ldi	r27, 0x00	; 0
    1368:	a8 1b       	sub	r26, r24
    136a:	b1 09       	sbc	r27, r1
    136c:	41 e0       	ldi	r20, 0x01	; 1
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	60 e0       	ldi	r22, 0x00	; 0
    1372:	70 e0       	ldi	r23, 0x00	; 0
    1374:	04 c0       	rjmp	.+8      	; 0x137e <_Z8pciSetuph+0x6e>
    1376:	44 0f       	add	r20, r20
    1378:	55 1f       	adc	r21, r21
    137a:	66 1f       	adc	r22, r22
    137c:	77 1f       	adc	r23, r23
    137e:	aa 95       	dec	r26
    1380:	d2 f7       	brpl	.-12     	; 0x1376 <_Z8pciSetuph+0x66>
    1382:	2c c0       	rjmp	.+88     	; 0x13dc <_Z8pciSetuph+0xcc>
    1384:	88 30       	cpi	r24, 0x08	; 8
    1386:	68 f4       	brcc	.+26     	; 0x13a2 <_Z8pciSetuph+0x92>
    1388:	41 e0       	ldi	r20, 0x01	; 1
    138a:	50 e0       	ldi	r21, 0x00	; 0
    138c:	60 e0       	ldi	r22, 0x00	; 0
    138e:	70 e0       	ldi	r23, 0x00	; 0
    1390:	08 2e       	mov	r0, r24
    1392:	04 c0       	rjmp	.+8      	; 0x139c <_Z8pciSetuph+0x8c>
    1394:	44 0f       	add	r20, r20
    1396:	55 1f       	adc	r21, r21
    1398:	66 1f       	adc	r22, r22
    139a:	77 1f       	adc	r23, r23
    139c:	0a 94       	dec	r0
    139e:	d2 f7       	brpl	.-12     	; 0x1394 <_Z8pciSetuph+0x84>
    13a0:	1d c0       	rjmp	.+58     	; 0x13dc <_Z8pciSetuph+0xcc>
    13a2:	30 ef       	ldi	r19, 0xF0	; 240
    13a4:	38 0f       	add	r19, r24
    13a6:	38 30       	cpi	r19, 0x08	; 8
    13a8:	30 f4       	brcc	.+12     	; 0x13b6 <_Z8pciSetuph+0xa6>
    13aa:	41 e0       	ldi	r20, 0x01	; 1
    13ac:	50 e0       	ldi	r21, 0x00	; 0
    13ae:	60 e0       	ldi	r22, 0x00	; 0
    13b0:	70 e0       	ldi	r23, 0x00	; 0
    13b2:	30 ef       	ldi	r19, 0xF0	; 240
    13b4:	09 c0       	rjmp	.+18     	; 0x13c8 <_Z8pciSetuph+0xb8>
    13b6:	38 ef       	ldi	r19, 0xF8	; 248
    13b8:	38 0f       	add	r19, r24
    13ba:	38 30       	cpi	r19, 0x08	; 8
    13bc:	70 f4       	brcc	.+28     	; 0x13da <_Z8pciSetuph+0xca>
    13be:	41 e0       	ldi	r20, 0x01	; 1
    13c0:	50 e0       	ldi	r21, 0x00	; 0
    13c2:	60 e0       	ldi	r22, 0x00	; 0
    13c4:	70 e0       	ldi	r23, 0x00	; 0
    13c6:	38 ef       	ldi	r19, 0xF8	; 248
    13c8:	38 0f       	add	r19, r24
    13ca:	04 c0       	rjmp	.+8      	; 0x13d4 <_Z8pciSetuph+0xc4>
    13cc:	44 0f       	add	r20, r20
    13ce:	55 1f       	adc	r21, r21
    13d0:	66 1f       	adc	r22, r22
    13d2:	77 1f       	adc	r23, r23
    13d4:	3a 95       	dec	r19
    13d6:	d2 f7       	brpl	.-12     	; 0x13cc <_Z8pciSetuph+0xbc>
    13d8:	01 c0       	rjmp	.+2      	; 0x13dc <_Z8pciSetuph+0xcc>
    13da:	41 e0       	ldi	r20, 0x01	; 1
    13dc:	42 2b       	or	r20, r18
    13de:	40 83       	st	Z, r20
    13e0:	3b b3       	in	r19, 0x1b	; 27
    13e2:	98 30       	cpi	r25, 0x08	; 8
    13e4:	50 f0       	brcs	.+20     	; 0x13fa <_Z8pciSetuph+0xea>
    13e6:	88 30       	cpi	r24, 0x08	; 8
    13e8:	50 f0       	brcs	.+20     	; 0x13fe <_Z8pciSetuph+0xee>
    13ea:	20 ef       	ldi	r18, 0xF0	; 240
    13ec:	28 0f       	add	r18, r24
    13ee:	28 30       	cpi	r18, 0x08	; 8
    13f0:	40 f0       	brcs	.+16     	; 0x1402 <_Z8pciSetuph+0xf2>
    13f2:	28 ef       	ldi	r18, 0xF8	; 248
    13f4:	28 0f       	add	r18, r24
    13f6:	28 30       	cpi	r18, 0x08	; 8
    13f8:	30 f0       	brcs	.+12     	; 0x1406 <_Z8pciSetuph+0xf6>
    13fa:	21 e0       	ldi	r18, 0x01	; 1
    13fc:	05 c0       	rjmp	.+10     	; 0x1408 <_Z8pciSetuph+0xf8>
    13fe:	22 e0       	ldi	r18, 0x02	; 2
    1400:	03 c0       	rjmp	.+6      	; 0x1408 <_Z8pciSetuph+0xf8>
    1402:	24 e0       	ldi	r18, 0x04	; 4
    1404:	01 c0       	rjmp	.+2      	; 0x1408 <_Z8pciSetuph+0xf8>
    1406:	28 e0       	ldi	r18, 0x08	; 8
    1408:	23 2b       	or	r18, r19
    140a:	2b bb       	out	0x1b, r18	; 27
    140c:	20 91 68 00 	lds	r18, 0x0068	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
    1410:	98 30       	cpi	r25, 0x08	; 8
    1412:	78 f0       	brcs	.+30     	; 0x1432 <_Z8pciSetuph+0x122>
    1414:	88 30       	cpi	r24, 0x08	; 8
    1416:	48 f0       	brcs	.+18     	; 0x142a <_Z8pciSetuph+0x11a>
    1418:	90 ef       	ldi	r25, 0xF0	; 240
    141a:	98 0f       	add	r25, r24
    141c:	98 30       	cpi	r25, 0x08	; 8
    141e:	38 f0       	brcs	.+14     	; 0x142e <_Z8pciSetuph+0x11e>
    1420:	88 50       	subi	r24, 0x08	; 8
    1422:	88 30       	cpi	r24, 0x08	; 8
    1424:	30 f4       	brcc	.+12     	; 0x1432 <_Z8pciSetuph+0x122>
    1426:	88 e0       	ldi	r24, 0x08	; 8
    1428:	05 c0       	rjmp	.+10     	; 0x1434 <_Z8pciSetuph+0x124>
    142a:	82 e0       	ldi	r24, 0x02	; 2
    142c:	03 c0       	rjmp	.+6      	; 0x1434 <_Z8pciSetuph+0x124>
    142e:	84 e0       	ldi	r24, 0x04	; 4
    1430:	01 c0       	rjmp	.+2      	; 0x1434 <_Z8pciSetuph+0x124>
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	82 2b       	or	r24, r18
    1436:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
    143a:	08 95       	ret
    143c:	a3 e7       	ldi	r26, 0x73	; 115
    143e:	b0 e0       	ldi	r27, 0x00	; 0
    1440:	8e cf       	rjmp	.-228    	; 0x135e <_Z8pciSetuph+0x4e>

00001442 <setup>:
    1442:	1f 93       	push	r17
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	63 e8       	ldi	r22, 0x83	; 131
    144a:	76 e0       	ldi	r23, 0x06	; 6
    144c:	80 e0       	ldi	r24, 0x00	; 0
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	0e 94 40 17 	call	0x2e80	; 0x2e80 <_ZN13AltSoftSerial4initEm>
    1454:	64 e9       	ldi	r22, 0x94	; 148
    1456:	71 e0       	ldi	r23, 0x01	; 1
    1458:	8f e8       	ldi	r24, 0x8F	; 143
    145a:	93 e0       	ldi	r25, 0x03	; 3
    145c:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <_ZN5Print7printlnEPKc>
    1460:	8e e1       	ldi	r24, 0x1E	; 30
    1462:	0e 94 88 09 	call	0x1310	; 0x1310 <_Z8pciSetuph>
    1466:	8d e1       	ldi	r24, 0x1D	; 29
    1468:	0e 94 88 09 	call	0x1310	; 0x1310 <_Z8pciSetuph>
    146c:	61 e0       	ldi	r22, 0x01	; 1
    146e:	87 e1       	ldi	r24, 0x17	; 23
    1470:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
    1474:	62 e0       	ldi	r22, 0x02	; 2
    1476:	8c e1       	ldi	r24, 0x1C	; 28
    1478:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
    147c:	80 91 6a 02 	lds	r24, 0x026A	; 0x80026a <_ZGVZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c>
    1480:	81 11       	cpse	r24, r1
    1482:	45 c0       	rjmp	.+138    	; 0x150e <setup+0xcc>
    1484:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x3>
    1488:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x2>
    148c:	8f ef       	ldi	r24, 0xFF	; 255
    148e:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x6>
    1492:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x7>
    1496:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x8>
    149a:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x9>
    149e:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xa>
    14a2:	80 93 7d 02 	sts	0x027D, r24	; 0x80027d <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xb>
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	80 93 7e 02 	sts	0x027E, r24	; 0x80027e <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xc>
    14ac:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xe>
    14b0:	10 92 7f 02 	sts	0x027F, r1	; 0x80027f <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xd>
    14b4:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x5>
    14b8:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x4>
    14bc:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <_ZN14CLEDController7m_pHeadE>
    14c0:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <_ZN14CLEDController7m_pHeadE+0x1>
    14c4:	89 2b       	or	r24, r25
    14c6:	31 f4       	brne	.+12     	; 0x14d4 <setup+0x92>
    14c8:	82 e7       	ldi	r24, 0x72	; 114
    14ca:	92 e0       	ldi	r25, 0x02	; 2
    14cc:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <_ZN14CLEDController7m_pHeadE+0x1>
    14d0:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <_ZN14CLEDController7m_pHeadE>
    14d4:	e0 91 4a 04 	lds	r30, 0x044A	; 0x80044a <_ZN14CLEDController7m_pTailE>
    14d8:	f0 91 4b 04 	lds	r31, 0x044B	; 0x80044b <_ZN14CLEDController7m_pTailE+0x1>
    14dc:	30 97       	sbiw	r30, 0x00	; 0
    14de:	21 f0       	breq	.+8      	; 0x14e8 <setup+0xa6>
    14e0:	82 e7       	ldi	r24, 0x72	; 114
    14e2:	92 e0       	ldi	r25, 0x02	; 2
    14e4:	95 83       	std	Z+5, r25	; 0x05
    14e6:	84 83       	std	Z+4, r24	; 0x04
    14e8:	82 e7       	ldi	r24, 0x72	; 114
    14ea:	92 e0       	ldi	r25, 0x02	; 2
    14ec:	90 93 4b 04 	sts	0x044B, r25	; 0x80044b <_ZN14CLEDController7m_pTailE+0x1>
    14f0:	80 93 4a 04 	sts	0x044A, r24	; 0x80044a <_ZN14CLEDController7m_pTailE>
    14f4:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x10>
    14f8:	10 92 81 02 	sts	0x0281, r1	; 0x800281 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0xf>
    14fc:	82 ed       	ldi	r24, 0xD2	; 210
    14fe:	91 e0       	ldi	r25, 0x01	; 1
    1500:	90 93 73 02 	sts	0x0273, r25	; 0x800273 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c+0x1>
    1504:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <_ZZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c>
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	80 93 6a 02 	sts	0x026A, r24	; 0x80026a <_ZGVZN8CFastLED7addLedsI6WS2811Lh28EL6EOrder66EEER14CLEDControllerP4CRGBiiE1c>
    150e:	20 e0       	ldi	r18, 0x00	; 0
    1510:	30 e0       	ldi	r19, 0x00	; 0
    1512:	47 e3       	ldi	r20, 0x37	; 55
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	62 ed       	ldi	r22, 0xD2	; 210
    1518:	72 e0       	ldi	r23, 0x02	; 2
    151a:	82 e7       	ldi	r24, 0x72	; 114
    151c:	92 e0       	ldi	r25, 0x02	; 2
    151e:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>
    1522:	6b ee       	ldi	r22, 0xEB	; 235
    1524:	75 e0       	ldi	r23, 0x05	; 5
    1526:	82 ea       	ldi	r24, 0xA2	; 162
    1528:	92 e0       	ldi	r25, 0x02	; 2
    152a:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    152e:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    1532:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <FastLED>
    1536:	8b e7       	ldi	r24, 0x7B	; 123
    1538:	93 e0       	ldi	r25, 0x03	; 3
    153a:	0e 94 3b 04 	call	0x876	; 0x876 <_ZN7ADXL3457powerOnEv>
    153e:	87 e3       	ldi	r24, 0x37	; 55
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	0e 94 85 22 	call	0x450a	; 0x450a <_Znwj>
    1546:	ec 01       	movw	r28, r24
    1548:	86 ec       	ldi	r24, 0xC6	; 198
    154a:	91 e0       	ldi	r25, 0x01	; 1
    154c:	99 83       	std	Y+1, r25	; 0x01
    154e:	88 83       	st	Y, r24
    1550:	1f 82       	std	Y+7, r1	; 0x07
    1552:	1e 82       	std	Y+6, r1	; 0x06
    1554:	80 e7       	ldi	r24, 0x70	; 112
    1556:	91 e0       	ldi	r25, 0x01	; 1
    1558:	9d 83       	std	Y+5, r25	; 0x05
    155a:	8c 83       	std	Y+4, r24	; 0x04
    155c:	ce 01       	movw	r24, r28
    155e:	04 96       	adiw	r24, 0x04	; 4
    1560:	0e 94 64 06 	call	0xcc8	; 0xcc8 <_ZN4OLED4initEv>
    1564:	11 e0       	ldi	r17, 0x01	; 1
    1566:	1b 83       	std	Y+3, r17	; 0x03
    1568:	8d ed       	ldi	r24, 0xDD	; 221
    156a:	94 e0       	ldi	r25, 0x04	; 4
    156c:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
    1570:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <_ZN4Menu11CurrentMenuE>
    1574:	83 e1       	ldi	r24, 0x13	; 19
    1576:	8b 8b       	std	Y+19, r24	; 0x13
    1578:	84 e6       	ldi	r24, 0x64	; 100
    157a:	91 e0       	ldi	r25, 0x01	; 1
    157c:	99 83       	std	Y+1, r25	; 0x01
    157e:	88 83       	st	Y, r24
    1580:	d0 93 9e 02 	sts	0x029E, r29	; 0x80029e <animnu+0x1>
    1584:	c0 93 9d 02 	sts	0x029D, r28	; 0x80029d <animnu>
    1588:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <animation>
    158c:	8d ab       	std	Y+53, r24	; 0x35
    158e:	ce 01       	movw	r24, r28
    1590:	0e 94 37 05 	call	0xa6e	; 0xa6e <_ZN13AnimationMenu8ShowMenuEv>
    1594:	10 93 99 02 	sts	0x0299, r17	; 0x800299 <sleepScreen>
    1598:	80 e1       	ldi	r24, 0x10	; 16
    159a:	97 e2       	ldi	r25, 0x27	; 39
    159c:	90 93 98 02 	sts	0x0298, r25	; 0x800298 <sleepInt+0x1>
    15a0:	80 93 97 02 	sts	0x0297, r24	; 0x800297 <sleepInt>
    15a4:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    15a8:	60 93 0c 01 	sts	0x010C, r22	; 0x80010c <sleepTime>
    15ac:	70 93 0d 01 	sts	0x010D, r23	; 0x80010d <sleepTime+0x1>
    15b0:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <sleepTime+0x2>
    15b4:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <sleepTime+0x3>
    15b8:	78 94       	sei
    15ba:	df 91       	pop	r29
    15bc:	cf 91       	pop	r28
    15be:	1f 91       	pop	r17
    15c0:	08 95       	ret

000015c2 <__vector_4>:
    15c2:	1f 92       	push	r1
    15c4:	0f 92       	push	r0
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	0f 92       	push	r0
    15ca:	11 24       	eor	r1, r1
    15cc:	0f 93       	push	r16
    15ce:	1f 93       	push	r17
    15d0:	2f 93       	push	r18
    15d2:	3f 93       	push	r19
    15d4:	4f 93       	push	r20
    15d6:	5f 93       	push	r21
    15d8:	6f 93       	push	r22
    15da:	7f 93       	push	r23
    15dc:	8f 93       	push	r24
    15de:	9f 93       	push	r25
    15e0:	af 93       	push	r26
    15e2:	bf 93       	push	r27
    15e4:	cf 93       	push	r28
    15e6:	ef 93       	push	r30
    15e8:	ff 93       	push	r31
    15ea:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    15ee:	60 93 0c 01 	sts	0x010C, r22	; 0x80010c <sleepTime>
    15f2:	70 93 0d 01 	sts	0x010D, r23	; 0x80010d <sleepTime+0x1>
    15f6:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <sleepTime+0x2>
    15fa:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <sleepTime+0x3>
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	80 93 99 02 	sts	0x0299, r24	; 0x800299 <sleepScreen>
    1604:	88 e7       	ldi	r24, 0x78	; 120
    1606:	93 e0       	ldi	r25, 0x03	; 3
    1608:	0e 94 af 08 	call	0x115e	; 0x115e <_ZN6Rotary7processEv>
    160c:	c8 2f       	mov	r28, r24
    160e:	00 91 9d 02 	lds	r16, 0x029D	; 0x80029d <animnu>
    1612:	10 91 9e 02 	lds	r17, 0x029E	; 0x80029e <animnu+0x1>
    1616:	8c e1       	ldi	r24, 0x1C	; 28
    1618:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <digitalRead>
    161c:	21 e0       	ldi	r18, 0x01	; 1
    161e:	89 2b       	or	r24, r25
    1620:	09 f0       	breq	.+2      	; 0x1624 <__vector_4+0x62>
    1622:	20 e0       	ldi	r18, 0x00	; 0
    1624:	f8 01       	movw	r30, r16
    1626:	24 ab       	std	Z+52, r18	; 0x34
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	80 93 94 02 	sts	0x0294, r24	; 0x800294 <exitloop>
    162e:	cc 23       	and	r28, r28
    1630:	39 f0       	breq	.+14     	; 0x1640 <__vector_4+0x7e>
    1632:	c0 32       	cpi	r28, 0x20	; 32
    1634:	19 f0       	breq	.+6      	; 0x163c <__vector_4+0x7a>
    1636:	c0 31       	cpi	r28, 0x10	; 16
    1638:	19 f4       	brne	.+6      	; 0x1640 <__vector_4+0x7e>
    163a:	82 e0       	ldi	r24, 0x02	; 2
    163c:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <interr>
    1640:	ff 91       	pop	r31
    1642:	ef 91       	pop	r30
    1644:	cf 91       	pop	r28
    1646:	bf 91       	pop	r27
    1648:	af 91       	pop	r26
    164a:	9f 91       	pop	r25
    164c:	8f 91       	pop	r24
    164e:	7f 91       	pop	r23
    1650:	6f 91       	pop	r22
    1652:	5f 91       	pop	r21
    1654:	4f 91       	pop	r20
    1656:	3f 91       	pop	r19
    1658:	2f 91       	pop	r18
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	0f 90       	pop	r0
    1660:	0f be       	out	0x3f, r0	; 63
    1662:	0f 90       	pop	r0
    1664:	1f 90       	pop	r1
    1666:	18 95       	reti

00001668 <_Z8Darknessv>:
    1668:	e2 ed       	ldi	r30, 0xD2	; 210
    166a:	f2 e0       	ldi	r31, 0x02	; 2
    166c:	10 82       	st	Z, r1
    166e:	11 82       	std	Z+1, r1	; 0x01
    1670:	12 82       	std	Z+2, r1	; 0x02
    1672:	33 96       	adiw	r30, 0x03	; 3
    1674:	83 e0       	ldi	r24, 0x03	; 3
    1676:	e7 37       	cpi	r30, 0x77	; 119
    1678:	f8 07       	cpc	r31, r24
    167a:	c1 f7       	brne	.-16     	; 0x166c <_Z8Darknessv+0x4>
    167c:	08 95       	ret

0000167e <_Z4Firev>:
    167e:	9f 92       	push	r9
    1680:	af 92       	push	r10
    1682:	bf 92       	push	r11
    1684:	cf 92       	push	r12
    1686:	df 92       	push	r13
    1688:	ef 92       	push	r14
    168a:	ff 92       	push	r15
    168c:	0f 93       	push	r16
    168e:	1f 93       	push	r17
    1690:	cf 93       	push	r28
    1692:	df 93       	push	r29
    1694:	cd b7       	in	r28, 0x3d	; 61
    1696:	de b7       	in	r29, 0x3e	; 62
    1698:	ec 97       	sbiw	r28, 0x3c	; 60
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	0f be       	out	0x3f, r0	; 63
    16a2:	cd bf       	out	0x3d, r28	; 61
    16a4:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <cyclingTorchColor>
    16a8:	88 23       	and	r24, r24
    16aa:	09 f4       	brne	.+2      	; 0x16ae <_Z4Firev+0x30>
    16ac:	4b c0       	rjmp	.+150    	; 0x1744 <_Z4Firev+0xc6>
    16ae:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <_ZZ4FirevE3hue>
    16b2:	8f 5f       	subi	r24, 0xFF	; 255
    16b4:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <_ZZ4FirevE3hue>
    16b8:	89 83       	std	Y+1, r24	; 0x01
    16ba:	1f ef       	ldi	r17, 0xFF	; 255
    16bc:	1a 83       	std	Y+2, r17	; 0x02
    16be:	80 ec       	ldi	r24, 0xC0	; 192
    16c0:	8b 83       	std	Y+3, r24	; 0x03
    16c2:	be 01       	movw	r22, r28
    16c4:	66 5c       	subi	r22, 0xC6	; 198
    16c6:	7f 4f       	sbci	r23, 0xFF	; 255
    16c8:	ce 01       	movw	r24, r28
    16ca:	01 96       	adiw	r24, 0x01	; 1
    16cc:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    16d0:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <_ZZ4FirevE3hue>
    16d4:	89 83       	std	Y+1, r24	; 0x01
    16d6:	80 e8       	ldi	r24, 0x80	; 128
    16d8:	8a 83       	std	Y+2, r24	; 0x02
    16da:	1b 83       	std	Y+3, r17	; 0x03
    16dc:	be 01       	movw	r22, r28
    16de:	69 5c       	subi	r22, 0xC9	; 201
    16e0:	7f 4f       	sbci	r23, 0xFF	; 255
    16e2:	ce 01       	movw	r24, r28
    16e4:	01 96       	adiw	r24, 0x01	; 1
    16e6:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    16ea:	19 ab       	std	Y+49, r17	; 0x31
    16ec:	1a ab       	std	Y+50, r17	; 0x32
    16ee:	1b ab       	std	Y+51, r17	; 0x33
    16f0:	1c aa       	std	Y+52, r1	; 0x34
    16f2:	1d aa       	std	Y+53, r1	; 0x35
    16f4:	1e aa       	std	Y+54, r1	; 0x36
    16f6:	ce 01       	movw	r24, r28
    16f8:	c1 96       	adiw	r24, 0x31	; 49
    16fa:	7c 01       	movw	r14, r24
    16fc:	8e 01       	movw	r16, r28
    16fe:	09 5c       	subi	r16, 0xC9	; 201
    1700:	1f 4f       	sbci	r17, 0xFF	; 255
    1702:	9e 01       	movw	r18, r28
    1704:	26 5c       	subi	r18, 0xC6	; 198
    1706:	3f 4f       	sbci	r19, 0xFF	; 255
    1708:	ae 01       	movw	r20, r28
    170a:	4c 5c       	subi	r20, 0xCC	; 204
    170c:	5f 4f       	sbci	r21, 0xFF	; 255
    170e:	60 e1       	ldi	r22, 0x10	; 16
    1710:	70 e0       	ldi	r23, 0x00	; 0
    1712:	c0 97       	sbiw	r24, 0x30	; 48
    1714:	0e 94 92 1a 	call	0x3524	; 0x3524 <_Z17fill_gradient_RGBP4CRGBjRKS_S2_S2_S2_>
    1718:	40 e3       	ldi	r20, 0x30	; 48
    171a:	50 e0       	ldi	r21, 0x00	; 0
    171c:	be 01       	movw	r22, r28
    171e:	6f 5f       	subi	r22, 0xFF	; 255
    1720:	7f 4f       	sbci	r23, 0xFF	; 255
    1722:	82 ea       	ldi	r24, 0xA2	; 162
    1724:	92 e0       	ldi	r25, 0x02	; 2
    1726:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <memmove8>
    172a:	69 e2       	ldi	r22, 0x29	; 41
    172c:	c6 2e       	mov	r12, r22
    172e:	62 e0       	ldi	r22, 0x02	; 2
    1730:	d6 2e       	mov	r13, r22
    1732:	70 e6       	ldi	r23, 0x60	; 96
    1734:	e7 2e       	mov	r14, r23
    1736:	72 e0       	ldi	r23, 0x02	; 2
    1738:	f7 2e       	mov	r15, r23
    173a:	86 01       	movw	r16, r12
    173c:	e7 e3       	ldi	r30, 0x37	; 55
    173e:	ae 2e       	mov	r10, r30
    1740:	b1 2c       	mov	r11, r1
    1742:	47 c0       	rjmp	.+142    	; 0x17d2 <_Z4Firev+0x154>
    1744:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <torchHue>
    1748:	8f 3f       	cpi	r24, 0xFF	; 255
    174a:	99 f4       	brne	.+38     	; 0x1772 <_Z4Firev+0xf4>
    174c:	6b ee       	ldi	r22, 0xEB	; 235
    174e:	75 e0       	ldi	r23, 0x05	; 5
    1750:	82 ea       	ldi	r24, 0xA2	; 162
    1752:	92 e0       	ldi	r25, 0x02	; 2
    1754:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    1758:	0e 94 42 29 	call	0x5284	; 0x5284 <random>
    175c:	20 91 1d 01 	lds	r18, 0x011D	; 0x80011d <rand16seed>
    1760:	30 91 1e 01 	lds	r19, 0x011E	; 0x80011e <rand16seed+0x1>
    1764:	62 0f       	add	r22, r18
    1766:	73 1f       	adc	r23, r19
    1768:	70 93 1e 01 	sts	0x011E, r23	; 0x80011e <rand16seed+0x1>
    176c:	60 93 1d 01 	sts	0x011D, r22	; 0x80011d <rand16seed>
    1770:	dc cf       	rjmp	.-72     	; 0x172a <_Z4Firev+0xac>
    1772:	89 83       	std	Y+1, r24	; 0x01
    1774:	1f ef       	ldi	r17, 0xFF	; 255
    1776:	1a 83       	std	Y+2, r17	; 0x02
    1778:	80 ec       	ldi	r24, 0xC0	; 192
    177a:	8b 83       	std	Y+3, r24	; 0x03
    177c:	be 01       	movw	r22, r28
    177e:	66 5c       	subi	r22, 0xC6	; 198
    1780:	7f 4f       	sbci	r23, 0xFF	; 255
    1782:	ce 01       	movw	r24, r28
    1784:	01 96       	adiw	r24, 0x01	; 1
    1786:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    178a:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <torchHue>
    178e:	89 83       	std	Y+1, r24	; 0x01
    1790:	80 e8       	ldi	r24, 0x80	; 128
    1792:	8a 83       	std	Y+2, r24	; 0x02
    1794:	1b 83       	std	Y+3, r17	; 0x03
    1796:	be 01       	movw	r22, r28
    1798:	69 5c       	subi	r22, 0xC9	; 201
    179a:	7f 4f       	sbci	r23, 0xFF	; 255
    179c:	ce 01       	movw	r24, r28
    179e:	01 96       	adiw	r24, 0x01	; 1
    17a0:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    17a4:	19 ab       	std	Y+49, r17	; 0x31
    17a6:	1a ab       	std	Y+50, r17	; 0x32
    17a8:	1b ab       	std	Y+51, r17	; 0x33
    17aa:	1c aa       	std	Y+52, r1	; 0x34
    17ac:	1d aa       	std	Y+53, r1	; 0x35
    17ae:	1e aa       	std	Y+54, r1	; 0x36
    17b0:	fe 01       	movw	r30, r28
    17b2:	f1 96       	adiw	r30, 0x31	; 49
    17b4:	7f 01       	movw	r14, r30
    17b6:	8e 01       	movw	r16, r28
    17b8:	09 5c       	subi	r16, 0xC9	; 201
    17ba:	1f 4f       	sbci	r17, 0xFF	; 255
    17bc:	9e 01       	movw	r18, r28
    17be:	26 5c       	subi	r18, 0xC6	; 198
    17c0:	3f 4f       	sbci	r19, 0xFF	; 255
    17c2:	ae 01       	movw	r20, r28
    17c4:	4c 5c       	subi	r20, 0xCC	; 204
    17c6:	5f 4f       	sbci	r21, 0xFF	; 255
    17c8:	60 e1       	ldi	r22, 0x10	; 16
    17ca:	70 e0       	ldi	r23, 0x00	; 0
    17cc:	ce 01       	movw	r24, r28
    17ce:	01 96       	adiw	r24, 0x01	; 1
    17d0:	a1 cf       	rjmp	.-190    	; 0x1714 <_Z4Firev+0x96>
    17d2:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <COOLING>
    17d6:	fa e0       	ldi	r31, 0x0A	; 10
    17d8:	8f 9f       	mul	r24, r31
    17da:	c0 01       	movw	r24, r0
    17dc:	11 24       	eor	r1, r1
    17de:	b5 01       	movw	r22, r10
    17e0:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    17e4:	52 e0       	ldi	r21, 0x02	; 2
    17e6:	95 2e       	mov	r9, r21
    17e8:	96 0e       	add	r9, r22
    17ea:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    17ee:	89 9d       	mul	r24, r9
    17f0:	b0 01       	movw	r22, r0
    17f2:	11 24       	eor	r1, r1
    17f4:	f8 01       	movw	r30, r16
    17f6:	20 81       	ld	r18, Z
    17f8:	27 1b       	sub	r18, r23
    17fa:	08 f4       	brcc	.+2      	; 0x17fe <L_1428>
    17fc:	20 e0       	ldi	r18, 0x00	; 0

000017fe <L_1428>:
    17fe:	21 93       	st	Z+, r18
    1800:	8f 01       	movw	r16, r30
    1802:	ee 16       	cp	r14, r30
    1804:	ff 06       	cpc	r15, r31
    1806:	29 f7       	brne	.-54     	; 0x17d2 <_Z4Firev+0x154>
    1808:	ee e5       	ldi	r30, 0x5E	; 94
    180a:	f2 e0       	ldi	r31, 0x02	; 2
    180c:	03 e0       	ldi	r16, 0x03	; 3
    180e:	10 e0       	ldi	r17, 0x00	; 0
    1810:	80 81       	ld	r24, Z
    1812:	22 91       	ld	r18, -Z
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	82 0f       	add	r24, r18
    1818:	91 1d       	adc	r25, r1
    181a:	82 0f       	add	r24, r18
    181c:	91 1d       	adc	r25, r1
    181e:	b8 01       	movw	r22, r16
    1820:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    1824:	62 83       	std	Z+2, r22	; 0x02
    1826:	ce 16       	cp	r12, r30
    1828:	df 06       	cpc	r13, r31
    182a:	91 f7       	brne	.-28     	; 0x1810 <L_1428+0x12>
    182c:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1830:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <SPARKING>
    1834:	89 17       	cp	r24, r25
    1836:	d0 f4       	brcc	.+52     	; 0x186c <L_1526+0x2>
    1838:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    183c:	f7 e0       	ldi	r31, 0x07	; 7
    183e:	8f 9f       	mul	r24, r31
    1840:	c0 01       	movw	r24, r0
    1842:	11 24       	eor	r1, r1
    1844:	09 2f       	mov	r16, r25
    1846:	11 27       	eor	r17, r17
    1848:	07 fd       	sbrc	r16, 7
    184a:	1a 95       	dec	r17
    184c:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1850:	2f e5       	ldi	r18, 0x5F	; 95
    1852:	82 9f       	mul	r24, r18
    1854:	c0 01       	movw	r24, r0
    1856:	11 24       	eor	r1, r1
    1858:	30 ea       	ldi	r19, 0xA0	; 160
    185a:	39 0f       	add	r19, r25
    185c:	f8 01       	movw	r30, r16
    185e:	e7 5d       	subi	r30, 0xD7	; 215
    1860:	fd 4f       	sbci	r31, 0xFD	; 253
    1862:	20 81       	ld	r18, Z
    1864:	23 0f       	add	r18, r19
    1866:	08 f4       	brcc	.+2      	; 0x186a <L_1526>
    1868:	2f ef       	ldi	r18, 0xFF	; 255

0000186a <L_1526>:
    186a:	20 83       	st	Z, r18
    186c:	e1 2c       	mov	r14, r1
    186e:	f1 2c       	mov	r15, r1
    1870:	10 ef       	ldi	r17, 0xF0	; 240
    1872:	36 e3       	ldi	r19, 0x36	; 54
    1874:	a3 2e       	mov	r10, r19
    1876:	b1 2c       	mov	r11, r1
    1878:	f6 01       	movw	r30, r12
    187a:	41 91       	ld	r20, Z+
    187c:	6f 01       	movw	r12, r30
    187e:	41 9f       	mul	r20, r17
    1880:	04 0e       	add	r0, r20
    1882:	40 e0       	ldi	r20, 0x00	; 0
    1884:	41 1d       	adc	r20, r1
    1886:	11 24       	eor	r1, r1
    1888:	01 e0       	ldi	r16, 0x01	; 1
    188a:	2f ef       	ldi	r18, 0xFF	; 255
    188c:	62 ea       	ldi	r22, 0xA2	; 162
    188e:	72 e0       	ldi	r23, 0x02	; 2
    1890:	ce 01       	movw	r24, r28
    1892:	01 96       	adiw	r24, 0x01	; 1
    1894:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>
    1898:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <gReverseDirection>
    189c:	88 23       	and	r24, r24
    189e:	21 f0       	breq	.+8      	; 0x18a8 <L_1526+0x3e>
    18a0:	f5 01       	movw	r30, r10
    18a2:	ee 19       	sub	r30, r14
    18a4:	ff 09       	sbc	r31, r15
    18a6:	01 c0       	rjmp	.+2      	; 0x18aa <L_1526+0x40>
    18a8:	f7 01       	movw	r30, r14
    18aa:	cf 01       	movw	r24, r30
    18ac:	88 0f       	add	r24, r24
    18ae:	99 1f       	adc	r25, r25
    18b0:	e8 0f       	add	r30, r24
    18b2:	f9 1f       	adc	r31, r25
    18b4:	ee 52       	subi	r30, 0x2E	; 46
    18b6:	fd 4f       	sbci	r31, 0xFD	; 253
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
    18ba:	80 83       	st	Z, r24
    18bc:	8a 81       	ldd	r24, Y+2	; 0x02
    18be:	81 83       	std	Z+1, r24	; 0x01
    18c0:	8b 81       	ldd	r24, Y+3	; 0x03
    18c2:	82 83       	std	Z+2, r24	; 0x02
    18c4:	ff ef       	ldi	r31, 0xFF	; 255
    18c6:	ef 1a       	sub	r14, r31
    18c8:	ff 0a       	sbc	r15, r31
    18ca:	27 e3       	ldi	r18, 0x37	; 55
    18cc:	e2 16       	cp	r14, r18
    18ce:	f1 04       	cpc	r15, r1
    18d0:	99 f6       	brne	.-90     	; 0x1878 <L_1526+0xe>
    18d2:	ec 96       	adiw	r28, 0x3c	; 60
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	f8 94       	cli
    18d8:	de bf       	out	0x3e, r29	; 62
    18da:	0f be       	out	0x3f, r0	; 63
    18dc:	cd bf       	out	0x3d, r28	; 61
    18de:	df 91       	pop	r29
    18e0:	cf 91       	pop	r28
    18e2:	1f 91       	pop	r17
    18e4:	0f 91       	pop	r16
    18e6:	ff 90       	pop	r15
    18e8:	ef 90       	pop	r14
    18ea:	df 90       	pop	r13
    18ec:	cf 90       	pop	r12
    18ee:	bf 90       	pop	r11
    18f0:	af 90       	pop	r10
    18f2:	9f 90       	pop	r9
    18f4:	08 95       	ret

000018f6 <_Z7Lanternv>:
    18f6:	cf 93       	push	r28
    18f8:	df 93       	push	r29
    18fa:	00 d0       	rcall	.+0      	; 0x18fc <_Z7Lanternv+0x6>
    18fc:	1f 92       	push	r1
    18fe:	cd b7       	in	r28, 0x3d	; 61
    1900:	de b7       	in	r29, 0x3e	; 62
    1902:	8f ef       	ldi	r24, 0xFF	; 255
    1904:	89 83       	std	Y+1, r24	; 0x01
    1906:	8a 83       	std	Y+2, r24	; 0x02
    1908:	8b 83       	std	Y+3, r24	; 0x03
    190a:	ae 01       	movw	r20, r28
    190c:	4f 5f       	subi	r20, 0xFF	; 255
    190e:	5f 4f       	sbci	r21, 0xFF	; 255
    1910:	67 e3       	ldi	r22, 0x37	; 55
    1912:	70 e0       	ldi	r23, 0x00	; 0
    1914:	82 ed       	ldi	r24, 0xD2	; 210
    1916:	92 e0       	ldi	r25, 0x02	; 2
    1918:	0e 94 a6 19 	call	0x334c	; 0x334c <_Z10fill_solidP4CRGBiRKS_>
    191c:	0f 90       	pop	r0
    191e:	0f 90       	pop	r0
    1920:	0f 90       	pop	r0
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	08 95       	ret

00001928 <_Z4Pongv>:
    1928:	0f 93       	push	r16
    192a:	1f 93       	push	r17
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	00 d0       	rcall	.+0      	; 0x1932 <_Z4Pongv+0xa>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <_Z4Pongv+0xc>
    1934:	00 d0       	rcall	.+0      	; 0x1936 <_Z4Pongv+0xe>
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
    193a:	44 e1       	ldi	r20, 0x14	; 20
    193c:	67 e3       	ldi	r22, 0x37	; 55
    193e:	70 e0       	ldi	r23, 0x00	; 0
    1940:	82 ed       	ldi	r24, 0xD2	; 210
    1942:	92 e0       	ldi	r25, 0x02	; 2
    1944:	0e 94 48 1b 	call	0x3690	; 0x3690 <_Z13fadeToBlackByP4CRGBjh>
    1948:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    194c:	9b 01       	movw	r18, r22
    194e:	ac 01       	movw	r20, r24
    1950:	60 e0       	ldi	r22, 0x00	; 0
    1952:	78 e3       	ldi	r23, 0x38	; 56
    1954:	8e e0       	ldi	r24, 0x0E	; 14
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <__mulsi3>
    195c:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <_ZL9sin16_avrj>
    1960:	67 e3       	ldi	r22, 0x37	; 55
    1962:	70 e0       	ldi	r23, 0x00	; 0
    1964:	90 58       	subi	r25, 0x80	; 128
    1966:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_ZL7scale16jj>
    196a:	8c 01       	movw	r16, r24
    196c:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <gHue>
    1970:	8c 83       	std	Y+4, r24	; 0x04
    1972:	8f ef       	ldi	r24, 0xFF	; 255
    1974:	8d 83       	std	Y+5, r24	; 0x05
    1976:	80 ec       	ldi	r24, 0xC0	; 192
    1978:	8e 83       	std	Y+6, r24	; 0x06
    197a:	be 01       	movw	r22, r28
    197c:	6f 5f       	subi	r22, 0xFF	; 255
    197e:	7f 4f       	sbci	r23, 0xFF	; 255
    1980:	ce 01       	movw	r24, r28
    1982:	04 96       	adiw	r24, 0x04	; 4
    1984:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    1988:	c8 01       	movw	r24, r16
    198a:	88 0f       	add	r24, r24
    198c:	99 1f       	adc	r25, r25
    198e:	80 0f       	add	r24, r16
    1990:	91 1f       	adc	r25, r17
    1992:	be 01       	movw	r22, r28
    1994:	6f 5f       	subi	r22, 0xFF	; 255
    1996:	7f 4f       	sbci	r23, 0xFF	; 255
    1998:	8e 52       	subi	r24, 0x2E	; 46
    199a:	9d 4f       	sbci	r25, 0xFD	; 253
    199c:	0e 94 4f 09 	call	0x129e	; 0x129e <_ZN4CRGBpLERKS_>
    19a0:	26 96       	adiw	r28, 0x06	; 6
    19a2:	0f b6       	in	r0, 0x3f	; 63
    19a4:	f8 94       	cli
    19a6:	de bf       	out	0x3e, r29	; 62
    19a8:	0f be       	out	0x3f, r0	; 63
    19aa:	cd bf       	out	0x3d, r28	; 61
    19ac:	df 91       	pop	r29
    19ae:	cf 91       	pop	r28
    19b0:	1f 91       	pop	r17
    19b2:	0f 91       	pop	r16
    19b4:	08 95       	ret

000019b6 <_Z9WaveRacerv>:
    19b6:	df 92       	push	r13
    19b8:	ef 92       	push	r14
    19ba:	ff 92       	push	r15
    19bc:	0f 93       	push	r16
    19be:	1f 93       	push	r17
    19c0:	cf 93       	push	r28
    19c2:	df 93       	push	r29
    19c4:	00 d0       	rcall	.+0      	; 0x19c6 <_Z9WaveRacerv+0x10>
    19c6:	00 d0       	rcall	.+0      	; 0x19c8 <_Z9WaveRacerv+0x12>
    19c8:	00 d0       	rcall	.+0      	; 0x19ca <_Z9WaveRacerv+0x14>
    19ca:	cd b7       	in	r28, 0x3d	; 61
    19cc:	de b7       	in	r29, 0x3e	; 62
    19ce:	44 e1       	ldi	r20, 0x14	; 20
    19d0:	67 e3       	ldi	r22, 0x37	; 55
    19d2:	70 e0       	ldi	r23, 0x00	; 0
    19d4:	82 ed       	ldi	r24, 0xD2	; 210
    19d6:	92 e0       	ldi	r25, 0x02	; 2
    19d8:	0e 94 48 1b 	call	0x3690	; 0x3690 <_Z13fadeToBlackByP4CRGBjh>
    19dc:	07 e0       	ldi	r16, 0x07	; 7
    19de:	10 e0       	ldi	r17, 0x00	; 0
    19e0:	f1 2c       	mov	r15, r1
    19e2:	48 ec       	ldi	r20, 0xC8	; 200
    19e4:	e4 2e       	mov	r14, r20
    19e6:	dd 24       	eor	r13, r13
    19e8:	da 94       	dec	r13
    19ea:	fc 82       	std	Y+4, r15	; 0x04
    19ec:	ed 82       	std	Y+5, r14	; 0x05
    19ee:	de 82       	std	Y+6, r13	; 0x06
    19f0:	be 01       	movw	r22, r28
    19f2:	6f 5f       	subi	r22, 0xFF	; 255
    19f4:	7f 4f       	sbci	r23, 0xFF	; 255
    19f6:	ce 01       	movw	r24, r28
    19f8:	04 96       	adiw	r24, 0x04	; 4
    19fa:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    19fe:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    1a02:	9b 01       	movw	r18, r22
    1a04:	ac 01       	movw	r20, r24
    1a06:	a8 e1       	ldi	r26, 0x18	; 24
    1a08:	b1 e0       	ldi	r27, 0x01	; 1
    1a0a:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    1a0e:	9b 01       	movw	r18, r22
    1a10:	ac 01       	movw	r20, r24
    1a12:	b0 2f       	mov	r27, r16
    1a14:	a0 e0       	ldi	r26, 0x00	; 0
    1a16:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    1a1a:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <_ZL9sin16_avrj>
    1a1e:	67 e3       	ldi	r22, 0x37	; 55
    1a20:	70 e0       	ldi	r23, 0x00	; 0
    1a22:	90 58       	subi	r25, 0x80	; 128
    1a24:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_ZL7scale16jj>
    1a28:	29 81       	ldd	r18, Y+1	; 0x01
    1a2a:	fc 01       	movw	r30, r24
    1a2c:	ee 0f       	add	r30, r30
    1a2e:	ff 1f       	adc	r31, r31
    1a30:	df 01       	movw	r26, r30
    1a32:	a8 0f       	add	r26, r24
    1a34:	b9 1f       	adc	r27, r25
    1a36:	ae 52       	subi	r26, 0x2E	; 46
    1a38:	bd 4f       	sbci	r27, 0xFD	; 253
    1a3a:	3c 91       	ld	r19, X
    1a3c:	32 17       	cp	r19, r18
    1a3e:	08 f4       	brcc	.+2      	; 0x1a42 <_Z9WaveRacerv+0x8c>
    1a40:	2c 93       	st	X, r18
    1a42:	2a 81       	ldd	r18, Y+2	; 0x02
    1a44:	df 01       	movw	r26, r30
    1a46:	a8 0f       	add	r26, r24
    1a48:	b9 1f       	adc	r27, r25
    1a4a:	ae 52       	subi	r26, 0x2E	; 46
    1a4c:	bd 4f       	sbci	r27, 0xFD	; 253
    1a4e:	11 96       	adiw	r26, 0x01	; 1
    1a50:	3c 91       	ld	r19, X
    1a52:	11 97       	sbiw	r26, 0x01	; 1
    1a54:	32 17       	cp	r19, r18
    1a56:	10 f4       	brcc	.+4      	; 0x1a5c <_Z9WaveRacerv+0xa6>
    1a58:	11 96       	adiw	r26, 0x01	; 1
    1a5a:	2c 93       	st	X, r18
    1a5c:	2b 81       	ldd	r18, Y+3	; 0x03
    1a5e:	8e 0f       	add	r24, r30
    1a60:	9f 1f       	adc	r25, r31
    1a62:	fc 01       	movw	r30, r24
    1a64:	ee 52       	subi	r30, 0x2E	; 46
    1a66:	fd 4f       	sbci	r31, 0xFD	; 253
    1a68:	82 81       	ldd	r24, Z+2	; 0x02
    1a6a:	82 17       	cp	r24, r18
    1a6c:	08 f4       	brcc	.+2      	; 0x1a70 <_Z9WaveRacerv+0xba>
    1a6e:	22 83       	std	Z+2, r18	; 0x02
    1a70:	80 e2       	ldi	r24, 0x20	; 32
    1a72:	f8 0e       	add	r15, r24
    1a74:	0f 5f       	subi	r16, 0xFF	; 255
    1a76:	1f 4f       	sbci	r17, 0xFF	; 255
    1a78:	0f 30       	cpi	r16, 0x0F	; 15
    1a7a:	11 05       	cpc	r17, r1
    1a7c:	09 f0       	breq	.+2      	; 0x1a80 <_Z9WaveRacerv+0xca>
    1a7e:	b5 cf       	rjmp	.-150    	; 0x19ea <_Z9WaveRacerv+0x34>
    1a80:	26 96       	adiw	r28, 0x06	; 6
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	de bf       	out	0x3e, r29	; 62
    1a88:	0f be       	out	0x3f, r0	; 63
    1a8a:	cd bf       	out	0x3d, r28	; 61
    1a8c:	df 91       	pop	r29
    1a8e:	cf 91       	pop	r28
    1a90:	1f 91       	pop	r17
    1a92:	0f 91       	pop	r16
    1a94:	ff 90       	pop	r15
    1a96:	ef 90       	pop	r14
    1a98:	df 90       	pop	r13
    1a9a:	08 95       	ret

00001a9c <_Z5Jokerv>:
    1a9c:	1f 93       	push	r17
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
    1aa2:	cd b7       	in	r28, 0x3d	; 61
    1aa4:	de b7       	in	r29, 0x3e	; 62
    1aa6:	e6 97       	sbiw	r28, 0x36	; 54
    1aa8:	0f b6       	in	r0, 0x3f	; 63
    1aaa:	f8 94       	cli
    1aac:	de bf       	out	0x3e, r29	; 62
    1aae:	0f be       	out	0x3f, r0	; 63
    1ab0:	cd bf       	out	0x3d, r28	; 61
    1ab2:	80 ec       	ldi	r24, 0xC0	; 192
    1ab4:	89 83       	std	Y+1, r24	; 0x01
    1ab6:	1f ef       	ldi	r17, 0xFF	; 255
    1ab8:	1a 83       	std	Y+2, r17	; 0x02
    1aba:	1b 83       	std	Y+3, r17	; 0x03
    1abc:	be 01       	movw	r22, r28
    1abe:	6c 5c       	subi	r22, 0xCC	; 204
    1ac0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ac2:	ce 01       	movw	r24, r28
    1ac4:	01 96       	adiw	r24, 0x01	; 1
    1ac6:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    1aca:	80 e6       	ldi	r24, 0x60	; 96
    1acc:	89 83       	std	Y+1, r24	; 0x01
    1ace:	1a 83       	std	Y+2, r17	; 0x02
    1ad0:	1b 83       	std	Y+3, r17	; 0x03
    1ad2:	be 01       	movw	r22, r28
    1ad4:	6f 5c       	subi	r22, 0xCF	; 207
    1ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad8:	ce 01       	movw	r24, r28
    1ada:	01 96       	adiw	r24, 0x01	; 1
    1adc:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    1ae0:	59 a9       	ldd	r21, Y+49	; 0x31
    1ae2:	59 83       	std	Y+1, r21	; 0x01
    1ae4:	4a a9       	ldd	r20, Y+50	; 0x32
    1ae6:	4a 83       	std	Y+2, r20	; 0x02
    1ae8:	3b a9       	ldd	r19, Y+51	; 0x33
    1aea:	3b 83       	std	Y+3, r19	; 0x03
    1aec:	5c 83       	std	Y+4, r21	; 0x04
    1aee:	4d 83       	std	Y+5, r20	; 0x05
    1af0:	3e 83       	std	Y+6, r19	; 0x06
    1af2:	1f 82       	std	Y+7, r1	; 0x07
    1af4:	18 86       	std	Y+8, r1	; 0x08
    1af6:	19 86       	std	Y+9, r1	; 0x09
    1af8:	1a 86       	std	Y+10, r1	; 0x0a
    1afa:	1b 86       	std	Y+11, r1	; 0x0b
    1afc:	1c 86       	std	Y+12, r1	; 0x0c
    1afe:	2c a9       	ldd	r18, Y+52	; 0x34
    1b00:	2d 87       	std	Y+13, r18	; 0x0d
    1b02:	9d a9       	ldd	r25, Y+53	; 0x35
    1b04:	9e 87       	std	Y+14, r25	; 0x0e
    1b06:	8e a9       	ldd	r24, Y+54	; 0x36
    1b08:	8f 87       	std	Y+15, r24	; 0x0f
    1b0a:	28 8b       	std	Y+16, r18	; 0x10
    1b0c:	99 8b       	std	Y+17, r25	; 0x11
    1b0e:	8a 8b       	std	Y+18, r24	; 0x12
    1b10:	1b 8a       	std	Y+19, r1	; 0x13
    1b12:	1c 8a       	std	Y+20, r1	; 0x14
    1b14:	1d 8a       	std	Y+21, r1	; 0x15
    1b16:	1e 8a       	std	Y+22, r1	; 0x16
    1b18:	1f 8a       	std	Y+23, r1	; 0x17
    1b1a:	18 8e       	std	Y+24, r1	; 0x18
    1b1c:	59 8f       	std	Y+25, r21	; 0x19
    1b1e:	4a 8f       	std	Y+26, r20	; 0x1a
    1b20:	3b 8f       	std	Y+27, r19	; 0x1b
    1b22:	5c 8f       	std	Y+28, r21	; 0x1c
    1b24:	4d 8f       	std	Y+29, r20	; 0x1d
    1b26:	3e 8f       	std	Y+30, r19	; 0x1e
    1b28:	1f 8e       	std	Y+31, r1	; 0x1f
    1b2a:	18 a2       	std	Y+32, r1	; 0x20
    1b2c:	19 a2       	std	Y+33, r1	; 0x21
    1b2e:	1a a2       	std	Y+34, r1	; 0x22
    1b30:	1b a2       	std	Y+35, r1	; 0x23
    1b32:	1c a2       	std	Y+36, r1	; 0x24
    1b34:	2d a3       	std	Y+37, r18	; 0x25
    1b36:	9e a3       	std	Y+38, r25	; 0x26
    1b38:	8f a3       	std	Y+39, r24	; 0x27
    1b3a:	28 a7       	std	Y+40, r18	; 0x28
    1b3c:	99 a7       	std	Y+41, r25	; 0x29
    1b3e:	8a a7       	std	Y+42, r24	; 0x2a
    1b40:	1b a6       	std	Y+43, r1	; 0x2b
    1b42:	1c a6       	std	Y+44, r1	; 0x2c
    1b44:	1d a6       	std	Y+45, r1	; 0x2d
    1b46:	1e a6       	std	Y+46, r1	; 0x2e
    1b48:	1f a6       	std	Y+47, r1	; 0x2f
    1b4a:	18 aa       	std	Y+48, r1	; 0x30
    1b4c:	40 e3       	ldi	r20, 0x30	; 48
    1b4e:	50 e0       	ldi	r21, 0x00	; 0
    1b50:	be 01       	movw	r22, r28
    1b52:	6f 5f       	subi	r22, 0xFF	; 255
    1b54:	7f 4f       	sbci	r23, 0xFF	; 255
    1b56:	82 ea       	ldi	r24, 0xA2	; 162
    1b58:	92 e0       	ldi	r25, 0x02	; 2
    1b5a:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <memmove8>
    1b5e:	e6 96       	adiw	r28, 0x36	; 54
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	de bf       	out	0x3e, r29	; 62
    1b66:	0f be       	out	0x3f, r0	; 63
    1b68:	cd bf       	out	0x3d, r28	; 61
    1b6a:	df 91       	pop	r29
    1b6c:	cf 91       	pop	r28
    1b6e:	1f 91       	pop	r17
    1b70:	08 95       	ret

00001b72 <_Z7p_1940sv>:
    1b72:	cf 93       	push	r28
    1b74:	df 93       	push	r29
    1b76:	00 d0       	rcall	.+0      	; 0x1b78 <_Z7p_1940sv+0x6>
    1b78:	1f 92       	push	r1
    1b7a:	cd b7       	in	r28, 0x3d	; 61
    1b7c:	de b7       	in	r29, 0x3e	; 62
    1b7e:	19 82       	std	Y+1, r1	; 0x01
    1b80:	1a 82       	std	Y+2, r1	; 0x02
    1b82:	1b 82       	std	Y+3, r1	; 0x03
    1b84:	ae 01       	movw	r20, r28
    1b86:	4f 5f       	subi	r20, 0xFF	; 255
    1b88:	5f 4f       	sbci	r21, 0xFF	; 255
    1b8a:	60 e1       	ldi	r22, 0x10	; 16
    1b8c:	70 e0       	ldi	r23, 0x00	; 0
    1b8e:	82 ea       	ldi	r24, 0xA2	; 162
    1b90:	92 e0       	ldi	r25, 0x02	; 2
    1b92:	0e 94 a6 19 	call	0x334c	; 0x334c <_Z10fill_solidP4CRGBiRKS_>
    1b96:	e2 ea       	ldi	r30, 0xA2	; 162
    1b98:	f2 e0       	ldi	r31, 0x02	; 2
    1b9a:	8f ef       	ldi	r24, 0xFF	; 255
    1b9c:	80 83       	st	Z, r24
    1b9e:	81 83       	std	Z+1, r24	; 0x01
    1ba0:	82 83       	std	Z+2, r24	; 0x02
    1ba2:	84 87       	std	Z+12, r24	; 0x0c
    1ba4:	85 87       	std	Z+13, r24	; 0x0d
    1ba6:	86 87       	std	Z+14, r24	; 0x0e
    1ba8:	80 8f       	std	Z+24, r24	; 0x18
    1baa:	81 8f       	std	Z+25, r24	; 0x19
    1bac:	82 8f       	std	Z+26, r24	; 0x1a
    1bae:	84 a3       	std	Z+36, r24	; 0x24
    1bb0:	85 a3       	std	Z+37, r24	; 0x25
    1bb2:	86 a3       	std	Z+38, r24	; 0x26
    1bb4:	0f 90       	pop	r0
    1bb6:	0f 90       	pop	r0
    1bb8:	0f 90       	pop	r0
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	08 95       	ret

00001bc0 <_Z7Seizurev>:
    1bc0:	ef 92       	push	r14
    1bc2:	ff 92       	push	r15
    1bc4:	0f 93       	push	r16
    1bc6:	1f 93       	push	r17
    1bc8:	cf 93       	push	r28
    1bca:	df 93       	push	r29
    1bcc:	00 d0       	rcall	.+0      	; 0x1bce <_Z7Seizurev+0xe>
    1bce:	1f 92       	push	r1
    1bd0:	cd b7       	in	r28, 0x3d	; 61
    1bd2:	de b7       	in	r29, 0x3e	; 62
    1bd4:	02 ea       	ldi	r16, 0xA2	; 162
    1bd6:	12 e0       	ldi	r17, 0x02	; 2
    1bd8:	ee 24       	eor	r14, r14
    1bda:	ea 94       	dec	r14
    1bdc:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1be0:	f8 2e       	mov	r15, r24
    1be2:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1be6:	89 83       	std	Y+1, r24	; 0x01
    1be8:	ea 82       	std	Y+2, r14	; 0x02
    1bea:	fb 82       	std	Y+3, r15	; 0x03
    1bec:	b8 01       	movw	r22, r16
    1bee:	ce 01       	movw	r24, r28
    1bf0:	01 96       	adiw	r24, 0x01	; 1
    1bf2:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    1bf6:	0d 5f       	subi	r16, 0xFD	; 253
    1bf8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bfa:	82 e0       	ldi	r24, 0x02	; 2
    1bfc:	02 3d       	cpi	r16, 0xD2	; 210
    1bfe:	18 07       	cpc	r17, r24
    1c00:	69 f7       	brne	.-38     	; 0x1bdc <_Z7Seizurev+0x1c>
    1c02:	42 e3       	ldi	r20, 0x32	; 50
    1c04:	50 e0       	ldi	r21, 0x00	; 0
    1c06:	60 e0       	ldi	r22, 0x00	; 0
    1c08:	70 e0       	ldi	r23, 0x00	; 0
    1c0a:	8e e4       	ldi	r24, 0x4E	; 78
    1c0c:	94 e0       	ldi	r25, 0x04	; 4
    1c0e:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <_ZN8CFastLED5delayEm>
    1c12:	0f 90       	pop	r0
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
    1c18:	df 91       	pop	r29
    1c1a:	cf 91       	pop	r28
    1c1c:	1f 91       	pop	r17
    1c1e:	0f 91       	pop	r16
    1c20:	ff 90       	pop	r15
    1c22:	ef 90       	pop	r14
    1c24:	08 95       	ret

00001c26 <_Z7Flickerv>:
    1c26:	0f 93       	push	r16
    1c28:	1f 93       	push	r17
    1c2a:	cf 93       	push	r28
    1c2c:	df 93       	push	r29
    1c2e:	00 d0       	rcall	.+0      	; 0x1c30 <_Z7Flickerv+0xa>
    1c30:	00 d0       	rcall	.+0      	; 0x1c32 <_Z7Flickerv+0xc>
    1c32:	00 d0       	rcall	.+0      	; 0x1c34 <_Z7Flickerv+0xe>
    1c34:	cd b7       	in	r28, 0x3d	; 61
    1c36:	de b7       	in	r29, 0x3e	; 62
    1c38:	4a e0       	ldi	r20, 0x0A	; 10
    1c3a:	67 e3       	ldi	r22, 0x37	; 55
    1c3c:	70 e0       	ldi	r23, 0x00	; 0
    1c3e:	82 ed       	ldi	r24, 0xD2	; 210
    1c40:	92 e0       	ldi	r25, 0x02	; 2
    1c42:	0e 94 48 1b 	call	0x3690	; 0x3690 <_Z13fadeToBlackByP4CRGBjh>
    1c46:	20 91 1d 01 	lds	r18, 0x011D	; 0x80011d <rand16seed>
    1c4a:	30 91 1e 01 	lds	r19, 0x011E	; 0x80011e <rand16seed+0x1>
    1c4e:	85 e0       	ldi	r24, 0x05	; 5
    1c50:	98 e0       	ldi	r25, 0x08	; 8
    1c52:	28 9f       	mul	r18, r24
    1c54:	80 01       	movw	r16, r0
    1c56:	29 9f       	mul	r18, r25
    1c58:	10 0d       	add	r17, r0
    1c5a:	38 9f       	mul	r19, r24
    1c5c:	10 0d       	add	r17, r0
    1c5e:	11 24       	eor	r1, r1
    1c60:	07 5e       	subi	r16, 0xE7	; 231
    1c62:	19 4c       	sbci	r17, 0xC9	; 201
    1c64:	10 93 1e 01 	sts	0x011E, r17	; 0x80011e <rand16seed+0x1>
    1c68:	00 93 1d 01 	sts	0x011D, r16	; 0x80011d <rand16seed>
    1c6c:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1c70:	20 e4       	ldi	r18, 0x40	; 64
    1c72:	82 9f       	mul	r24, r18
    1c74:	c0 01       	movw	r24, r0
    1c76:	11 24       	eor	r1, r1
    1c78:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <gHue>
    1c7c:	89 0f       	add	r24, r25
    1c7e:	8c 83       	std	Y+4, r24	; 0x04
    1c80:	88 ec       	ldi	r24, 0xC8	; 200
    1c82:	8d 83       	std	Y+5, r24	; 0x05
    1c84:	8f ef       	ldi	r24, 0xFF	; 255
    1c86:	8e 83       	std	Y+6, r24	; 0x06
    1c88:	be 01       	movw	r22, r28
    1c8a:	6f 5f       	subi	r22, 0xFF	; 255
    1c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8e:	ce 01       	movw	r24, r28
    1c90:	04 96       	adiw	r24, 0x04	; 4
    1c92:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    1c96:	98 01       	movw	r18, r16
    1c98:	a7 e3       	ldi	r26, 0x37	; 55
    1c9a:	b0 e0       	ldi	r27, 0x00	; 0
    1c9c:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__umulhisi3>
    1ca0:	aa 27       	eor	r26, r26
    1ca2:	bb 27       	eor	r27, r27
    1ca4:	9c 01       	movw	r18, r24
    1ca6:	22 0f       	add	r18, r18
    1ca8:	33 1f       	adc	r19, r19
    1caa:	82 0f       	add	r24, r18
    1cac:	93 1f       	adc	r25, r19
    1cae:	be 01       	movw	r22, r28
    1cb0:	6f 5f       	subi	r22, 0xFF	; 255
    1cb2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb4:	8e 52       	subi	r24, 0x2E	; 46
    1cb6:	9d 4f       	sbci	r25, 0xFD	; 253
    1cb8:	0e 94 4f 09 	call	0x129e	; 0x129e <_ZN4CRGBpLERKS_>
    1cbc:	26 96       	adiw	r28, 0x06	; 6
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	de bf       	out	0x3e, r29	; 62
    1cc4:	0f be       	out	0x3f, r0	; 63
    1cc6:	cd bf       	out	0x3d, r28	; 61
    1cc8:	df 91       	pop	r29
    1cca:	cf 91       	pop	r28
    1ccc:	1f 91       	pop	r17
    1cce:	0f 91       	pop	r16
    1cd0:	08 95       	ret

00001cd2 <_Z25FillLEDsFromPaletteColorsh>:
    1cd2:	cf 92       	push	r12
    1cd4:	df 92       	push	r13
    1cd6:	ef 92       	push	r14
    1cd8:	ff 92       	push	r15
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <_Z25FillLEDsFromPaletteColorsh+0x12>
    1ce4:	1f 92       	push	r1
    1ce6:	cd b7       	in	r28, 0x3d	; 61
    1ce8:	de b7       	in	r29, 0x3e	; 62
    1cea:	18 2f       	mov	r17, r24
    1cec:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <gReverseDirection>
    1cf0:	81 11       	cpse	r24, r1
    1cf2:	24 c0       	rjmp	.+72     	; 0x1d3c <_Z25FillLEDsFromPaletteColorsh+0x6a>
    1cf4:	24 e7       	ldi	r18, 0x74	; 116
    1cf6:	e2 2e       	mov	r14, r18
    1cf8:	23 e0       	ldi	r18, 0x03	; 3
    1cfa:	f2 2e       	mov	r15, r18
    1cfc:	3f ec       	ldi	r19, 0xCF	; 207
    1cfe:	c3 2e       	mov	r12, r19
    1d00:	32 e0       	ldi	r19, 0x02	; 2
    1d02:	d3 2e       	mov	r13, r19
    1d04:	00 91 a1 02 	lds	r16, 0x02A1	; 0x8002a1 <currentBlending>
    1d08:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    1d0c:	41 2f       	mov	r20, r17
    1d0e:	62 ea       	ldi	r22, 0xA2	; 162
    1d10:	72 e0       	ldi	r23, 0x02	; 2
    1d12:	ce 01       	movw	r24, r28
    1d14:	01 96       	adiw	r24, 0x01	; 1
    1d16:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>
    1d1a:	89 81       	ldd	r24, Y+1	; 0x01
    1d1c:	f7 01       	movw	r30, r14
    1d1e:	80 83       	st	Z, r24
    1d20:	8a 81       	ldd	r24, Y+2	; 0x02
    1d22:	81 83       	std	Z+1, r24	; 0x01
    1d24:	8b 81       	ldd	r24, Y+3	; 0x03
    1d26:	82 83       	std	Z+2, r24	; 0x02
    1d28:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <cloudNumber>
    1d2c:	18 0f       	add	r17, r24
    1d2e:	f3 e0       	ldi	r31, 0x03	; 3
    1d30:	ef 1a       	sub	r14, r31
    1d32:	f1 08       	sbc	r15, r1
    1d34:	ce 14       	cp	r12, r14
    1d36:	df 04       	cpc	r13, r15
    1d38:	29 f7       	brne	.-54     	; 0x1d04 <_Z25FillLEDsFromPaletteColorsh+0x32>
    1d3a:	23 c0       	rjmp	.+70     	; 0x1d82 <_Z25FillLEDsFromPaletteColorsh+0xb0>
    1d3c:	82 ed       	ldi	r24, 0xD2	; 210
    1d3e:	e8 2e       	mov	r14, r24
    1d40:	82 e0       	ldi	r24, 0x02	; 2
    1d42:	f8 2e       	mov	r15, r24
    1d44:	97 e7       	ldi	r25, 0x77	; 119
    1d46:	c9 2e       	mov	r12, r25
    1d48:	93 e0       	ldi	r25, 0x03	; 3
    1d4a:	d9 2e       	mov	r13, r25
    1d4c:	00 91 a1 02 	lds	r16, 0x02A1	; 0x8002a1 <currentBlending>
    1d50:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    1d54:	41 2f       	mov	r20, r17
    1d56:	62 ea       	ldi	r22, 0xA2	; 162
    1d58:	72 e0       	ldi	r23, 0x02	; 2
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	01 96       	adiw	r24, 0x01	; 1
    1d5e:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>
    1d62:	89 81       	ldd	r24, Y+1	; 0x01
    1d64:	f7 01       	movw	r30, r14
    1d66:	80 83       	st	Z, r24
    1d68:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6a:	81 83       	std	Z+1, r24	; 0x01
    1d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6e:	82 83       	std	Z+2, r24	; 0x02
    1d70:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <cloudNumber>
    1d74:	18 0f       	add	r17, r24
    1d76:	f3 e0       	ldi	r31, 0x03	; 3
    1d78:	ef 0e       	add	r14, r31
    1d7a:	f1 1c       	adc	r15, r1
    1d7c:	ce 14       	cp	r12, r14
    1d7e:	df 04       	cpc	r13, r15
    1d80:	29 f7       	brne	.-54     	; 0x1d4c <_Z25FillLEDsFromPaletteColorsh+0x7a>
    1d82:	0f 90       	pop	r0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	df 91       	pop	r29
    1d8a:	cf 91       	pop	r28
    1d8c:	1f 91       	pop	r17
    1d8e:	0f 91       	pop	r16
    1d90:	ff 90       	pop	r15
    1d92:	ef 90       	pop	r14
    1d94:	df 90       	pop	r13
    1d96:	cf 90       	pop	r12
    1d98:	08 95       	ret

00001d9a <_Z6Cloudsv>:
    1d9a:	6b ee       	ldi	r22, 0xEB	; 235
    1d9c:	76 e0       	ldi	r23, 0x06	; 6
    1d9e:	82 ea       	ldi	r24, 0xA2	; 162
    1da0:	92 e0       	ldi	r25, 0x02	; 2
    1da2:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    1da6:	81 e0       	ldi	r24, 0x01	; 1
    1da8:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <currentBlending>
    1dac:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <_ZZ6CloudsvE10startIndex>
    1db0:	8f 5f       	subi	r24, 0xFF	; 255
    1db2:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <_ZZ6CloudsvE10startIndex>
    1db6:	0c 94 69 0e 	jmp	0x1cd2	; 0x1cd2 <_Z25FillLEDsFromPaletteColorsh>

00001dba <_Z8FunStuffh>:
    1dba:	81 11       	cpse	r24, r1
    1dbc:	03 c0       	rjmp	.+6      	; 0x1dc4 <_Z8FunStuffh+0xa>
    1dbe:	6b ea       	ldi	r22, 0xAB	; 171
    1dc0:	76 e0       	ldi	r23, 0x06	; 6
    1dc2:	28 c0       	rjmp	.+80     	; 0x1e14 <_Z8FunStuffh+0x5a>
    1dc4:	81 30       	cpi	r24, 0x01	; 1
    1dc6:	39 f4       	brne	.+14     	; 0x1dd6 <_Z8FunStuffh+0x1c>
    1dc8:	6b e6       	ldi	r22, 0x6B	; 107
    1dca:	76 e0       	ldi	r23, 0x06	; 6
    1dcc:	82 ea       	ldi	r24, 0xA2	; 162
    1dce:	92 e0       	ldi	r25, 0x02	; 2
    1dd0:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    1dd4:	13 c0       	rjmp	.+38     	; 0x1dfc <_Z8FunStuffh+0x42>
    1dd6:	82 30       	cpi	r24, 0x02	; 2
    1dd8:	19 f4       	brne	.+6      	; 0x1de0 <_Z8FunStuffh+0x26>
    1dda:	6b e6       	ldi	r22, 0x6B	; 107
    1ddc:	76 e0       	ldi	r23, 0x06	; 6
    1dde:	1a c0       	rjmp	.+52     	; 0x1e14 <_Z8FunStuffh+0x5a>
    1de0:	83 30       	cpi	r24, 0x03	; 3
    1de2:	19 f4       	brne	.+6      	; 0x1dea <_Z8FunStuffh+0x30>
    1de4:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <_Z5Jokerv>
    1de8:	19 c0       	rjmp	.+50     	; 0x1e1c <_Z8FunStuffh+0x62>
    1dea:	84 30       	cpi	r24, 0x04	; 4
    1dec:	19 f4       	brne	.+6      	; 0x1df4 <_Z8FunStuffh+0x3a>
    1dee:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <_Z7Seizurev>
    1df2:	14 c0       	rjmp	.+40     	; 0x1e1c <_Z8FunStuffh+0x62>
    1df4:	85 30       	cpi	r24, 0x05	; 5
    1df6:	29 f4       	brne	.+10     	; 0x1e02 <_Z8FunStuffh+0x48>
    1df8:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <_Z7p_1940sv>
    1dfc:	10 92 a1 02 	sts	0x02A1, r1	; 0x8002a1 <currentBlending>
    1e00:	10 c0       	rjmp	.+32     	; 0x1e22 <_Z8FunStuffh+0x68>
    1e02:	86 30       	cpi	r24, 0x06	; 6
    1e04:	19 f4       	brne	.+6      	; 0x1e0c <_Z8FunStuffh+0x52>
    1e06:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <_Z7p_1940sv>
    1e0a:	08 c0       	rjmp	.+16     	; 0x1e1c <_Z8FunStuffh+0x62>
    1e0c:	87 30       	cpi	r24, 0x07	; 7
    1e0e:	49 f4       	brne	.+18     	; 0x1e22 <_Z8FunStuffh+0x68>
    1e10:	6b e2       	ldi	r22, 0x2B	; 43
    1e12:	76 e0       	ldi	r23, 0x06	; 6
    1e14:	82 ea       	ldi	r24, 0xA2	; 162
    1e16:	92 e0       	ldi	r25, 0x02	; 2
    1e18:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <currentBlending>
    1e22:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <_ZZ8FunStuffhE10startIndex>
    1e26:	8f 5f       	subi	r24, 0xFF	; 255
    1e28:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <_ZZ8FunStuffhE10startIndex>
    1e2c:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <_Z25FillLEDsFromPaletteColorsh>
    1e30:	4a e0       	ldi	r20, 0x0A	; 10
    1e32:	50 e0       	ldi	r21, 0x00	; 0
    1e34:	60 e0       	ldi	r22, 0x00	; 0
    1e36:	70 e0       	ldi	r23, 0x00	; 0
    1e38:	8e e4       	ldi	r24, 0x4E	; 78
    1e3a:	94 e0       	ldi	r25, 0x04	; 4
    1e3c:	0c 94 0c 1d 	jmp	0x3a18	; 0x3a18 <_ZN8CFastLED5delayEm>

00001e40 <_Z7fadeallv>:
    1e40:	e2 ed       	ldi	r30, 0xD2	; 210
    1e42:	f2 e0       	ldi	r31, 0x02	; 2
    1e44:	3a ef       	ldi	r19, 0xFA	; 250
    1e46:	20 81       	ld	r18, Z
    1e48:	23 9f       	mul	r18, r19
    1e4a:	02 0e       	add	r0, r18
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	21 1d       	adc	r18, r1
    1e50:	20 83       	st	Z, r18
    1e52:	21 81       	ldd	r18, Z+1	; 0x01
    1e54:	23 9f       	mul	r18, r19
    1e56:	02 0e       	add	r0, r18
    1e58:	20 e0       	ldi	r18, 0x00	; 0
    1e5a:	21 1d       	adc	r18, r1
    1e5c:	21 83       	std	Z+1, r18	; 0x01
    1e5e:	22 81       	ldd	r18, Z+2	; 0x02
    1e60:	23 9f       	mul	r18, r19
    1e62:	02 0e       	add	r0, r18
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	21 1d       	adc	r18, r1
    1e68:	22 83       	std	Z+2, r18	; 0x02
    1e6a:	11 24       	eor	r1, r1
    1e6c:	33 96       	adiw	r30, 0x03	; 3
    1e6e:	83 e0       	ldi	r24, 0x03	; 3
    1e70:	e7 37       	cpi	r30, 0x77	; 119
    1e72:	f8 07       	cpc	r31, r24
    1e74:	41 f7       	brne	.-48     	; 0x1e46 <_Z7fadeallv+0x6>
    1e76:	08 95       	ret

00001e78 <_Z10addGlitterh>:
    1e78:	1f 93       	push	r17
    1e7a:	cf 93       	push	r28
    1e7c:	df 93       	push	r29
    1e7e:	00 d0       	rcall	.+0      	; 0x1e80 <_Z10addGlitterh+0x8>
    1e80:	1f 92       	push	r1
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
    1e86:	18 2f       	mov	r17, r24
    1e88:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_ZL7random8v>
    1e8c:	81 17       	cp	r24, r17
    1e8e:	48 f5       	brcc	.+82     	; 0x1ee2 <_Z10addGlitterh+0x6a>
    1e90:	8f ef       	ldi	r24, 0xFF	; 255
    1e92:	89 83       	std	Y+1, r24	; 0x01
    1e94:	8a 83       	std	Y+2, r24	; 0x02
    1e96:	8b 83       	std	Y+3, r24	; 0x03
    1e98:	40 91 1d 01 	lds	r20, 0x011D	; 0x80011d <rand16seed>
    1e9c:	50 91 1e 01 	lds	r21, 0x011E	; 0x80011e <rand16seed+0x1>
    1ea0:	85 e0       	ldi	r24, 0x05	; 5
    1ea2:	98 e0       	ldi	r25, 0x08	; 8
    1ea4:	48 9f       	mul	r20, r24
    1ea6:	90 01       	movw	r18, r0
    1ea8:	49 9f       	mul	r20, r25
    1eaa:	30 0d       	add	r19, r0
    1eac:	58 9f       	mul	r21, r24
    1eae:	30 0d       	add	r19, r0
    1eb0:	11 24       	eor	r1, r1
    1eb2:	27 5e       	subi	r18, 0xE7	; 231
    1eb4:	39 4c       	sbci	r19, 0xC9	; 201
    1eb6:	30 93 1e 01 	sts	0x011E, r19	; 0x80011e <rand16seed+0x1>
    1eba:	20 93 1d 01 	sts	0x011D, r18	; 0x80011d <rand16seed>
    1ebe:	a7 e3       	ldi	r26, 0x37	; 55
    1ec0:	b0 e0       	ldi	r27, 0x00	; 0
    1ec2:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__umulhisi3>
    1ec6:	aa 27       	eor	r26, r26
    1ec8:	bb 27       	eor	r27, r27
    1eca:	9c 01       	movw	r18, r24
    1ecc:	22 0f       	add	r18, r18
    1ece:	33 1f       	adc	r19, r19
    1ed0:	82 0f       	add	r24, r18
    1ed2:	93 1f       	adc	r25, r19
    1ed4:	be 01       	movw	r22, r28
    1ed6:	6f 5f       	subi	r22, 0xFF	; 255
    1ed8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eda:	8e 52       	subi	r24, 0x2E	; 46
    1edc:	9d 4f       	sbci	r25, 0xFD	; 253
    1ede:	0e 94 4f 09 	call	0x129e	; 0x129e <_ZN4CRGBpLERKS_>
    1ee2:	0f 90       	pop	r0
    1ee4:	0f 90       	pop	r0
    1ee6:	0f 90       	pop	r0
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	1f 91       	pop	r17
    1eee:	08 95       	ret

00001ef0 <_Z14RainbowGlitterv>:
    1ef0:	27 e0       	ldi	r18, 0x07	; 7
    1ef2:	40 91 a0 02 	lds	r20, 0x02A0	; 0x8002a0 <gHue>
    1ef6:	67 e3       	ldi	r22, 0x37	; 55
    1ef8:	70 e0       	ldi	r23, 0x00	; 0
    1efa:	82 ed       	ldi	r24, 0xD2	; 210
    1efc:	92 e0       	ldi	r25, 0x02	; 2
    1efe:	0e 94 bb 19 	call	0x3376	; 0x3376 <_Z12fill_rainbowP4CRGBihh>
    1f02:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <chanceOfGlitter>
    1f06:	0c 94 3c 0f 	jmp	0x1e78	; 0x1e78 <_Z10addGlitterh>

00001f0a <_Z5Stackv>:
    1f0a:	0f 93       	push	r16
    1f0c:	cf 93       	push	r28
    1f0e:	df 93       	push	r29
    1f10:	00 d0       	rcall	.+0      	; 0x1f12 <_Z5Stackv+0x8>
    1f12:	1f 92       	push	r1
    1f14:	cd b7       	in	r28, 0x3d	; 61
    1f16:	de b7       	in	r29, 0x3e	; 62
    1f18:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <stack_index>
    1f1c:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <stack_ch>
    1f20:	89 13       	cpse	r24, r25
    1f22:	0a c0       	rjmp	.+20     	; 0x1f38 <_Z5Stackv+0x2e>
    1f24:	81 50       	subi	r24, 0x01	; 1
    1f26:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <stack_ch>
    1f2a:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <stack_colorIndex>
    1f2e:	8c 5f       	subi	r24, 0xFC	; 252
    1f30:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <stack_colorIndex>
    1f34:	10 92 95 02 	sts	0x0295, r1	; 0x800295 <stack_index>
    1f38:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <gReverseDirection>
    1f3c:	00 91 a1 02 	lds	r16, 0x02A1	; 0x8002a1 <currentBlending>
    1f40:	24 e6       	ldi	r18, 0x64	; 100
    1f42:	40 91 96 02 	lds	r20, 0x0296	; 0x800296 <stack_colorIndex>
    1f46:	62 ea       	ldi	r22, 0xA2	; 162
    1f48:	72 e0       	ldi	r23, 0x02	; 2
    1f4a:	81 11       	cpse	r24, r1
    1f4c:	1d c0       	rjmp	.+58     	; 0x1f88 <_Z5Stackv+0x7e>
    1f4e:	ce 01       	movw	r24, r28
    1f50:	01 96       	adiw	r24, 0x01	; 1
    1f52:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>
    1f56:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <stack_index>
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	e5 e3       	ldi	r30, 0x35	; 53
    1f5e:	f0 e0       	ldi	r31, 0x00	; 0
    1f60:	e8 1b       	sub	r30, r24
    1f62:	f9 0b       	sbc	r31, r25
    1f64:	9f 01       	movw	r18, r30
    1f66:	22 0f       	add	r18, r18
    1f68:	33 1f       	adc	r19, r19
    1f6a:	e2 0f       	add	r30, r18
    1f6c:	f3 1f       	adc	r31, r19
    1f6e:	ee 52       	subi	r30, 0x2E	; 46
    1f70:	fd 4f       	sbci	r31, 0xFD	; 253
    1f72:	29 81       	ldd	r18, Y+1	; 0x01
    1f74:	20 83       	st	Z, r18
    1f76:	2a 81       	ldd	r18, Y+2	; 0x02
    1f78:	21 83       	std	Z+1, r18	; 0x01
    1f7a:	2b 81       	ldd	r18, Y+3	; 0x03
    1f7c:	22 83       	std	Z+2, r18	; 0x02
    1f7e:	e6 e3       	ldi	r30, 0x36	; 54
    1f80:	f0 e0       	ldi	r31, 0x00	; 0
    1f82:	e8 1b       	sub	r30, r24
    1f84:	f9 0b       	sbc	r31, r25
    1f86:	18 c0       	rjmp	.+48     	; 0x1fb8 <_Z5Stackv+0xae>
    1f88:	ce 01       	movw	r24, r28
    1f8a:	01 96       	adiw	r24, 0x01	; 1
    1f8c:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>
    1f90:	e0 91 95 02 	lds	r30, 0x0295	; 0x800295 <stack_index>
    1f94:	f0 e0       	ldi	r31, 0x00	; 0
    1f96:	df 01       	movw	r26, r30
    1f98:	aa 0f       	add	r26, r26
    1f9a:	bb 1f       	adc	r27, r27
    1f9c:	ae 0f       	add	r26, r30
    1f9e:	bf 1f       	adc	r27, r31
    1fa0:	ae 52       	subi	r26, 0x2E	; 46
    1fa2:	bd 4f       	sbci	r27, 0xFD	; 253
    1fa4:	89 81       	ldd	r24, Y+1	; 0x01
    1fa6:	8c 93       	st	X, r24
    1fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    1faa:	11 96       	adiw	r26, 0x01	; 1
    1fac:	8c 93       	st	X, r24
    1fae:	11 97       	sbiw	r26, 0x01	; 1
    1fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb2:	12 96       	adiw	r26, 0x02	; 2
    1fb4:	8c 93       	st	X, r24
    1fb6:	31 97       	sbiw	r30, 0x01	; 1
    1fb8:	cf 01       	movw	r24, r30
    1fba:	88 0f       	add	r24, r24
    1fbc:	99 1f       	adc	r25, r25
    1fbe:	e8 0f       	add	r30, r24
    1fc0:	f9 1f       	adc	r31, r25
    1fc2:	ee 52       	subi	r30, 0x2E	; 46
    1fc4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fc6:	10 82       	st	Z, r1
    1fc8:	11 82       	std	Z+1, r1	; 0x01
    1fca:	12 82       	std	Z+2, r1	; 0x02
    1fcc:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <stack_index>
    1fd0:	8f 5f       	subi	r24, 0xFF	; 255
    1fd2:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <stack_index>
    1fd6:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <stack_ch>
    1fda:	81 11       	cpse	r24, r1
    1fdc:	05 c0       	rjmp	.+10     	; 0x1fe8 <_Z5Stackv+0xde>
    1fde:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <stack_colorIndex>
    1fe2:	87 e3       	ldi	r24, 0x37	; 55
    1fe4:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <stack_ch>
    1fe8:	0f 90       	pop	r0
    1fea:	0f 90       	pop	r0
    1fec:	0f 90       	pop	r0
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	0f 91       	pop	r16
    1ff4:	08 95       	ret

00001ff6 <_Z5rgORbv>:
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
    1ffc:	c2 ed       	ldi	r28, 0xD2	; 210
    1ffe:	d2 e0       	ldi	r29, 0x02	; 2
    2000:	1f ef       	ldi	r17, 0xFF	; 255
    2002:	23 e0       	ldi	r18, 0x03	; 3
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	40 e0       	ldi	r20, 0x00	; 0
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	60 e0       	ldi	r22, 0x00	; 0
    200c:	70 e0       	ldi	r23, 0x00	; 0
    200e:	cb 01       	movw	r24, r22
    2010:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <_Z6randomll>
    2014:	61 30       	cpi	r22, 0x01	; 1
    2016:	19 f4       	brne	.+6      	; 0x201e <_Z5rgORbv+0x28>
    2018:	18 83       	st	Y, r17
    201a:	19 82       	std	Y+1, r1	; 0x01
    201c:	04 c0       	rjmp	.+8      	; 0x2026 <_Z5rgORbv+0x30>
    201e:	18 82       	st	Y, r1
    2020:	62 30       	cpi	r22, 0x02	; 2
    2022:	19 f4       	brne	.+6      	; 0x202a <_Z5rgORbv+0x34>
    2024:	19 83       	std	Y+1, r17	; 0x01
    2026:	1a 82       	std	Y+2, r1	; 0x02
    2028:	02 c0       	rjmp	.+4      	; 0x202e <_Z5rgORbv+0x38>
    202a:	19 82       	std	Y+1, r1	; 0x01
    202c:	1a 83       	std	Y+2, r17	; 0x02
    202e:	8e e4       	ldi	r24, 0x4E	; 78
    2030:	94 e0       	ldi	r25, 0x04	; 4
    2032:	0e 94 84 09 	call	0x1308	; 0x1308 <_ZN8CFastLED4showEv>
    2036:	23 96       	adiw	r28, 0x03	; 3
    2038:	83 e0       	ldi	r24, 0x03	; 3
    203a:	c7 37       	cpi	r28, 0x77	; 119
    203c:	d8 07       	cpc	r29, r24
    203e:	09 f7       	brne	.-62     	; 0x2002 <_Z5rgORbv+0xc>
    2040:	df 91       	pop	r29
    2042:	cf 91       	pop	r28
    2044:	1f 91       	pop	r17
    2046:	08 95       	ret

00002048 <_Z5Cometv>:
    2048:	ff 92       	push	r15
    204a:	0f 93       	push	r16
    204c:	1f 93       	push	r17
    204e:	cf 93       	push	r28
    2050:	df 93       	push	r29
    2052:	00 d0       	rcall	.+0      	; 0x2054 <_Z5Cometv+0xc>
    2054:	1f 92       	push	r1
    2056:	cd b7       	in	r28, 0x3d	; 61
    2058:	de b7       	in	r29, 0x3e	; 62
    205a:	02 ed       	ldi	r16, 0xD2	; 210
    205c:	12 e0       	ldi	r17, 0x02	; 2
    205e:	ff 24       	eor	r15, r15
    2060:	fa 94       	dec	r15
    2062:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <__data_end>
    2066:	91 e0       	ldi	r25, 0x01	; 1
    2068:	98 0f       	add	r25, r24
    206a:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <__data_end>
    206e:	89 83       	std	Y+1, r24	; 0x01
    2070:	fa 82       	std	Y+2, r15	; 0x02
    2072:	fb 82       	std	Y+3, r15	; 0x03
    2074:	b8 01       	movw	r22, r16
    2076:	ce 01       	movw	r24, r28
    2078:	01 96       	adiw	r24, 0x01	; 1
    207a:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    207e:	8e e4       	ldi	r24, 0x4E	; 78
    2080:	94 e0       	ldi	r25, 0x04	; 4
    2082:	0e 94 84 09 	call	0x1308	; 0x1308 <_ZN8CFastLED4showEv>
    2086:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <_Z7fadeallv>
    208a:	6a e0       	ldi	r22, 0x0A	; 10
    208c:	70 e0       	ldi	r23, 0x00	; 0
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	0e 94 0a 24 	call	0x4814	; 0x4814 <delay>
    2096:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <exitloop>
    209a:	88 23       	and	r24, r24
    209c:	19 f0       	breq	.+6      	; 0x20a4 <_Z5Cometv+0x5c>
    209e:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <exitloop>
    20a2:	30 c0       	rjmp	.+96     	; 0x2104 <_Z5Cometv+0xbc>
    20a4:	0d 5f       	subi	r16, 0xFD	; 253
    20a6:	1f 4f       	sbci	r17, 0xFF	; 255
    20a8:	83 e0       	ldi	r24, 0x03	; 3
    20aa:	07 37       	cpi	r16, 0x77	; 119
    20ac:	18 07       	cpc	r17, r24
    20ae:	c9 f6       	brne	.-78     	; 0x2062 <_Z5Cometv+0x1a>
    20b0:	00 e0       	ldi	r16, 0x00	; 0
    20b2:	10 e0       	ldi	r17, 0x00	; 0
    20b4:	ff 24       	eor	r15, r15
    20b6:	fa 94       	dec	r15
    20b8:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <__data_end>
    20bc:	91 e0       	ldi	r25, 0x01	; 1
    20be:	98 0f       	add	r25, r24
    20c0:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <__data_end>
    20c4:	89 83       	std	Y+1, r24	; 0x01
    20c6:	fa 82       	std	Y+2, r15	; 0x02
    20c8:	fb 82       	std	Y+3, r15	; 0x03
    20ca:	b8 01       	movw	r22, r16
    20cc:	6c 58       	subi	r22, 0x8C	; 140
    20ce:	7c 4f       	sbci	r23, 0xFC	; 252
    20d0:	ce 01       	movw	r24, r28
    20d2:	01 96       	adiw	r24, 0x01	; 1
    20d4:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    20d8:	8e e4       	ldi	r24, 0x4E	; 78
    20da:	94 e0       	ldi	r25, 0x04	; 4
    20dc:	0e 94 84 09 	call	0x1308	; 0x1308 <_ZN8CFastLED4showEv>
    20e0:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <_Z7fadeallv>
    20e4:	6a e0       	ldi	r22, 0x0A	; 10
    20e6:	70 e0       	ldi	r23, 0x00	; 0
    20e8:	80 e0       	ldi	r24, 0x00	; 0
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	0e 94 0a 24 	call	0x4814	; 0x4814 <delay>
    20f0:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <exitloop>
    20f4:	81 11       	cpse	r24, r1
    20f6:	d3 cf       	rjmp	.-90     	; 0x209e <_Z5Cometv+0x56>
    20f8:	03 50       	subi	r16, 0x03	; 3
    20fa:	11 09       	sbc	r17, r1
    20fc:	0b 35       	cpi	r16, 0x5B	; 91
    20fe:	8f ef       	ldi	r24, 0xFF	; 255
    2100:	18 07       	cpc	r17, r24
    2102:	d1 f6       	brne	.-76     	; 0x20b8 <_Z5Cometv+0x70>
    2104:	0f 90       	pop	r0
    2106:	0f 90       	pop	r0
    2108:	0f 90       	pop	r0
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	1f 91       	pop	r17
    2110:	0f 91       	pop	r16
    2112:	ff 90       	pop	r15
    2114:	08 95       	ret

00002116 <_Z4Fadev>:
    2116:	0f 93       	push	r16
    2118:	1f 93       	push	r17
    211a:	cf 93       	push	r28
    211c:	df 93       	push	r29
    211e:	00 d0       	rcall	.+0      	; 0x2120 <_Z4Fadev+0xa>
    2120:	1f 92       	push	r1
    2122:	cd b7       	in	r28, 0x3d	; 61
    2124:	de b7       	in	r29, 0x3e	; 62
    2126:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <gHue>
    212a:	89 83       	std	Y+1, r24	; 0x01
    212c:	8f ef       	ldi	r24, 0xFF	; 255
    212e:	8b 83       	std	Y+3, r24	; 0x03
    2130:	80 ef       	ldi	r24, 0xF0	; 240
    2132:	8a 83       	std	Y+2, r24	; 0x02
    2134:	02 ed       	ldi	r16, 0xD2	; 210
    2136:	12 e0       	ldi	r17, 0x02	; 2
    2138:	b8 01       	movw	r22, r16
    213a:	ce 01       	movw	r24, r28
    213c:	01 96       	adiw	r24, 0x01	; 1
    213e:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    2142:	0d 5f       	subi	r16, 0xFD	; 253
    2144:	1f 4f       	sbci	r17, 0xFF	; 255
    2146:	83 e0       	ldi	r24, 0x03	; 3
    2148:	07 37       	cpi	r16, 0x77	; 119
    214a:	18 07       	cpc	r17, r24
    214c:	a9 f7       	brne	.-22     	; 0x2138 <_Z4Fadev+0x22>
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	0f 90       	pop	r0
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	08 95       	ret

0000215e <loop>:
    215e:	cf 92       	push	r12
    2160:	df 92       	push	r13
    2162:	ef 92       	push	r14
    2164:	ff 92       	push	r15
    2166:	0f 93       	push	r16
    2168:	1f 93       	push	r17
    216a:	cf 93       	push	r28
    216c:	df 93       	push	r29
    216e:	cd b7       	in	r28, 0x3d	; 61
    2170:	de b7       	in	r29, 0x3e	; 62
    2172:	29 97       	sbiw	r28, 0x09	; 9
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	f8 94       	cli
    2178:	de bf       	out	0x3e, r29	; 62
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	cd bf       	out	0x3d, r28	; 61
    217e:	9e 01       	movw	r18, r28
    2180:	2c 5f       	subi	r18, 0xFC	; 252
    2182:	3f 4f       	sbci	r19, 0xFF	; 255
    2184:	ae 01       	movw	r20, r28
    2186:	4a 5f       	subi	r20, 0xFA	; 250
    2188:	5f 4f       	sbci	r21, 0xFF	; 255
    218a:	be 01       	movw	r22, r28
    218c:	68 5f       	subi	r22, 0xF8	; 248
    218e:	7f 4f       	sbci	r23, 0xFF	; 255
    2190:	8b e7       	ldi	r24, 0x7B	; 123
    2192:	93 e0       	ldi	r25, 0x03	; 3
    2194:	0e 94 a2 04 	call	0x944	; 0x944 <_ZN7ADXL3457readXYZEPiS0_S0_>
    2198:	88 85       	ldd	r24, Y+8	; 0x08
    219a:	99 85       	ldd	r25, Y+9	; 0x09
    219c:	8a 36       	cpi	r24, 0x6A	; 106
    219e:	2f ef       	ldi	r18, 0xFF	; 255
    21a0:	92 07       	cpc	r25, r18
    21a2:	14 f5       	brge	.+68     	; 0x21e8 <loop+0x8a>
    21a4:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <rotated>
    21a8:	81 11       	cpse	r24, r1
    21aa:	46 c0       	rjmp	.+140    	; 0x2238 <loop+0xda>
    21ac:	00 91 9d 02 	lds	r16, 0x029D	; 0x80029d <animnu>
    21b0:	10 91 9e 02 	lds	r17, 0x029E	; 0x80029e <animnu+0x1>
    21b4:	78 01       	movw	r14, r16
    21b6:	84 e0       	ldi	r24, 0x04	; 4
    21b8:	e8 0e       	add	r14, r24
    21ba:	f1 1c       	adc	r15, r1
    21bc:	60 ea       	ldi	r22, 0xA0	; 160
    21be:	c7 01       	movw	r24, r14
    21c0:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN4OLED11sendCommandEh>
    21c4:	60 ec       	ldi	r22, 0xC0	; 192
    21c6:	c7 01       	movw	r24, r14
    21c8:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN4OLED11sendCommandEh>
    21cc:	d8 01       	movw	r26, r16
    21ce:	ed 91       	ld	r30, X+
    21d0:	fc 91       	ld	r31, X
    21d2:	01 90       	ld	r0, Z+
    21d4:	f0 81       	ld	r31, Z
    21d6:	e0 2d       	mov	r30, r0
    21d8:	c8 01       	movw	r24, r16
    21da:	09 95       	icall
    21dc:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <gReverseDirection>
    21e0:	81 e0       	ldi	r24, 0x01	; 1
    21e2:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <rotated>
    21e6:	28 c0       	rjmp	.+80     	; 0x2238 <loop+0xda>
    21e8:	87 39       	cpi	r24, 0x97	; 151
    21ea:	91 05       	cpc	r25, r1
    21ec:	2c f1       	brlt	.+74     	; 0x2238 <loop+0xda>
    21ee:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <rotated>
    21f2:	88 23       	and	r24, r24
    21f4:	09 f1       	breq	.+66     	; 0x2238 <loop+0xda>
    21f6:	00 91 9d 02 	lds	r16, 0x029D	; 0x80029d <animnu>
    21fa:	10 91 9e 02 	lds	r17, 0x029E	; 0x80029e <animnu+0x1>
    21fe:	78 01       	movw	r14, r16
    2200:	b4 e0       	ldi	r27, 0x04	; 4
    2202:	eb 0e       	add	r14, r27
    2204:	f1 1c       	adc	r15, r1
    2206:	61 ea       	ldi	r22, 0xA1	; 161
    2208:	c7 01       	movw	r24, r14
    220a:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN4OLED11sendCommandEh>
    220e:	60 eb       	ldi	r22, 0xB0	; 176
    2210:	c7 01       	movw	r24, r14
    2212:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN4OLED11sendCommandEh>
    2216:	68 ec       	ldi	r22, 0xC8	; 200
    2218:	c7 01       	movw	r24, r14
    221a:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN4OLED11sendCommandEh>
    221e:	d8 01       	movw	r26, r16
    2220:	ed 91       	ld	r30, X+
    2222:	fc 91       	ld	r31, X
    2224:	01 90       	ld	r0, Z+
    2226:	f0 81       	ld	r31, Z
    2228:	e0 2d       	mov	r30, r0
    222a:	c8 01       	movw	r24, r16
    222c:	09 95       	icall
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <gReverseDirection>
    2234:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <rotated>
    2238:	80 91 99 02 	lds	r24, 0x0299	; 0x800299 <sleepScreen>
    223c:	88 23       	and	r24, r24
    223e:	21 f1       	breq	.+72     	; 0x2288 <loop+0x12a>
    2240:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    2244:	00 91 0c 01 	lds	r16, 0x010C	; 0x80010c <sleepTime>
    2248:	10 91 0d 01 	lds	r17, 0x010D	; 0x80010d <sleepTime+0x1>
    224c:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <sleepTime+0x2>
    2250:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <sleepTime+0x3>
    2254:	ab 01       	movw	r20, r22
    2256:	bc 01       	movw	r22, r24
    2258:	40 1b       	sub	r20, r16
    225a:	51 0b       	sbc	r21, r17
    225c:	62 0b       	sbc	r22, r18
    225e:	73 0b       	sbc	r23, r19
    2260:	80 91 97 02 	lds	r24, 0x0297	; 0x800297 <sleepInt>
    2264:	90 91 98 02 	lds	r25, 0x0298	; 0x800298 <sleepInt+0x1>
    2268:	a0 e0       	ldi	r26, 0x00	; 0
    226a:	b0 e0       	ldi	r27, 0x00	; 0
    226c:	84 17       	cp	r24, r20
    226e:	95 07       	cpc	r25, r21
    2270:	a6 07       	cpc	r26, r22
    2272:	b7 07       	cpc	r27, r23
    2274:	48 f4       	brcc	.+18     	; 0x2288 <loop+0x12a>
    2276:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    227a:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    227e:	04 96       	adiw	r24, 0x04	; 4
    2280:	0e 94 8c 06 	call	0xd18	; 0xd18 <_ZN4OLED5clearEv>
    2284:	10 92 99 02 	sts	0x0299, r1	; 0x800299 <sleepScreen>
    2288:	e0 91 9d 02 	lds	r30, 0x029D	; 0x80029d <animnu>
    228c:	f0 91 9e 02 	lds	r31, 0x029E	; 0x80029e <animnu+0x1>
    2290:	93 81       	ldd	r25, Z+3	; 0x03
    2292:	85 a9       	ldd	r24, Z+53	; 0x35
    2294:	98 17       	cp	r25, r24
    2296:	19 f0       	breq	.+6      	; 0x229e <loop+0x140>
    2298:	83 e0       	ldi	r24, 0x03	; 3
    229a:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <interr>
    229e:	8f e8       	ldi	r24, 0x8F	; 143
    22a0:	93 e0       	ldi	r25, 0x03	; 3
    22a2:	0e 94 31 17 	call	0x2e62	; 0x2e62 <_ZN13AltSoftSerial9availableEv>
    22a6:	89 2b       	or	r24, r25
    22a8:	09 f4       	brne	.+2      	; 0x22ac <loop+0x14e>
    22aa:	02 c1       	rjmp	.+516    	; 0x24b0 <loop+0x352>
    22ac:	8f e8       	ldi	r24, 0x8F	; 143
    22ae:	93 e0       	ldi	r25, 0x03	; 3
    22b0:	0e 94 08 17 	call	0x2e10	; 0x2e10 <_ZN13AltSoftSerial4readEv>
    22b4:	7c 01       	movw	r14, r24
    22b6:	8f e8       	ldi	r24, 0x8F	; 143
    22b8:	93 e0       	ldi	r25, 0x03	; 3
    22ba:	0e 94 08 17 	call	0x2e10	; 0x2e10 <_ZN13AltSoftSerial4readEv>
    22be:	8c 01       	movw	r16, r24
    22c0:	8f e8       	ldi	r24, 0x8F	; 143
    22c2:	93 e0       	ldi	r25, 0x03	; 3
    22c4:	0e 94 08 17 	call	0x2e10	; 0x2e10 <_ZN13AltSoftSerial4readEv>
    22c8:	d8 2e       	mov	r13, r24
    22ca:	8f e8       	ldi	r24, 0x8F	; 143
    22cc:	93 e0       	ldi	r25, 0x03	; 3
    22ce:	0e 94 08 17 	call	0x2e10	; 0x2e10 <_ZN13AltSoftSerial4readEv>
    22d2:	f7 01       	movw	r30, r14
    22d4:	ff 27       	eor	r31, r31
    22d6:	31 97       	sbiw	r30, 0x01	; 1
    22d8:	e9 30       	cpi	r30, 0x09	; 9
    22da:	f1 05       	cpc	r31, r1
    22dc:	08 f0       	brcs	.+2      	; 0x22e0 <loop+0x182>
    22de:	91 c0       	rjmp	.+290    	; 0x2402 <loop+0x2a4>
    22e0:	e8 5c       	subi	r30, 0xC8	; 200
    22e2:	ff 4f       	sbci	r31, 0xFF	; 255
    22e4:	0c 94 af 27 	jmp	0x4f5e	; 0x4f5e <__tablejump2__>
    22e8:	00 93 1c 01 	sts	0x011C, r16	; 0x80011c <animation>
    22ec:	0e 94 34 0b 	call	0x1668	; 0x1668 <_Z8Darknessv>
    22f0:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
    22f4:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
    22f8:	8d 5d       	subi	r24, 0xDD	; 221
    22fa:	94 40       	sbci	r25, 0x04	; 4
    22fc:	09 f0       	breq	.+2      	; 0x2300 <loop+0x1a2>
    22fe:	81 c0       	rjmp	.+258    	; 0x2402 <loop+0x2a4>
    2300:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    2304:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    2308:	20 91 1c 01 	lds	r18, 0x011C	; 0x80011c <animation>
    230c:	fc 01       	movw	r30, r24
    230e:	25 ab       	std	Z+53, r18	; 0x35
    2310:	01 90       	ld	r0, Z+
    2312:	f0 81       	ld	r31, Z
    2314:	e0 2d       	mov	r30, r0
    2316:	13 c0       	rjmp	.+38     	; 0x233e <loop+0x1e0>
    2318:	00 93 1b 01 	sts	0x011B, r16	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    231c:	00 93 4e 04 	sts	0x044E, r16	; 0x80044e <FastLED>
    2320:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
    2324:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
    2328:	87 5d       	subi	r24, 0xD7	; 215
    232a:	94 40       	sbci	r25, 0x04	; 4
    232c:	09 f0       	breq	.+2      	; 0x2330 <loop+0x1d2>
    232e:	69 c0       	rjmp	.+210    	; 0x2402 <loop+0x2a4>
    2330:	80 91 9b 02 	lds	r24, 0x029B	; 0x80029b <brtnsmnu>
    2334:	90 91 9c 02 	lds	r25, 0x029C	; 0x80029c <brtnsmnu+0x1>
    2338:	dc 01       	movw	r26, r24
    233a:	ed 91       	ld	r30, X+
    233c:	fc 91       	ld	r31, X
    233e:	01 90       	ld	r0, Z+
    2340:	f0 81       	ld	r31, Z
    2342:	e0 2d       	mov	r30, r0
    2344:	09 95       	icall
    2346:	5d c0       	rjmp	.+186    	; 0x2402 <loop+0x2a4>
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	08 13       	cpse	r16, r24
    234c:	80 e0       	ldi	r24, 0x00	; 0
    234e:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <gReverseDirection>
    2352:	57 c0       	rjmp	.+174    	; 0x2402 <loop+0x2a4>
    2354:	11 27       	eor	r17, r17
    2356:	02 30       	cpi	r16, 0x02	; 2
    2358:	11 05       	cpc	r17, r1
    235a:	51 f0       	breq	.+20     	; 0x2370 <loop+0x212>
    235c:	03 30       	cpi	r16, 0x03	; 3
    235e:	11 05       	cpc	r17, r1
    2360:	51 f0       	breq	.+20     	; 0x2376 <loop+0x218>
    2362:	01 30       	cpi	r16, 0x01	; 1
    2364:	11 05       	cpc	r17, r1
    2366:	09 f0       	breq	.+2      	; 0x236a <loop+0x20c>
    2368:	4c c0       	rjmp	.+152    	; 0x2402 <loop+0x2a4>
    236a:	d0 92 15 01 	sts	0x0115, r13	; 0x800115 <COOLING>
    236e:	49 c0       	rjmp	.+146    	; 0x2402 <loop+0x2a4>
    2370:	d0 92 16 01 	sts	0x0116, r13	; 0x800116 <SPARKING>
    2374:	46 c0       	rjmp	.+140    	; 0x2402 <loop+0x2a4>
    2376:	d1 10       	cpse	r13, r1
    2378:	04 c0       	rjmp	.+8      	; 0x2382 <loop+0x224>
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <cyclingTorchColor>
    2380:	40 c0       	rjmp	.+128    	; 0x2402 <loop+0x2a4>
    2382:	bf ef       	ldi	r27, 0xFF	; 255
    2384:	db 12       	cpse	r13, r27
    2386:	05 c0       	rjmp	.+10     	; 0x2392 <loop+0x234>
    2388:	10 92 9a 02 	sts	0x029A, r1	; 0x80029a <cyclingTorchColor>
    238c:	d0 92 10 01 	sts	0x0110, r13	; 0x800110 <torchHue>
    2390:	38 c0       	rjmp	.+112    	; 0x2402 <loop+0x2a4>
    2392:	d0 92 10 01 	sts	0x0110, r13	; 0x800110 <torchHue>
    2396:	10 92 9a 02 	sts	0x029A, r1	; 0x80029a <cyclingTorchColor>
    239a:	33 c0       	rjmp	.+102    	; 0x2402 <loop+0x2a4>
    239c:	00 93 12 01 	sts	0x0112, r16	; 0x800112 <cloudNumber>
    23a0:	30 c0       	rjmp	.+96     	; 0x2402 <loop+0x2a4>
    23a2:	00 93 13 01 	sts	0x0113, r16	; 0x800113 <FRAMES_PER_SECOND>
    23a6:	2d c0       	rjmp	.+90     	; 0x2402 <loop+0x2a4>
    23a8:	00 93 11 01 	sts	0x0111, r16	; 0x800111 <chanceOfGlitter>
    23ac:	2a c0       	rjmp	.+84     	; 0x2402 <loop+0x2a4>
    23ae:	01 11       	cpse	r16, r1
    23b0:	06 c0       	rjmp	.+12     	; 0x23be <loop+0x260>
    23b2:	10 92 99 02 	sts	0x0299, r1	; 0x800299 <sleepScreen>
    23b6:	82 e0       	ldi	r24, 0x02	; 2
    23b8:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <interr>
    23bc:	22 c0       	rjmp	.+68     	; 0x2402 <loop+0x2a4>
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	80 93 99 02 	sts	0x0299, r24	; 0x800299 <sleepScreen>
    23c4:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    23c8:	60 93 0c 01 	sts	0x010C, r22	; 0x80010c <sleepTime>
    23cc:	70 93 0d 01 	sts	0x010D, r23	; 0x80010d <sleepTime+0x1>
    23d0:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <sleepTime+0x2>
    23d4:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <sleepTime+0x3>
    23d8:	28 ee       	ldi	r18, 0xE8	; 232
    23da:	33 e0       	ldi	r19, 0x03	; 3
    23dc:	02 9f       	mul	r16, r18
    23de:	c0 01       	movw	r24, r0
    23e0:	03 9f       	mul	r16, r19
    23e2:	90 0d       	add	r25, r0
    23e4:	11 24       	eor	r1, r1
    23e6:	90 93 98 02 	sts	0x0298, r25	; 0x800298 <sleepInt+0x1>
    23ea:	80 93 97 02 	sts	0x0297, r24	; 0x800297 <sleepInt>
    23ee:	09 c0       	rjmp	.+18     	; 0x2402 <loop+0x2a4>
    23f0:	9a e0       	ldi	r25, 0x0A	; 10
    23f2:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <animation>
    23f6:	00 93 8d 02 	sts	0x028D, r16	; 0x80028d <red_color>
    23fa:	d0 92 8c 02 	sts	0x028C, r13	; 0x80028c <green_color>
    23fe:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <blue_color>
    2402:	66 e0       	ldi	r22, 0x06	; 6
    2404:	72 e0       	ldi	r23, 0x02	; 2
    2406:	8e e8       	ldi	r24, 0x8E	; 142
    2408:	92 e0       	ldi	r25, 0x02	; 2
    240a:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <_ZN6StringaSEPKc>
    240e:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <animation>
    2412:	84 31       	cpi	r24, 0x14	; 20
    2414:	09 f4       	brne	.+2      	; 0x2418 <loop+0x2ba>
    2416:	c0 c0       	rjmp	.+384    	; 0x2598 <loop+0x43a>
    2418:	e0 91 9d 02 	lds	r30, 0x029D	; 0x80029d <animnu>
    241c:	f0 91 9e 02 	lds	r31, 0x029E	; 0x80029e <animnu+0x1>
    2420:	63 81       	ldd	r22, Z+3	; 0x03
    2422:	70 e0       	ldi	r23, 0x00	; 0
    2424:	7b 01       	movw	r14, r22
    2426:	e8 1a       	sub	r14, r24
    2428:	f1 08       	sbc	r15, r1
    242a:	4a e0       	ldi	r20, 0x0A	; 10
    242c:	50 e0       	ldi	r21, 0x00	; 0
    242e:	b7 01       	movw	r22, r14
    2430:	8b e1       	ldi	r24, 0x1B	; 27
    2432:	95 e0       	ldi	r25, 0x05	; 5
    2434:	0e 94 7d 23 	call	0x46fa	; 0x46fa <_ZN5Print7printlnEii>
    2438:	e0 91 9d 02 	lds	r30, 0x029D	; 0x80029d <animnu>
    243c:	f0 91 9e 02 	lds	r31, 0x029E	; 0x80029e <animnu+0x1>
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	84 ab       	std	Z+52, r24	; 0x34
    2444:	f7 fe       	sbrs	r15, 7
    2446:	1d c0       	rjmp	.+58     	; 0x2482 <loop+0x324>
    2448:	00 e0       	ldi	r16, 0x00	; 0
    244a:	10 e0       	ldi	r17, 0x00	; 0
    244c:	f1 94       	neg	r15
    244e:	e1 94       	neg	r14
    2450:	f1 08       	sbc	r15, r1
    2452:	0e 15       	cp	r16, r14
    2454:	1f 05       	cpc	r17, r15
    2456:	34 f0       	brlt	.+12     	; 0x2464 <loop+0x306>
    2458:	e0 91 9d 02 	lds	r30, 0x029D	; 0x80029d <animnu>
    245c:	f0 91 9e 02 	lds	r31, 0x029E	; 0x80029e <animnu+0x1>
    2460:	14 aa       	std	Z+52, r1	; 0x34
    2462:	9a c0       	rjmp	.+308    	; 0x2598 <loop+0x43a>
    2464:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    2468:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    246c:	dc 01       	movw	r26, r24
    246e:	ed 91       	ld	r30, X+
    2470:	fc 91       	ld	r31, X
    2472:	02 80       	ldd	r0, Z+2	; 0x02
    2474:	f3 81       	ldd	r31, Z+3	; 0x03
    2476:	e0 2d       	mov	r30, r0
    2478:	61 e0       	ldi	r22, 0x01	; 1
    247a:	09 95       	icall
    247c:	0f 5f       	subi	r16, 0xFF	; 255
    247e:	1f 4f       	sbci	r17, 0xFF	; 255
    2480:	e8 cf       	rjmp	.-48     	; 0x2452 <loop+0x2f4>
    2482:	e1 14       	cp	r14, r1
    2484:	f1 04       	cpc	r15, r1
    2486:	41 f3       	breq	.-48     	; 0x2458 <loop+0x2fa>
    2488:	00 e0       	ldi	r16, 0x00	; 0
    248a:	10 e0       	ldi	r17, 0x00	; 0
    248c:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    2490:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    2494:	dc 01       	movw	r26, r24
    2496:	ed 91       	ld	r30, X+
    2498:	fc 91       	ld	r31, X
    249a:	02 80       	ldd	r0, Z+2	; 0x02
    249c:	f3 81       	ldd	r31, Z+3	; 0x03
    249e:	e0 2d       	mov	r30, r0
    24a0:	62 e0       	ldi	r22, 0x02	; 2
    24a2:	09 95       	icall
    24a4:	0f 5f       	subi	r16, 0xFF	; 255
    24a6:	1f 4f       	sbci	r17, 0xFF	; 255
    24a8:	0e 15       	cp	r16, r14
    24aa:	1f 05       	cpc	r17, r15
    24ac:	7c f3       	brlt	.-34     	; 0x248c <loop+0x32e>
    24ae:	d4 cf       	rjmp	.-88     	; 0x2458 <loop+0x2fa>
    24b0:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <interr>
    24b4:	88 23       	and	r24, r24
    24b6:	09 f4       	brne	.+2      	; 0x24ba <loop+0x35c>
    24b8:	6f c0       	rjmp	.+222    	; 0x2598 <loop+0x43a>
    24ba:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
    24be:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
    24c2:	2d 5d       	subi	r18, 0xDD	; 221
    24c4:	34 40       	sbci	r19, 0x04	; 4
    24c6:	09 f0       	breq	.+2      	; 0x24ca <loop+0x36c>
    24c8:	56 c0       	rjmp	.+172    	; 0x2576 <loop+0x418>
    24ca:	82 30       	cpi	r24, 0x02	; 2
    24cc:	81 f0       	breq	.+32     	; 0x24ee <loop+0x390>
    24ce:	83 30       	cpi	r24, 0x03	; 3
    24d0:	d9 f0       	breq	.+54     	; 0x2508 <loop+0x3aa>
    24d2:	81 30       	cpi	r24, 0x01	; 1
    24d4:	39 f5       	brne	.+78     	; 0x2524 <loop+0x3c6>
    24d6:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    24da:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    24de:	dc 01       	movw	r26, r24
    24e0:	ed 91       	ld	r30, X+
    24e2:	fc 91       	ld	r31, X
    24e4:	02 80       	ldd	r0, Z+2	; 0x02
    24e6:	f3 81       	ldd	r31, Z+3	; 0x03
    24e8:	e0 2d       	mov	r30, r0
    24ea:	61 e0       	ldi	r22, 0x01	; 1
    24ec:	0b c0       	rjmp	.+22     	; 0x2504 <loop+0x3a6>
    24ee:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    24f2:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    24f6:	dc 01       	movw	r26, r24
    24f8:	ed 91       	ld	r30, X+
    24fa:	fc 91       	ld	r31, X
    24fc:	02 80       	ldd	r0, Z+2	; 0x02
    24fe:	f3 81       	ldd	r31, Z+3	; 0x03
    2500:	e0 2d       	mov	r30, r0
    2502:	62 e0       	ldi	r22, 0x02	; 2
    2504:	09 95       	icall
    2506:	0e c0       	rjmp	.+28     	; 0x2524 <loop+0x3c6>
    2508:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <animnu>
    250c:	90 91 9e 02 	lds	r25, 0x029E	; 0x80029e <animnu+0x1>
    2510:	dc 01       	movw	r26, r24
    2512:	ed 91       	ld	r30, X+
    2514:	fc 91       	ld	r31, X
    2516:	02 80       	ldd	r0, Z+2	; 0x02
    2518:	f3 81       	ldd	r31, Z+3	; 0x03
    251a:	e0 2d       	mov	r30, r0
    251c:	63 e0       	ldi	r22, 0x03	; 3
    251e:	09 95       	icall
    2520:	80 93 9f 02 	sts	0x029F, r24	; 0x80029f <selectedItem>
    2524:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    2528:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <FastLED>
    252c:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <selectedItem>
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	98 13       	cpse	r25, r24
    2534:	1d c0       	rjmp	.+58     	; 0x2570 <loop+0x412>
    2536:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <animation>
    253a:	a0 91 9d 02 	lds	r26, 0x029D	; 0x80029d <animnu>
    253e:	b0 91 9e 02 	lds	r27, 0x029E	; 0x80029e <animnu+0x1>
    2542:	13 96       	adiw	r26, 0x03	; 3
    2544:	8c 91       	ld	r24, X
    2546:	13 97       	sbiw	r26, 0x03	; 3
    2548:	d5 96       	adiw	r26, 0x35	; 53
    254a:	8c 93       	st	X, r24
    254c:	d5 97       	sbiw	r26, 0x35	; 53
    254e:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <_ZN4Menu11CurrentMenuE>
    2552:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <_ZN4Menu11CurrentMenuE+0x1>
    2556:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <_ZN4Menu11MenuWithAniE+0x1>
    255a:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <_ZN4Menu11MenuWithAniE>
    255e:	ed 91       	ld	r30, X+
    2560:	fc 91       	ld	r31, X
    2562:	11 97       	sbiw	r26, 0x01	; 1
    2564:	01 90       	ld	r0, Z+
    2566:	f0 81       	ld	r31, Z
    2568:	e0 2d       	mov	r30, r0
    256a:	cd 01       	movw	r24, r26
    256c:	09 95       	icall
    256e:	03 c0       	rjmp	.+6      	; 0x2576 <loop+0x418>
    2570:	8f 5f       	subi	r24, 0xFF	; 255
    2572:	84 31       	cpi	r24, 0x14	; 20
    2574:	f1 f6       	brne	.-68     	; 0x2532 <loop+0x3d4>
    2576:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <interr>
    257a:	83 30       	cpi	r24, 0x03	; 3
    257c:	49 f4       	brne	.+18     	; 0x2590 <loop+0x432>
    257e:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <stack_colorIndex>
    2582:	87 e3       	ldi	r24, 0x37	; 55
    2584:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <stack_ch>
    2588:	10 92 95 02 	sts	0x0295, r1	; 0x800295 <stack_index>
    258c:	0e 94 34 0b 	call	0x1668	; 0x1668 <_Z8Darknessv>
    2590:	10 92 77 03 	sts	0x0377, r1	; 0x800377 <interr>
    2594:	10 92 9f 02 	sts	0x029F, r1	; 0x80029f <selectedItem>
    2598:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <_ZN4Menu10BRIGHTNESSE>
    259c:	81 11       	cpse	r24, r1
    259e:	02 c0       	rjmp	.+4      	; 0x25a4 <loop+0x446>
    25a0:	60 e0       	ldi	r22, 0x00	; 0
    25a2:	01 c0       	rjmp	.+2      	; 0x25a6 <loop+0x448>
    25a4:	61 e0       	ldi	r22, 0x01	; 1
    25a6:	87 e1       	ldi	r24, 0x17	; 23
    25a8:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
    25ac:	e0 91 1c 01 	lds	r30, 0x011C	; 0x80011c <animation>
    25b0:	8e 2f       	mov	r24, r30
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	fc 01       	movw	r30, r24
    25b6:	31 97       	sbiw	r30, 0x01	; 1
    25b8:	e4 31       	cpi	r30, 0x14	; 20
    25ba:	f1 05       	cpc	r31, r1
    25bc:	20 f4       	brcc	.+8      	; 0x25c6 <loop+0x468>
    25be:	ef 5b       	subi	r30, 0xBF	; 191
    25c0:	ff 4f       	sbci	r31, 0xFF	; 255
    25c2:	0c 94 af 27 	jmp	0x4f5e	; 0x4f5e <__tablejump2__>
    25c6:	0e 94 34 0b 	call	0x1668	; 0x1668 <_Z8Darknessv>
    25ca:	60 e0       	ldi	r22, 0x00	; 0
    25cc:	87 e1       	ldi	r24, 0x17	; 23
    25ce:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
    25d2:	56 c0       	rjmp	.+172    	; 0x2680 <loop+0x522>
    25d4:	0e 94 3f 0b 	call	0x167e	; 0x167e <_Z4Firev>
    25d8:	53 c0       	rjmp	.+166    	; 0x2680 <loop+0x522>
    25da:	0e 94 7b 0c 	call	0x18f6	; 0x18f6 <_Z7Lanternv>
    25de:	50 c0       	rjmp	.+160    	; 0x2680 <loop+0x522>
    25e0:	0e 94 8b 10 	call	0x2116	; 0x2116 <_Z4Fadev>
    25e4:	42 e3       	ldi	r20, 0x32	; 50
    25e6:	50 e0       	ldi	r21, 0x00	; 0
    25e8:	60 e0       	ldi	r22, 0x00	; 0
    25ea:	70 e0       	ldi	r23, 0x00	; 0
    25ec:	8e e4       	ldi	r24, 0x4E	; 78
    25ee:	94 e0       	ldi	r25, 0x04	; 4
    25f0:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <_ZN8CFastLED5delayEm>
    25f4:	45 c0       	rjmp	.+138    	; 0x2680 <loop+0x522>
    25f6:	0e 94 24 10 	call	0x2048	; 0x2048 <_Z5Cometv>
    25fa:	42 c0       	rjmp	.+132    	; 0x2680 <loop+0x522>
    25fc:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <_Z14RainbowGlitterv>
    2600:	3f c0       	rjmp	.+126    	; 0x2680 <loop+0x522>
    2602:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <_Z5rgORbv>
    2606:	3c c0       	rjmp	.+120    	; 0x2680 <loop+0x522>
    2608:	80 e0       	ldi	r24, 0x00	; 0
    260a:	01 c0       	rjmp	.+2      	; 0x260e <loop+0x4b0>
    260c:	81 e0       	ldi	r24, 0x01	; 1
    260e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <_Z8FunStuffh>
    2612:	36 c0       	rjmp	.+108    	; 0x2680 <loop+0x522>
    2614:	82 e0       	ldi	r24, 0x02	; 2
    2616:	fb cf       	rjmp	.-10     	; 0x260e <loop+0x4b0>
    2618:	83 e0       	ldi	r24, 0x03	; 3
    261a:	f9 cf       	rjmp	.-14     	; 0x260e <loop+0x4b0>
    261c:	84 e0       	ldi	r24, 0x04	; 4
    261e:	f7 cf       	rjmp	.-18     	; 0x260e <loop+0x4b0>
    2620:	85 e0       	ldi	r24, 0x05	; 5
    2622:	f5 cf       	rjmp	.-22     	; 0x260e <loop+0x4b0>
    2624:	86 e0       	ldi	r24, 0x06	; 6
    2626:	f3 cf       	rjmp	.-26     	; 0x260e <loop+0x4b0>
    2628:	87 e0       	ldi	r24, 0x07	; 7
    262a:	f1 cf       	rjmp	.-30     	; 0x260e <loop+0x4b0>
    262c:	0e 94 94 0c 	call	0x1928	; 0x1928 <_Z4Pongv>
    2630:	27 c0       	rjmp	.+78     	; 0x2680 <loop+0x522>
    2632:	0e 94 cd 0e 	call	0x1d9a	; 0x1d9a <_Z6Cloudsv>
    2636:	24 c0       	rjmp	.+72     	; 0x2680 <loop+0x522>
    2638:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <_Z9WaveRacerv>
    263c:	21 c0       	rjmp	.+66     	; 0x2680 <loop+0x522>
    263e:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <_Z7Flickerv>
    2642:	1e c0       	rjmp	.+60     	; 0x2680 <loop+0x522>
    2644:	6b ea       	ldi	r22, 0xAB	; 171
    2646:	76 e0       	ldi	r23, 0x06	; 6
    2648:	82 ea       	ldi	r24, 0xA2	; 162
    264a:	92 e0       	ldi	r25, 0x02	; 2
    264c:	0e 94 67 09 	call	0x12ce	; 0x12ce <_ZN13CRGBPalette16aSERA16_Km>
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <currentBlending>
    2656:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <_Z5Stackv>
    265a:	12 c0       	rjmp	.+36     	; 0x2680 <loop+0x522>
    265c:	80 91 8b 02 	lds	r24, 0x028B	; 0x80028b <blue_color>
    2660:	90 91 8c 02 	lds	r25, 0x028C	; 0x80028c <green_color>
    2664:	20 91 8d 02 	lds	r18, 0x028D	; 0x80028d <red_color>
    2668:	29 83       	std	Y+1, r18	; 0x01
    266a:	9a 83       	std	Y+2, r25	; 0x02
    266c:	8b 83       	std	Y+3, r24	; 0x03
    266e:	ae 01       	movw	r20, r28
    2670:	4f 5f       	subi	r20, 0xFF	; 255
    2672:	5f 4f       	sbci	r21, 0xFF	; 255
    2674:	67 e3       	ldi	r22, 0x37	; 55
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	82 ed       	ldi	r24, 0xD2	; 210
    267a:	92 e0       	ldi	r25, 0x02	; 2
    267c:	0e 94 a6 19 	call	0x334c	; 0x334c <_Z10fill_solidP4CRGBiRKS_>
    2680:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <_ZGVZ4loopE4PER0>
    2684:	81 11       	cpse	r24, r1
    2686:	19 c0       	rjmp	.+50     	; 0x26ba <loop+0x55c>
    2688:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    268c:	60 93 61 02 	sts	0x0261, r22	; 0x800261 <_ZZ4loopE4PER0>
    2690:	70 93 62 02 	sts	0x0262, r23	; 0x800262 <_ZZ4loopE4PER0+0x1>
    2694:	80 93 63 02 	sts	0x0263, r24	; 0x800263 <_ZZ4loopE4PER0+0x2>
    2698:	90 93 64 02 	sts	0x0264, r25	; 0x800264 <_ZZ4loopE4PER0+0x3>
    269c:	84 e1       	ldi	r24, 0x14	; 20
    269e:	90 e0       	ldi	r25, 0x00	; 0
    26a0:	a0 e0       	ldi	r26, 0x00	; 0
    26a2:	b0 e0       	ldi	r27, 0x00	; 0
    26a4:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <_ZZ4loopE4PER0+0x4>
    26a8:	90 93 66 02 	sts	0x0266, r25	; 0x800266 <_ZZ4loopE4PER0+0x5>
    26ac:	a0 93 67 02 	sts	0x0267, r26	; 0x800267 <_ZZ4loopE4PER0+0x6>
    26b0:	b0 93 68 02 	sts	0x0268, r27	; 0x800268 <_ZZ4loopE4PER0+0x7>
    26b4:	81 e0       	ldi	r24, 0x01	; 1
    26b6:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <_ZGVZ4loopE4PER0>
    26ba:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    26be:	00 91 61 02 	lds	r16, 0x0261	; 0x800261 <_ZZ4loopE4PER0>
    26c2:	10 91 62 02 	lds	r17, 0x0262	; 0x800262 <_ZZ4loopE4PER0+0x1>
    26c6:	20 91 63 02 	lds	r18, 0x0263	; 0x800263 <_ZZ4loopE4PER0+0x2>
    26ca:	30 91 64 02 	lds	r19, 0x0264	; 0x800264 <_ZZ4loopE4PER0+0x3>
    26ce:	dc 01       	movw	r26, r24
    26d0:	cb 01       	movw	r24, r22
    26d2:	80 1b       	sub	r24, r16
    26d4:	91 0b       	sbc	r25, r17
    26d6:	a2 0b       	sbc	r26, r18
    26d8:	b3 0b       	sbc	r27, r19
    26da:	00 91 65 02 	lds	r16, 0x0265	; 0x800265 <_ZZ4loopE4PER0+0x4>
    26de:	10 91 66 02 	lds	r17, 0x0266	; 0x800266 <_ZZ4loopE4PER0+0x5>
    26e2:	20 91 67 02 	lds	r18, 0x0267	; 0x800267 <_ZZ4loopE4PER0+0x6>
    26e6:	30 91 68 02 	lds	r19, 0x0268	; 0x800268 <_ZZ4loopE4PER0+0x7>
    26ea:	80 17       	cp	r24, r16
    26ec:	91 07       	cpc	r25, r17
    26ee:	a2 07       	cpc	r26, r18
    26f0:	b3 07       	cpc	r27, r19
    26f2:	78 f0       	brcs	.+30     	; 0x2712 <loop+0x5b4>
    26f4:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    26f8:	60 93 61 02 	sts	0x0261, r22	; 0x800261 <_ZZ4loopE4PER0>
    26fc:	70 93 62 02 	sts	0x0262, r23	; 0x800262 <_ZZ4loopE4PER0+0x1>
    2700:	80 93 63 02 	sts	0x0263, r24	; 0x800263 <_ZZ4loopE4PER0+0x2>
    2704:	90 93 64 02 	sts	0x0264, r25	; 0x800264 <_ZZ4loopE4PER0+0x3>
    2708:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <gHue>
    270c:	8f 5f       	subi	r24, 0xFF	; 255
    270e:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <gHue>
    2712:	8e e4       	ldi	r24, 0x4E	; 78
    2714:	94 e0       	ldi	r25, 0x04	; 4
    2716:	0e 94 84 09 	call	0x1308	; 0x1308 <_ZN8CFastLED4showEv>
    271a:	60 91 13 01 	lds	r22, 0x0113	; 0x800113 <FRAMES_PER_SECOND>
    271e:	70 e0       	ldi	r23, 0x00	; 0
    2720:	88 ee       	ldi	r24, 0xE8	; 232
    2722:	93 e0       	ldi	r25, 0x03	; 3
    2724:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    2728:	ab 01       	movw	r20, r22
    272a:	77 0f       	add	r23, r23
    272c:	66 0b       	sbc	r22, r22
    272e:	77 0b       	sbc	r23, r23
    2730:	8e e4       	ldi	r24, 0x4E	; 78
    2732:	94 e0       	ldi	r25, 0x04	; 4
    2734:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <_ZN8CFastLED5delayEm>
    2738:	29 96       	adiw	r28, 0x09	; 9
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	de bf       	out	0x3e, r29	; 62
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	cd bf       	out	0x3d, r28	; 61
    2744:	df 91       	pop	r29
    2746:	cf 91       	pop	r28
    2748:	1f 91       	pop	r17
    274a:	0f 91       	pop	r16
    274c:	ff 90       	pop	r15
    274e:	ef 90       	pop	r14
    2750:	df 90       	pop	r13
    2752:	cf 90       	pop	r12
    2754:	08 95       	ret

00002756 <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_66ELi1ELm4294967295EE>:
#define DADVANCE 3
#define DUSE (0xFF - (DADVANCE-1))

	// This method is made static to force making register Y available to use for data on AVR - if the method is non-static, then
	// gcc will use register Y for the this pointer.
	static void /*__attribute__((optimize("O0")))*/  /*__attribute__ ((always_inline))*/  showRGBInternal(PixelController<RGB_ORDER> & pixels)  {
    2756:	9f 92       	push	r9
    2758:	af 92       	push	r10
    275a:	bf 92       	push	r11
    275c:	cf 92       	push	r12
    275e:	df 92       	push	r13
    2760:	ef 92       	push	r14
    2762:	ff 92       	push	r15
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
    276c:	fc 01       	movw	r30, r24
		uint8_t *data = (uint8_t*)pixels.mData;
    276e:	c0 80       	ld	r12, Z
    2770:	d1 80       	ldd	r13, Z+1	; 0x01
		data_ptr_t port = FastPin<DATA_PIN>::port();
		data_t mask = FastPin<DATA_PIN>::mask();
		uint8_t scale_base = 0;

		// register uint8_t *end = data + nLeds;
		data_t hi = *port | mask;
    2772:	22 b1       	in	r18, 0x02	; 2
    2774:	20 61       	ori	r18, 0x10	; 16
    2776:	b2 2e       	mov	r11, r18
		data_t lo = *port & ~mask;
    2778:	92 b1       	in	r25, 0x02	; 2
    277a:	9f 7e       	andi	r25, 0xEF	; 239
		*port = lo;
    277c:	92 b9       	out	0x02, r25	; 2
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
    277e:	62 85       	ldd	r22, Z+10	; 0x0a
    2780:	87 81       	ldd	r24, Z+7	; 0x07
    2782:	06 2f       	mov	r16, r22
    2784:	08 1b       	sub	r16, r24
    2786:	80 2f       	mov	r24, r16
    2788:	07 83       	std	Z+7, r16	; 0x07

		// Setup the pixel controller
		pixels.preStepFirstByteDithering();

		// pull the dithering/adjustment values out of the pixels object for direct asm access
		uint8_t advanceBy = pixels.advanceBy();
    278a:	77 85       	ldd	r23, Z+15	; 0x0f
		uint16_t count = pixels.mLen;
    278c:	a2 81       	ldd	r26, Z+2	; 0x02
    278e:	b3 81       	ldd	r27, Z+3	; 0x03

		uint8_t s0 = pixels.mScale.raw[RO(0)];
    2790:	35 85       	ldd	r19, Z+13	; 0x0d
		uint8_t s1 = pixels.mScale.raw[RO(1)];
    2792:	44 85       	ldd	r20, Z+12	; 0x0c
		uint8_t s2 = pixels.mScale.raw[RO(2)];
    2794:	56 85       	ldd	r21, Z+14	; 0x0e
#if (FASTLED_SCALE8_FIXED==1)
		s0++; s1++; s2++;
    2796:	99 24       	eor	r9, r9
    2798:	93 94       	inc	r9
    279a:	93 0e       	add	r9, r19
    279c:	4f 5f       	subi	r20, 0xFF	; 255
    279e:	5f 5f       	subi	r21, 0xFF	; 255
#endif
		uint8_t d0 = pixels.d[RO(0)];
		uint8_t d1 = pixels.d[RO(1)];
    27a0:	f6 80       	ldd	r15, Z+6	; 0x06
		uint8_t d2 = pixels.d[RO(2)];
    27a2:	e0 84       	ldd	r14, Z+8	; 0x08
		uint8_t e0 = pixels.e[RO(0)];
		uint8_t e1 = pixels.e[RO(1)];
    27a4:	c1 85       	ldd	r28, Z+9	; 0x09
		uint8_t e2 = pixels.e[RO(2)];
    27a6:	d3 85       	ldd	r29, Z+11	; 0x0b

		uint8_t loopvar=0;

		// This has to be done in asm to keep gcc from messing up the asm code further down
		b0 = data[RO(0)];
    27a8:	f6 01       	movw	r30, r12
    27aa:	11 81       	ldd	r17, Z+1	; 0x01
		{
			LDSCL4(b0,O0) 	PRESCALEA2(d0)
    27ac:	a1 2c       	mov	r10, r1
    27ae:	0a 2d       	mov	r16, r10
    27b0:	2a 2d       	mov	r18, r10
    27b2:	3a 2d       	mov	r19, r10
    27b4:	31 81       	ldd	r19, Z+1	; 0x01
    27b6:	11 27       	eor	r17, r17
    27b8:	88 94       	clc
    27ba:	31 11       	cpse	r19, r1
    27bc:	38 0f       	add	r19, r24
			PRESCALEB4(d0)	SCALE02(b0,0)
    27be:	08 f4       	brcc	.+2      	; 0x27c2 <L_4796>
    27c0:	3f ef       	ldi	r19, 0xFF	; 255

000027c2 <L_4796>:
    27c2:	81 95       	neg	r24
    27c4:	88 94       	clc
    27c6:	90 fc       	sbrc	r9, 0
    27c8:	13 0f       	add	r17, r19
			RORSC04(b0,1) 	ROR1(b0) CLC1
    27ca:	17 95       	ror	r17
    27cc:	88 94       	clc
    27ce:	91 fc       	sbrc	r9, 1
    27d0:	13 0f       	add	r17, r19
    27d2:	17 95       	ror	r17
    27d4:	88 94       	clc
			SCROR04(b0,2)		SCALE02(b0,3)
    27d6:	92 fc       	sbrc	r9, 2
    27d8:	13 0f       	add	r17, r19
    27da:	17 95       	ror	r17
    27dc:	88 94       	clc
    27de:	93 fc       	sbrc	r9, 3
    27e0:	13 0f       	add	r17, r19
			RORSC04(b0,4) 	ROR1(b0) CLC1
    27e2:	17 95       	ror	r17
    27e4:	88 94       	clc
    27e6:	94 fc       	sbrc	r9, 4
    27e8:	13 0f       	add	r17, r19
    27ea:	17 95       	ror	r17
    27ec:	88 94       	clc
			SCROR04(b0,5) 	SCALE02(b0,6)
    27ee:	95 fc       	sbrc	r9, 5
    27f0:	13 0f       	add	r17, r19
    27f2:	17 95       	ror	r17
    27f4:	88 94       	clc
    27f6:	96 fc       	sbrc	r9, 6
    27f8:	13 0f       	add	r17, r19
			RORSC04(b0,7) 	ROR1(b0) CLC1
    27fa:	17 95       	ror	r17
    27fc:	88 94       	clc
    27fe:	97 fc       	sbrc	r9, 7
    2800:	13 0f       	add	r17, r19
    2802:	17 95       	ror	r17
    2804:	88 94       	clc
			MOV_ADDDE04(b1,b0,d0,e0)
    2806:	03 2f       	mov	r16, r19
    2808:	91 10       	cpse	r9, r1
    280a:	01 2f       	mov	r16, r17
    280c:	86 0f       	add	r24, r22
			MOV1(b0,b1)
    280e:	10 2f       	mov	r17, r16

		{
			// while(--count)
			{
				// Loop beginning
				DNOP;
    2810:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    2812:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2814:	00 c0       	rjmp	.+0      	; 0x2816 <L_4796+0x54>
    2816:	00 c0       	rjmp	.+0      	; 0x2818 <L_4796+0x56>
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    2818:	17 ff       	sbrs	r17, 7
    281a:	92 b9       	out	0x02, r25	; 2
    281c:	30 81       	ld	r19, Z
    281e:	00 27       	eor	r16, r16
    2820:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2822:	00 c0       	rjmp	.+0      	; 0x2824 <L_4796+0x62>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2824:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    2826:	92 b9       	out	0x02, r25	; 2
    2828:	31 11       	cpse	r19, r1
    282a:	3f 0d       	add	r19, r15
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    282c:	00 c0       	rjmp	.+0      	; 0x282e <L_4796+0x6c>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    282e:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    2830:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2832:	00 c0       	rjmp	.+0      	; 0x2834 <L_4796+0x72>
    2834:	00 c0       	rjmp	.+0      	; 0x2836 <L_4796+0x74>
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    2836:	16 ff       	sbrs	r17, 6
    2838:	92 b9       	out	0x02, r25	; 2
    283a:	08 f4       	brcc	.+2      	; 0x283e <L_5340>
    283c:	3f ef       	ldi	r19, 0xFF	; 255

0000283e <L_5340>:
    283e:	f1 94       	neg	r15
    2840:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2842:	00 c0       	rjmp	.+0      	; 0x2844 <L_5340+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2844:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    2846:	92 b9       	out	0x02, r25	; 2
    2848:	40 fd       	sbrc	r20, 0
    284a:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    284c:	00 c0       	rjmp	.+0      	; 0x284e <L_5340+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    284e:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    2850:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2852:	00 c0       	rjmp	.+0      	; 0x2854 <L_5340+0x16>
    2854:	00 c0       	rjmp	.+0      	; 0x2856 <L_5340+0x18>

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    2856:	15 ff       	sbrs	r17, 5
    2858:	92 b9       	out	0x02, r25	; 2
    285a:	07 95       	ror	r16
    285c:	88 94       	clc
    285e:	41 fd       	sbrc	r20, 1
    2860:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2862:	00 c0       	rjmp	.+0      	; 0x2864 <L_5340+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2864:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    2866:	92 b9       	out	0x02, r25	; 2
    2868:	07 95       	ror	r16
    286a:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    286c:	00 c0       	rjmp	.+0      	; 0x286e <L_5340+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    286e:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    2870:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2872:	00 c0       	rjmp	.+0      	; 0x2874 <L_5340+0x36>
    2874:	00 c0       	rjmp	.+0      	; 0x2876 <L_5340+0x38>
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    2876:	14 ff       	sbrs	r17, 4
    2878:	92 b9       	out	0x02, r25	; 2
    287a:	42 fd       	sbrc	r20, 2
    287c:	03 0f       	add	r16, r19
    287e:	07 95       	ror	r16
    2880:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2882:	00 c0       	rjmp	.+0      	; 0x2884 <L_5340+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2884:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    2886:	92 b9       	out	0x02, r25	; 2
    2888:	43 fd       	sbrc	r20, 3
    288a:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    288c:	00 c0       	rjmp	.+0      	; 0x288e <L_5340+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    288e:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2890:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2892:	00 c0       	rjmp	.+0      	; 0x2894 <L_5340+0x56>
    2894:	00 c0       	rjmp	.+0      	; 0x2896 <L_5340+0x58>
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2896:	13 ff       	sbrs	r17, 3
    2898:	92 b9       	out	0x02, r25	; 2
    289a:	07 95       	ror	r16
    289c:	88 94       	clc
    289e:	44 fd       	sbrc	r20, 4
    28a0:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28a2:	00 c0       	rjmp	.+0      	; 0x28a4 <L_5340+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28a4:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    28a6:	92 b9       	out	0x02, r25	; 2
    28a8:	07 95       	ror	r16
    28aa:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28ac:	00 c0       	rjmp	.+0      	; 0x28ae <L_5340+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28ae:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    28b0:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28b2:	00 c0       	rjmp	.+0      	; 0x28b4 <L_5340+0x76>
    28b4:	00 c0       	rjmp	.+0      	; 0x28b6 <L_5340+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    28b6:	12 ff       	sbrs	r17, 2
    28b8:	92 b9       	out	0x02, r25	; 2
    28ba:	45 fd       	sbrc	r20, 5
    28bc:	03 0f       	add	r16, r19
    28be:	07 95       	ror	r16
    28c0:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28c2:	00 c0       	rjmp	.+0      	; 0x28c4 <L_5340+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28c4:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    28c6:	92 b9       	out	0x02, r25	; 2
    28c8:	46 fd       	sbrc	r20, 6
    28ca:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28cc:	00 c0       	rjmp	.+0      	; 0x28ce <L_5340+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28ce:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    28d0:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28d2:	00 c0       	rjmp	.+0      	; 0x28d4 <L_5340+0x96>
    28d4:	00 c0       	rjmp	.+0      	; 0x28d6 <L_5340+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    28d6:	11 ff       	sbrs	r17, 1
    28d8:	92 b9       	out	0x02, r25	; 2
    28da:	07 95       	ror	r16
    28dc:	88 94       	clc
    28de:	47 fd       	sbrc	r20, 7
    28e0:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28e2:	00 c0       	rjmp	.+0      	; 0x28e4 <L_5340+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28e4:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    28e6:	92 b9       	out	0x02, r25	; 2
    28e8:	07 95       	ror	r16
    28ea:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28ec:	00 c0       	rjmp	.+0      	; 0x28ee <L_5340+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    28ee:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    28f0:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    28f2:	00 c0       	rjmp	.+0      	; 0x28f4 <L_5340+0xb6>
    28f4:	00 c0       	rjmp	.+0      	; 0x28f6 <L_5340+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    28f6:	10 ff       	sbrs	r17, 0
    28f8:	92 b9       	out	0x02, r25	; 2
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
    28fa:	13 2f       	mov	r17, r19
    28fc:	41 11       	cpse	r20, r1
    28fe:	10 2f       	mov	r17, r16
    2900:	fc 0e       	add	r15, r28
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2902:	00 c0       	rjmp	.+0      	; 0x2904 <L_5340+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2904:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
    2906:	92 b9       	out	0x02, r25	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2908:	00 c0       	rjmp	.+0      	; 0x290a <L_5340+0xcc>
    290a:	00 c0       	rjmp	.+0      	; 0x290c <L_5340+0xce>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    290c:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    290e:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2910:	00 c0       	rjmp	.+0      	; 0x2912 <L_5340+0xd4>
    2912:	00 c0       	rjmp	.+0      	; 0x2914 <L_5340+0xd6>
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    2914:	17 ff       	sbrs	r17, 7
    2916:	92 b9       	out	0x02, r25	; 2
    2918:	32 81       	ldd	r19, Z+2	; 0x02
    291a:	00 27       	eor	r16, r16
    291c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    291e:	00 c0       	rjmp	.+0      	; 0x2920 <L_5340+0xe2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2920:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    2922:	92 b9       	out	0x02, r25	; 2
    2924:	31 11       	cpse	r19, r1
    2926:	3e 0d       	add	r19, r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2928:	00 c0       	rjmp	.+0      	; 0x292a <L_5340+0xec>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    292a:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    292c:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    292e:	00 c0       	rjmp	.+0      	; 0x2930 <L_5340+0xf2>
    2930:	00 c0       	rjmp	.+0      	; 0x2932 <L_5340+0xf4>
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    2932:	16 ff       	sbrs	r17, 6
    2934:	92 b9       	out	0x02, r25	; 2
    2936:	08 f4       	brcc	.+2      	; 0x293a <L_6558>
    2938:	3f ef       	ldi	r19, 0xFF	; 255

0000293a <L_6558>:
    293a:	e7 0f       	add	r30, r23
    293c:	f1 1d       	adc	r31, r1
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    293e:	00 c0       	rjmp	.+0      	; 0x2940 <L_6558+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2940:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    2942:	92 b9       	out	0x02, r25	; 2
    2944:	50 fd       	sbrc	r21, 0
    2946:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2948:	00 c0       	rjmp	.+0      	; 0x294a <L_6558+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    294a:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    294c:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    294e:	00 c0       	rjmp	.+0      	; 0x2950 <L_6558+0x16>
    2950:	00 c0       	rjmp	.+0      	; 0x2952 <L_6558+0x18>
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2952:	15 ff       	sbrs	r17, 5
    2954:	92 b9       	out	0x02, r25	; 2
    2956:	07 95       	ror	r16
    2958:	88 94       	clc
    295a:	51 fd       	sbrc	r21, 1
    295c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    295e:	00 c0       	rjmp	.+0      	; 0x2960 <L_6558+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2960:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2962:	92 b9       	out	0x02, r25	; 2
    2964:	07 95       	ror	r16
    2966:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2968:	00 c0       	rjmp	.+0      	; 0x296a <L_6558+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    296a:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    296c:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    296e:	00 c0       	rjmp	.+0      	; 0x2970 <L_6558+0x36>
    2970:	00 c0       	rjmp	.+0      	; 0x2972 <L_6558+0x38>
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    2972:	14 ff       	sbrs	r17, 4
    2974:	92 b9       	out	0x02, r25	; 2
    2976:	52 fd       	sbrc	r21, 2
    2978:	03 0f       	add	r16, r19
    297a:	07 95       	ror	r16
    297c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    297e:	00 c0       	rjmp	.+0      	; 0x2980 <L_6558+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2980:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    2982:	92 b9       	out	0x02, r25	; 2
    2984:	53 fd       	sbrc	r21, 3
    2986:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2988:	00 c0       	rjmp	.+0      	; 0x298a <L_6558+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    298a:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    298c:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    298e:	00 c0       	rjmp	.+0      	; 0x2990 <L_6558+0x56>
    2990:	00 c0       	rjmp	.+0      	; 0x2992 <L_6558+0x58>

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2992:	13 ff       	sbrs	r17, 3
    2994:	92 b9       	out	0x02, r25	; 2
    2996:	07 95       	ror	r16
    2998:	88 94       	clc
    299a:	54 fd       	sbrc	r21, 4
    299c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    299e:	00 c0       	rjmp	.+0      	; 0x29a0 <L_6558+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29a0:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    29a2:	92 b9       	out	0x02, r25	; 2
    29a4:	07 95       	ror	r16
    29a6:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29a8:	00 c0       	rjmp	.+0      	; 0x29aa <L_6558+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29aa:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    29ac:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29ae:	00 c0       	rjmp	.+0      	; 0x29b0 <L_6558+0x76>
    29b0:	00 c0       	rjmp	.+0      	; 0x29b2 <L_6558+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    29b2:	12 ff       	sbrs	r17, 2
    29b4:	92 b9       	out	0x02, r25	; 2
    29b6:	55 fd       	sbrc	r21, 5
    29b8:	03 0f       	add	r16, r19
    29ba:	07 95       	ror	r16
    29bc:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29be:	00 c0       	rjmp	.+0      	; 0x29c0 <L_6558+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29c0:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    29c2:	92 b9       	out	0x02, r25	; 2
    29c4:	56 fd       	sbrc	r21, 6
    29c6:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29c8:	00 c0       	rjmp	.+0      	; 0x29ca <L_6558+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29ca:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    29cc:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29ce:	00 c0       	rjmp	.+0      	; 0x29d0 <L_6558+0x96>
    29d0:	00 c0       	rjmp	.+0      	; 0x29d2 <L_6558+0x98>
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    29d2:	11 ff       	sbrs	r17, 1
    29d4:	92 b9       	out	0x02, r25	; 2
    29d6:	07 95       	ror	r16
    29d8:	88 94       	clc
    29da:	57 fd       	sbrc	r21, 7
    29dc:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29de:	00 c0       	rjmp	.+0      	; 0x29e0 <L_6558+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29e0:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    29e2:	92 b9       	out	0x02, r25	; 2
    29e4:	07 95       	ror	r16
    29e6:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29e8:	00 c0       	rjmp	.+0      	; 0x29ea <L_6558+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    29ea:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    29ec:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29ee:	00 c0       	rjmp	.+0      	; 0x29f0 <L_6558+0xb6>
    29f0:	00 c0       	rjmp	.+0      	; 0x29f2 <L_6558+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    29f2:	10 ff       	sbrs	r17, 0
    29f4:	92 b9       	out	0x02, r25	; 2
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
    29f6:	13 2f       	mov	r17, r19
    29f8:	51 11       	cpse	r21, r1
    29fa:	10 2f       	mov	r17, r16
    29fc:	e1 94       	neg	r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    29fe:	00 c0       	rjmp	.+0      	; 0x2a00 <L_6558+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a00:	00 2c       	mov	r0, r0
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
    2a02:	92 b9       	out	0x02, r25	; 2
    2a04:	ed 0e       	add	r14, r29
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a06:	00 c0       	rjmp	.+0      	; 0x2a08 <L_6558+0xce>
    2a08:	00 c0       	rjmp	.+0      	; 0x2a0a <L_6558+0xd0>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    2a0a:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a0c:	00 c0       	rjmp	.+0      	; 0x2a0e <L_6558+0xd4>
    2a0e:	00 c0       	rjmp	.+0      	; 0x2a10 <L_6558+0xd6>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    2a10:	17 ff       	sbrs	r17, 7
    2a12:	92 b9       	out	0x02, r25	; 2
    2a14:	31 81       	ldd	r19, Z+1	; 0x01
    2a16:	00 27       	eor	r16, r16
    2a18:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a1a:	00 c0       	rjmp	.+0      	; 0x2a1c <L_6558+0xe2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a1c:	00 2c       	mov	r0, r0

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    2a1e:	92 b9       	out	0x02, r25	; 2
    2a20:	31 11       	cpse	r19, r1
    2a22:	38 0f       	add	r19, r24
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a24:	00 c0       	rjmp	.+0      	; 0x2a26 <L_6558+0xec>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a26:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    2a28:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a2a:	00 c0       	rjmp	.+0      	; 0x2a2c <L_6558+0xf2>
    2a2c:	00 c0       	rjmp	.+0      	; 0x2a2e <L_6558+0xf4>
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    2a2e:	16 ff       	sbrs	r17, 6
    2a30:	92 b9       	out	0x02, r25	; 2
    2a32:	08 f4       	brcc	.+2      	; 0x2a36 <L_7782>
    2a34:	3f ef       	ldi	r19, 0xFF	; 255

00002a36 <L_7782>:
    2a36:	81 95       	neg	r24
    2a38:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a3a:	00 c0       	rjmp	.+0      	; 0x2a3c <L_7782+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a3c:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    2a3e:	92 b9       	out	0x02, r25	; 2
    2a40:	90 fc       	sbrc	r9, 0
    2a42:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a44:	00 c0       	rjmp	.+0      	; 0x2a46 <L_7782+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a46:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2a48:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a4a:	00 c0       	rjmp	.+0      	; 0x2a4c <L_7782+0x16>
    2a4c:	00 c0       	rjmp	.+0      	; 0x2a4e <L_7782+0x18>
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2a4e:	15 ff       	sbrs	r17, 5
    2a50:	92 b9       	out	0x02, r25	; 2
    2a52:	07 95       	ror	r16
    2a54:	88 94       	clc
    2a56:	91 fc       	sbrc	r9, 1
    2a58:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a5a:	00 c0       	rjmp	.+0      	; 0x2a5c <L_7782+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a5c:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2a5e:	92 b9       	out	0x02, r25	; 2
    2a60:	07 95       	ror	r16
    2a62:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a64:	00 c0       	rjmp	.+0      	; 0x2a66 <L_7782+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a66:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    2a68:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a6a:	00 c0       	rjmp	.+0      	; 0x2a6c <L_7782+0x36>
    2a6c:	00 c0       	rjmp	.+0      	; 0x2a6e <L_7782+0x38>
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    2a6e:	14 ff       	sbrs	r17, 4
    2a70:	92 b9       	out	0x02, r25	; 2
    2a72:	92 fc       	sbrc	r9, 2
    2a74:	03 0f       	add	r16, r19
    2a76:	07 95       	ror	r16
    2a78:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a7a:	00 c0       	rjmp	.+0      	; 0x2a7c <L_7782+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a7c:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    2a7e:	92 b9       	out	0x02, r25	; 2
    2a80:	93 fc       	sbrc	r9, 3
    2a82:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a84:	00 c0       	rjmp	.+0      	; 0x2a86 <L_7782+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a86:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    2a88:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a8a:	00 c0       	rjmp	.+0      	; 0x2a8c <L_7782+0x56>
    2a8c:	00 c0       	rjmp	.+0      	; 0x2a8e <L_7782+0x58>
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    2a8e:	13 ff       	sbrs	r17, 3
    2a90:	92 b9       	out	0x02, r25	; 2
    2a92:	07 95       	ror	r16
    2a94:	88 94       	clc
    2a96:	94 fc       	sbrc	r9, 4
    2a98:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2a9a:	00 c0       	rjmp	.+0      	; 0x2a9c <L_7782+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2a9c:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    2a9e:	92 b9       	out	0x02, r25	; 2
    2aa0:	07 95       	ror	r16
    2aa2:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2aa4:	00 c0       	rjmp	.+0      	; 0x2aa6 <L_7782+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2aa6:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    2aa8:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2aaa:	00 c0       	rjmp	.+0      	; 0x2aac <L_7782+0x76>
    2aac:	00 c0       	rjmp	.+0      	; 0x2aae <L_7782+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    2aae:	12 ff       	sbrs	r17, 2
    2ab0:	92 b9       	out	0x02, r25	; 2
    2ab2:	95 fc       	sbrc	r9, 5
    2ab4:	03 0f       	add	r16, r19
    2ab6:	07 95       	ror	r16
    2ab8:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2aba:	00 c0       	rjmp	.+0      	; 0x2abc <L_7782+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2abc:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    2abe:	92 b9       	out	0x02, r25	; 2
    2ac0:	96 fc       	sbrc	r9, 6
    2ac2:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2ac4:	00 c0       	rjmp	.+0      	; 0x2ac6 <L_7782+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2ac6:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2ac8:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2aca:	00 c0       	rjmp	.+0      	; 0x2acc <L_7782+0x96>
    2acc:	00 c0       	rjmp	.+0      	; 0x2ace <L_7782+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2ace:	11 ff       	sbrs	r17, 1
    2ad0:	92 b9       	out	0x02, r25	; 2
    2ad2:	07 95       	ror	r16
    2ad4:	88 94       	clc
    2ad6:	97 fc       	sbrc	r9, 7
    2ad8:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2ada:	00 c0       	rjmp	.+0      	; 0x2adc <L_7782+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2adc:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    2ade:	92 b9       	out	0x02, r25	; 2
    2ae0:	07 95       	ror	r16
    2ae2:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2ae4:	00 c0       	rjmp	.+0      	; 0x2ae6 <L_7782+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2ae6:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    2ae8:	b2 b8       	out	0x02, r11	; 2
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2aea:	00 c0       	rjmp	.+0      	; 0x2aec <L_7782+0xb6>
    2aec:	00 c0       	rjmp	.+0      	; 0x2aee <L_7782+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    2aee:	10 ff       	sbrs	r17, 0
    2af0:	92 b9       	out	0x02, r25	; 2
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
    2af2:	13 2f       	mov	r17, r19
    2af4:	91 10       	cpse	r9, r1
    2af6:	10 2f       	mov	r17, r16
    2af8:	86 0f       	add	r24, r22
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    2afa:	00 c0       	rjmp	.+0      	; 0x2afc <L_7782+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    2afc:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
    2afe:	92 b9       	out	0x02, r25	; 2
				ENDLOOP5
    2b00:	11 97       	sbiw	r26, 0x01	; 1
    2b02:	09 f0       	breq	.+2      	; 0x2b06 <L_8751>
    2b04:	86 ce       	rjmp	.-756    	; 0x2812 <L_4796+0x50>

00002b06 <L_8751>:

		#if (FASTLED_ALLOW_INTERRUPTS == 1)
		// stop using the clock juggler
		TCCR0A &= ~0x30;
		#endif
	}
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	1f 91       	pop	r17
    2b0c:	0f 91       	pop	r16
    2b0e:	ff 90       	pop	r15
    2b10:	ef 90       	pop	r14
    2b12:	df 90       	pop	r13
    2b14:	cf 90       	pop	r12
    2b16:	bf 90       	pop	r11
    2b18:	af 90       	pop	r10
    2b1a:	9f 90       	pop	r9
    2b1c:	08 95       	ret

00002b1e <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE>:

	virtual uint16_t getMaxRefreshRate() const { return 400; }

protected:

	virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	cf 93       	push	r28
    2b24:	df 93       	push	r29
    2b26:	ec 01       	movw	r28, r24
    2b28:	8b 01       	movw	r16, r22
	CMinWait() { mLastMicros = 0; }

	void wait() {
		uint16_t diff;
		do {
			diff = (micros() & 0xFFFF) - mLastMicros;
    2b2a:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
public:
	CMinWait() { mLastMicros = 0; }

	void wait() {
		uint16_t diff;
		do {
    2b2e:	2f 85       	ldd	r18, Y+15	; 0x0f
    2b30:	38 89       	ldd	r19, Y+16	; 0x10
    2b32:	62 1b       	sub	r22, r18
    2b34:	73 0b       	sbc	r23, r19
    2b36:	6a 30       	cpi	r22, 0x0A	; 10
    2b38:	71 05       	cpc	r23, r1
    2b3a:	b8 f3       	brcs	.-18     	; 0x2b2a <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0xc>

		mWait.wait();
		cli();
    2b3c:	f8 94       	cli

		showRGBInternal(pixels);
    2b3e:	c8 01       	movw	r24, r16
    2b40:	0e 94 ab 13 	call	0x2756	; 0x2756 <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_66ELi1ELm4294967295EE>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
            }
        }

        __attribute__((always_inline)) inline int size() { return mLen; }
    2b44:	f8 01       	movw	r30, r16
    2b46:	42 81       	ldd	r20, Z+2	; 0x02
    2b48:	53 81       	ldd	r21, Z+3	; 0x03

		// Adjust the timer
#if (!defined(NO_CORRECTION) || (NO_CORRECTION == 0)) && (FASTLED_ALLOW_INTERRUPTS == 0)
        uint32_t microsTaken = (uint32_t)pixels.size() * (uint32_t)CLKS_TO_MICROS(24 * (T1 + T2 + T3));
    2b4a:	20 ee       	ldi	r18, 0xE0	; 224
    2b4c:	31 e0       	ldi	r19, 0x01	; 1
    2b4e:	da 01       	movw	r26, r20
    2b50:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <__usmulhisi3>
    2b54:	dc 01       	movw	r26, r24
    2b56:	cb 01       	movw	r24, r22
    2b58:	f4 e0       	ldi	r31, 0x04	; 4
    2b5a:	b6 95       	lsr	r27
    2b5c:	a7 95       	ror	r26
    2b5e:	97 95       	ror	r25
    2b60:	87 95       	ror	r24
    2b62:	fa 95       	dec	r31
    2b64:	d1 f7       	brne	.-12     	; 0x2b5a <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0x3c>
         "  clr __zero_reg__                    \n\t"

         : [result] "+r" (result)
         : [i] "r" (i), [scale] "r" (scale)
         : "r0", "r1"
         );
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	b9 01       	movw	r22, r18
    2b6c:	ea e9       	ldi	r30, 0x9A	; 154
    2b6e:	4e 9f       	mul	r20, r30
    2b70:	61 2d       	mov	r22, r1
    2b72:	5e 9f       	mul	r21, r30
    2b74:	60 0d       	add	r22, r0
    2b76:	71 1d       	adc	r23, r1
    2b78:	11 24       	eor	r1, r1

        // adust for approximate observed actal runtime (as of January 2015)
        // roughly 9.6 cycles per pixel, which is 0.6us/pixel at 16MHz
        // microsTaken += nLeds * 0.6 * CLKS_TO_MICROS(16);
        microsTaken += scale16by8(pixels.size(),(0.6 * 256) + 1) * CLKS_TO_MICROS(16);
    2b7a:	86 0f       	add	r24, r22
    2b7c:	97 1f       	adc	r25, r23
    2b7e:	a1 1d       	adc	r26, r1
    2b80:	b1 1d       	adc	r27, r1
        // this is because the ONE interrupt that might come in while interrupts
        // are disabled is queued up, and it will be serviced as soon as
        // interrupts are re-enabled.
        // This actually should technically also account for the runtime of the
        // interrupt handler itself, but we're just not going to worry about that.
        if( microsTaken > 1000) {
    2b82:	89 3e       	cpi	r24, 0xE9	; 233
    2b84:	f3 e0       	ldi	r31, 0x03	; 3
    2b86:	9f 07       	cpc	r25, r31
    2b88:	a1 05       	cpc	r26, r1
    2b8a:	b1 05       	cpc	r27, r1
    2b8c:	88 f1       	brcs	.+98     	; 0x2bf0 <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0xd2>
            microsTaken -= 1000;

            // Now convert microseconds to 256ths of a second, approximately like this:
            // 250ths = (us/4)
            // 256ths = 250ths * (263/256);
            uint16_t x256ths = microsTaken >> 2;
    2b8e:	88 5e       	subi	r24, 0xE8	; 232
    2b90:	93 40       	sbci	r25, 0x03	; 3
    2b92:	a1 09       	sbc	r26, r1
    2b94:	b1 09       	sbc	r27, r1
    2b96:	42 e0       	ldi	r20, 0x02	; 2
    2b98:	b6 95       	lsr	r27
    2b9a:	a7 95       	ror	r26
    2b9c:	97 95       	ror	r25
    2b9e:	87 95       	ror	r24
    2ba0:	4a 95       	dec	r20
    2ba2:	d1 f7       	brne	.-12     	; 0x2b98 <_ZN19ClocklessControllerILh28ELi6ELi8ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0x7a>
    2ba4:	47 e0       	ldi	r20, 0x07	; 7
    2ba6:	84 9f       	mul	r24, r20
    2ba8:	21 2d       	mov	r18, r1
    2baa:	94 9f       	mul	r25, r20
    2bac:	20 0d       	add	r18, r0
    2bae:	31 1d       	adc	r19, r1
    2bb0:	11 24       	eor	r1, r1
    2bb2:	60 91 9b 03 	lds	r22, 0x039B	; 0x80039b <_ZL21gTimeErrorAccum256ths>
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	86 0f       	add	r24, r22
    2bba:	97 1f       	adc	r25, r23
            x256ths += scale16by8(x256ths,7);

            x256ths += gTimeErrorAccum256ths;
    2bbc:	82 0f       	add	r24, r18
    2bbe:	93 1f       	adc	r25, r19
            MS_COUNTER += (x256ths >> 8);
    2bc0:	40 91 b9 05 	lds	r20, 0x05B9	; 0x8005b9 <timer0_millis>
    2bc4:	50 91 ba 05 	lds	r21, 0x05BA	; 0x8005ba <timer0_millis+0x1>
    2bc8:	60 91 bb 05 	lds	r22, 0x05BB	; 0x8005bb <timer0_millis+0x2>
    2bcc:	70 91 bc 05 	lds	r23, 0x05BC	; 0x8005bc <timer0_millis+0x3>
    2bd0:	29 2f       	mov	r18, r25
    2bd2:	33 27       	eor	r19, r19
    2bd4:	42 0f       	add	r20, r18
    2bd6:	53 1f       	adc	r21, r19
    2bd8:	61 1d       	adc	r22, r1
    2bda:	71 1d       	adc	r23, r1
    2bdc:	40 93 b9 05 	sts	0x05B9, r20	; 0x8005b9 <timer0_millis>
    2be0:	50 93 ba 05 	sts	0x05BA, r21	; 0x8005ba <timer0_millis+0x1>
    2be4:	60 93 bb 05 	sts	0x05BB, r22	; 0x8005bb <timer0_millis+0x2>
    2be8:	70 93 bc 05 	sts	0x05BC, r23	; 0x8005bc <timer0_millis+0x3>
            gTimeErrorAccum256ths = x256ths & 0xFF;
    2bec:	80 93 9b 03 	sts	0x039B, r24	; 0x80039b <_ZL21gTimeErrorAccum256ths>
        MS_COUNTER += (microsTaken >> 10);
#endif

#endif

		sei();
    2bf0:	78 94       	sei
			diff = (micros() & 0xFFFF) - mLastMicros;
		} while(diff < WAIT);
	}

	void mark() { mLastMicros = micros() & 0xFFFF; }
    2bf2:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
    2bf6:	78 8b       	std	Y+16, r23	; 0x10
    2bf8:	6f 87       	std	Y+15, r22	; 0x0f
		mWait.mark();
	}
    2bfa:	df 91       	pop	r29
    2bfc:	cf 91       	pop	r28
    2bfe:	1f 91       	pop	r17
    2c00:	0f 91       	pop	r16
    2c02:	08 95       	ret

00002c04 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>:
        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
            mOffsets[i] = nOffset;
    2c04:	fc 01       	movw	r30, r24
    2c06:	11 8a       	std	Z+17, r1	; 0x11
    2c08:	10 8a       	std	Z+16, r1	; 0x10
    2c0a:	08 95       	ret

00002c0c <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>:
            enable_dithering(dither);
            mAdvance = 0;
            initOffsets(len);
        }

        void init_binary_dithering() {
    2c0c:	0f 93       	push	r16
    2c0e:	1f 93       	push	r17
    2c10:	cf 93       	push	r28
    2c12:	df 93       	push	r29
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
    2c14:	20 91 69 02 	lds	r18, 0x0269	; 0x800269 <_ZZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEvE1R>
    2c18:	2f 5f       	subi	r18, 0xFF	; 255
    2c1a:	32 2f       	mov	r19, r18
    2c1c:	37 70       	andi	r19, 0x07	; 7
    2c1e:	30 93 69 02 	sts	0x0269, r19	; 0x800269 <_ZZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEvE1R>
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
    2c22:	20 ff       	sbrs	r18, 0
    2c24:	02 c0       	rjmp	.+4      	; 0x2c2a <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x1e>
    2c26:	20 e8       	ldi	r18, 0x80	; 128
    2c28:	01 c0       	rjmp	.+2      	; 0x2c2c <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x20>
            R &= (0x01 << ditherBits) - 1;

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;
    2c2a:	20 e0       	ldi	r18, 0x00	; 0

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
    2c2c:	31 fd       	sbrc	r19, 1
    2c2e:	20 64       	ori	r18, 0x40	; 64
                if(R & 0x04) { Q |= 0x20; }
    2c30:	34 70       	andi	r19, 0x04	; 4
    2c32:	09 f0       	breq	.+2      	; 0x2c36 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x2a>
    2c34:	20 62       	ori	r18, 0x20	; 32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
    2c36:	20 5f       	subi	r18, 0xF0	; 240
    2c38:	fc 01       	movw	r30, r24
    2c3a:	ec 01       	movw	r28, r24
    2c3c:	23 96       	adiw	r28, 0x03	; 3
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
    2c3e:	00 e0       	ldi	r16, 0x00	; 0
    2c40:	11 e0       	ldi	r17, 0x01	; 1
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
    2c42:	64 85       	ldd	r22, Z+12	; 0x0c
                    e[i] = s ? (256/s) + 1 : 0;
    2c44:	66 23       	and	r22, r22
    2c46:	31 f0       	breq	.+12     	; 0x2c54 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x48>
    2c48:	70 e0       	ldi	r23, 0x00	; 0
    2c4a:	c8 01       	movw	r24, r16
    2c4c:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    2c50:	6f 5f       	subi	r22, 0xFF	; 255
    2c52:	01 c0       	rjmp	.+2      	; 0x2c56 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x4a>
    2c54:	60 e0       	ldi	r22, 0x00	; 0
    2c56:	61 87       	std	Z+9, r22	; 0x09
#endif
         "clr __zero_reg__    \n\t"

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    2c58:	32 2f       	mov	r19, r18
    2c5a:	36 9f       	mul	r19, r22
    2c5c:	03 0e       	add	r0, r19
    2c5e:	30 e0       	ldi	r19, 0x00	; 0
    2c60:	31 1d       	adc	r19, r1
    2c62:	11 24       	eor	r1, r1
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
    2c64:	31 11       	cpse	r19, r1
    2c66:	02 c0       	rjmp	.+4      	; 0x2c6c <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x60>

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
                    d[i] = scale8(Q, e[i]);
    2c68:	16 82       	std	Z+6, r1	; 0x06
    2c6a:	02 c0       	rjmp	.+4      	; 0x2c70 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x64>
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
    2c6c:	31 50       	subi	r19, 0x01	; 1
    2c6e:	36 83       	std	Z+6, r19	; 0x06
#endif
                    if(e[i]) e[i]--;
    2c70:	66 23       	and	r22, r22
    2c72:	11 f0       	breq	.+4      	; 0x2c78 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x6c>
    2c74:	61 50       	subi	r22, 0x01	; 1
    2c76:	61 87       	std	Z+9, r22	; 0x09
    2c78:	31 96       	adiw	r30, 0x01	; 1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
    2c7a:	ce 17       	cp	r28, r30
    2c7c:	df 07       	cpc	r29, r31
    2c7e:	09 f7       	brne	.-62     	; 0x2c42 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x36>
                    if(d[i]) (d[i]--);
#endif
                    if(e[i]) e[i]--;
            }
#endif
        }
    2c80:	df 91       	pop	r29
    2c82:	cf 91       	pop	r28
    2c84:	1f 91       	pop	r17
    2c86:	0f 91       	pop	r16
    2c88:	08 95       	ret

00002c8a <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_>:

  /// set all the leds on the controller to a given color
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    2c8a:	ef 92       	push	r14
    2c8c:	ff 92       	push	r15
    2c8e:	0f 93       	push	r16
    2c90:	1f 93       	push	r17
    2c92:	cf 93       	push	r28
    2c94:	df 93       	push	r29
    2c96:	cd b7       	in	r28, 0x3d	; 61
    2c98:	de b7       	in	r29, 0x3e	; 62
    2c9a:	62 97       	sbiw	r28, 0x12	; 18
    2c9c:	0f b6       	in	r0, 0x3f	; 63
    2c9e:	f8 94       	cli
    2ca0:	de bf       	out	0x3e, r29	; 62
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	cd bf       	out	0x3d, r28	; 61
    2ca6:	8c 01       	movw	r16, r24
    2ca8:	7a 01       	movw	r14, r20
    2caa:	f9 01       	movw	r30, r18
    2cac:	dc 01       	movw	r26, r24
    2cae:	1c 96       	adiw	r26, 0x0c	; 12
    2cb0:	8c 91       	ld	r24, X
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
    2cb2:	7a 83       	std	Y+2, r23	; 0x02
    2cb4:	69 83       	std	Y+1, r22	; 0x01
    2cb6:	5c 83       	std	Y+4, r21	; 0x04
    2cb8:	4b 83       	std	Y+3, r20	; 0x03
    2cba:	5e 83       	std	Y+6, r21	; 0x06
    2cbc:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2cbe:	90 81       	ld	r25, Z
    2cc0:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
    2cc2:	91 81       	ldd	r25, Z+1	; 0x01
    2cc4:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
    2cc6:	92 81       	ldd	r25, Z+2	; 0x02
    2cc8:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
    2cca:	81 30       	cpi	r24, 0x01	; 1
    2ccc:	29 f4       	brne	.+10     	; 0x2cd8 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
    2cce:	ce 01       	movw	r24, r28
    2cd0:	01 96       	adiw	r24, 0x01	; 1
    2cd2:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>
    2cd6:	06 c0       	rjmp	.+12     	; 0x2ce4 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
    2cd8:	1c 86       	std	Y+12, r1	; 0x0c
    2cda:	1b 86       	std	Y+11, r1	; 0x0b
    2cdc:	1a 86       	std	Y+10, r1	; 0x0a
    2cde:	19 86       	std	Y+9, r1	; 0x09
    2ce0:	18 86       	std	Y+8, r1	; 0x08
    2ce2:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
    2ce4:	18 8a       	std	Y+16, r1	; 0x10
            initOffsets(len);
    2ce6:	b7 01       	movw	r22, r14
    2ce8:	ce 01       	movw	r24, r28
    2cea:	01 96       	adiw	r24, 0x01	; 1
    2cec:	0e 94 02 16 	call	0x2c04	; 0x2c04 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
    2cf0:	d8 01       	movw	r26, r16
    2cf2:	ed 91       	ld	r30, X+
    2cf4:	fc 91       	ld	r31, X
    2cf6:	04 84       	ldd	r0, Z+12	; 0x0c
    2cf8:	f5 85       	ldd	r31, Z+13	; 0x0d
    2cfa:	e0 2d       	mov	r30, r0
    2cfc:	be 01       	movw	r22, r28
    2cfe:	6f 5f       	subi	r22, 0xFF	; 255
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	c8 01       	movw	r24, r16
    2d04:	09 95       	icall
  }
    2d06:	62 96       	adiw	r28, 0x12	; 18
    2d08:	0f b6       	in	r0, 0x3f	; 63
    2d0a:	f8 94       	cli
    2d0c:	de bf       	out	0x3e, r29	; 62
    2d0e:	0f be       	out	0x3f, r0	; 63
    2d10:	cd bf       	out	0x3d, r28	; 61
    2d12:	df 91       	pop	r29
    2d14:	cf 91       	pop	r28
    2d16:	1f 91       	pop	r17
    2d18:	0f 91       	pop	r16
    2d1a:	ff 90       	pop	r15
    2d1c:	ef 90       	pop	r14
    2d1e:	08 95       	ret

00002d20 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_>:

/// write the passed in rgb data out to the leds managed by this controller
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    2d20:	ef 92       	push	r14
    2d22:	ff 92       	push	r15
    2d24:	0f 93       	push	r16
    2d26:	1f 93       	push	r17
    2d28:	cf 93       	push	r28
    2d2a:	df 93       	push	r29
    2d2c:	cd b7       	in	r28, 0x3d	; 61
    2d2e:	de b7       	in	r29, 0x3e	; 62
    2d30:	62 97       	sbiw	r28, 0x12	; 18
    2d32:	0f b6       	in	r0, 0x3f	; 63
    2d34:	f8 94       	cli
    2d36:	de bf       	out	0x3e, r29	; 62
    2d38:	0f be       	out	0x3f, r0	; 63
    2d3a:	cd bf       	out	0x3d, r28	; 61
    2d3c:	8c 01       	movw	r16, r24
    2d3e:	7a 01       	movw	r14, r20
    2d40:	f9 01       	movw	r30, r18
    2d42:	dc 01       	movw	r26, r24
    2d44:	1c 96       	adiw	r26, 0x0c	; 12
    2d46:	8c 91       	ld	r24, X
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
    2d48:	7a 83       	std	Y+2, r23	; 0x02
    2d4a:	69 83       	std	Y+1, r22	; 0x01
    2d4c:	5c 83       	std	Y+4, r21	; 0x04
    2d4e:	4b 83       	std	Y+3, r20	; 0x03
    2d50:	5e 83       	std	Y+6, r21	; 0x06
    2d52:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2d54:	90 81       	ld	r25, Z
    2d56:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
    2d58:	91 81       	ldd	r25, Z+1	; 0x01
    2d5a:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
    2d5c:	92 81       	ldd	r25, Z+2	; 0x02
    2d5e:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
    2d60:	81 30       	cpi	r24, 0x01	; 1
    2d62:	29 f4       	brne	.+10     	; 0x2d6e <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
    2d64:	ce 01       	movw	r24, r28
    2d66:	01 96       	adiw	r24, 0x01	; 1
    2d68:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>
    2d6c:	06 c0       	rjmp	.+12     	; 0x2d7a <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
    2d6e:	1c 86       	std	Y+12, r1	; 0x0c
    2d70:	1b 86       	std	Y+11, r1	; 0x0b
    2d72:	1a 86       	std	Y+10, r1	; 0x0a
    2d74:	19 86       	std	Y+9, r1	; 0x09
    2d76:	18 86       	std	Y+8, r1	; 0x08
    2d78:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
    2d7a:	83 e0       	ldi	r24, 0x03	; 3
    2d7c:	88 8b       	std	Y+16, r24	; 0x10
            initOffsets(len);
    2d7e:	b7 01       	movw	r22, r14
    2d80:	ce 01       	movw	r24, r28
    2d82:	01 96       	adiw	r24, 0x01	; 1
    2d84:	0e 94 02 16 	call	0x2c04	; 0x2c04 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
    2d88:	d8 01       	movw	r26, r16
    2d8a:	ed 91       	ld	r30, X+
    2d8c:	fc 91       	ld	r31, X
    2d8e:	04 84       	ldd	r0, Z+12	; 0x0c
    2d90:	f5 85       	ldd	r31, Z+13	; 0x0d
    2d92:	e0 2d       	mov	r30, r0
    2d94:	be 01       	movw	r22, r28
    2d96:	6f 5f       	subi	r22, 0xFF	; 255
    2d98:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9a:	c8 01       	movw	r24, r16
    2d9c:	09 95       	icall
  }
    2d9e:	62 96       	adiw	r28, 0x12	; 18
    2da0:	0f b6       	in	r0, 0x3f	; 63
    2da2:	f8 94       	cli
    2da4:	de bf       	out	0x3e, r29	; 62
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	cd bf       	out	0x3d, r28	; 61
    2daa:	df 91       	pop	r29
    2dac:	cf 91       	pop	r28
    2dae:	1f 91       	pop	r17
    2db0:	0f 91       	pop	r16
    2db2:	ff 90       	pop	r15
    2db4:	ef 90       	pop	r14
    2db6:	08 95       	ret

00002db8 <_GLOBAL__sub_I_altSerial>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2db8:	ef e8       	ldi	r30, 0x8F	; 143
    2dba:	f3 e0       	ldi	r31, 0x03	; 3
    2dbc:	13 82       	std	Z+3, r1	; 0x03
    2dbe:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    2dc0:	88 ee       	ldi	r24, 0xE8	; 232
    2dc2:	93 e0       	ldi	r25, 0x03	; 3
    2dc4:	a0 e0       	ldi	r26, 0x00	; 0
    2dc6:	b0 e0       	ldi	r27, 0x00	; 0
    2dc8:	84 83       	std	Z+4, r24	; 0x04
    2dca:	95 83       	std	Z+5, r25	; 0x05
    2dcc:	a6 83       	std	Z+6, r26	; 0x06
    2dce:	b7 83       	std	Z+7, r27	; 0x07
#endif

class AltSoftSerial : public Stream
{
public:
	AltSoftSerial() { }
    2dd0:	84 ee       	ldi	r24, 0xE4	; 228
    2dd2:	91 e0       	ldi	r25, 0x01	; 1
    2dd4:	91 83       	std	Z+1, r25	; 0x01
    2dd6:	80 83       	st	Z, r24
#define ROT_SW	28
#define LS_SW	23
#define LS_DATA 28


ADXL345 adxl;
    2dd8:	8b e7       	ldi	r24, 0x7B	; 123
    2dda:	93 e0       	ldi	r25, 0x03	; 3
    2ddc:	0e 94 04 04 	call	0x808	; 0x808 <_ZN7ADXL345C1Ev>

//Define Input Objects and Variables
Rotary r = Rotary(ROT_DT, ROT_CK);
    2de0:	4d e1       	ldi	r20, 0x1D	; 29
    2de2:	6e e1       	ldi	r22, 0x1E	; 30
    2de4:	88 e7       	ldi	r24, 0x78	; 120
    2de6:	93 e0       	ldi	r25, 0x03	; 3
    2de8:	0e 94 96 08 	call	0x112c	; 0x112c <_ZN6RotaryC1Ecc>
	{
		interr = ACTION_DOWN;
	}
}

String readString;
    2dec:	66 e0       	ldi	r22, 0x06	; 6
    2dee:	72 e0       	ldi	r23, 0x02	; 2
    2df0:	8e e8       	ldi	r24, 0x8E	; 142
    2df2:	92 e0       	ldi	r25, 0x02	; 2
    2df4:	0c 94 29 26 	jmp	0x4c52	; 0x4c52 <_ZN6StringC1EPKc>

00002df8 <_GLOBAL__sub_D_altSerial>:
    2df8:	8e e8       	ldi	r24, 0x8E	; 142
    2dfa:	92 e0       	ldi	r25, 0x02	; 2
    2dfc:	0e 94 bb 25 	call	0x4b76	; 0x4b76 <_ZN6StringD1Ev>
	~AltSoftSerial() { end(); }
    2e00:	84 ee       	ldi	r24, 0xE4	; 228
    2e02:	91 e0       	ldi	r25, 0x01	; 1
    2e04:	90 93 90 03 	sts	0x0390, r25	; 0x800390 <altSerial+0x1>
    2e08:	80 93 8f 03 	sts	0x038F, r24	; 0x80038f <altSerial>
    2e0c:	0c 94 7d 19 	jmp	0x32fa	; 0x32fa <_ZN13AltSoftSerial3endEv>

00002e10 <_ZN13AltSoftSerial4readEv>:

int AltSoftSerial::read(void)
{
	uint8_t head, tail, out;

	head = rx_buffer_head;
    2e10:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <_ZL14rx_buffer_head>
	tail = rx_buffer_tail;
    2e14:	90 91 35 04 	lds	r25, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
	if (head == tail) return -1;
    2e18:	89 17       	cp	r24, r25
    2e1a:	69 f0       	breq	.+26     	; 0x2e36 <_ZN13AltSoftSerial4readEv+0x26>
	if (++tail >= RX_BUFFER_SIZE) tail = 0;
    2e1c:	9f 5f       	subi	r25, 0xFF	; 255
    2e1e:	90 35       	cpi	r25, 0x50	; 80
    2e20:	08 f0       	brcs	.+2      	; 0x2e24 <_ZN13AltSoftSerial4readEv+0x14>
    2e22:	90 e0       	ldi	r25, 0x00	; 0
	out = rx_buffer[tail];
    2e24:	e9 2f       	mov	r30, r25
    2e26:	f0 e0       	ldi	r31, 0x00	; 0
    2e28:	eb 51       	subi	r30, 0x1B	; 27
    2e2a:	fc 4f       	sbci	r31, 0xFC	; 252
    2e2c:	80 81       	ld	r24, Z
	rx_buffer_tail = tail;
    2e2e:	90 93 35 04 	sts	0x0435, r25	; 0x800435 <_ZL14rx_buffer_tail>
	return out;
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	08 95       	ret
{
	uint8_t head, tail, out;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    2e36:	8f ef       	ldi	r24, 0xFF	; 255
    2e38:	9f ef       	ldi	r25, 0xFF	; 255
	if (++tail >= RX_BUFFER_SIZE) tail = 0;
	out = rx_buffer[tail];
	rx_buffer_tail = tail;
	return out;
}
    2e3a:	08 95       	ret

00002e3c <_ZN13AltSoftSerial4peekEv>:

int AltSoftSerial::peek(void)
{
	uint8_t head, tail;

	head = rx_buffer_head;
    2e3c:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <_ZL14rx_buffer_head>
	tail = rx_buffer_tail;
    2e40:	e0 91 35 04 	lds	r30, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
	if (head == tail) return -1;
    2e44:	8e 17       	cp	r24, r30
    2e46:	51 f0       	breq	.+20     	; 0x2e5c <_ZN13AltSoftSerial4peekEv+0x20>
	if (++tail >= RX_BUFFER_SIZE) tail = 0;
    2e48:	ef 5f       	subi	r30, 0xFF	; 255
    2e4a:	e0 35       	cpi	r30, 0x50	; 80
    2e4c:	08 f0       	brcs	.+2      	; 0x2e50 <_ZN13AltSoftSerial4peekEv+0x14>
    2e4e:	e0 e0       	ldi	r30, 0x00	; 0
	return rx_buffer[tail];
    2e50:	f0 e0       	ldi	r31, 0x00	; 0
    2e52:	eb 51       	subi	r30, 0x1B	; 27
    2e54:	fc 4f       	sbci	r31, 0xFC	; 252
    2e56:	80 81       	ld	r24, Z
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	08 95       	ret
{
	uint8_t head, tail;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    2e5c:	8f ef       	ldi	r24, 0xFF	; 255
    2e5e:	9f ef       	ldi	r25, 0xFF	; 255
	if (++tail >= RX_BUFFER_SIZE) tail = 0;
	return rx_buffer[tail];
}
    2e60:	08 95       	ret

00002e62 <_ZN13AltSoftSerial9availableEv>:

int AltSoftSerial::available(void)
{
	uint8_t head, tail;

	head = rx_buffer_head;
    2e62:	50 91 36 04 	lds	r21, 0x0436	; 0x800436 <_ZL14rx_buffer_head>
	tail = rx_buffer_tail;
    2e66:	40 91 35 04 	lds	r20, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
    2e6a:	85 2f       	mov	r24, r21
    2e6c:	90 e0       	ldi	r25, 0x00	; 0
    2e6e:	24 2f       	mov	r18, r20
    2e70:	30 e0       	ldi	r19, 0x00	; 0
	if (head >= tail) return head - tail;
    2e72:	54 17       	cp	r21, r20
    2e74:	10 f4       	brcc	.+4      	; 0x2e7a <_ZN13AltSoftSerial9availableEv+0x18>
	return RX_BUFFER_SIZE + head - tail;
    2e76:	80 5b       	subi	r24, 0xB0	; 176
    2e78:	9f 4f       	sbci	r25, 0xFF	; 255
    2e7a:	82 1b       	sub	r24, r18
    2e7c:	93 0b       	sbc	r25, r19
}
    2e7e:	08 95       	ret

00002e80 <_ZN13AltSoftSerial4initEm>:
#endif

#define MAX_COUNTS_PER_BIT  6241  // 65536 / 10.5

void AltSoftSerial::init(uint32_t cycles_per_bit)
{
    2e80:	9b 01       	movw	r18, r22
    2e82:	ac 01       	movw	r20, r24
	//Serial.printf("cycles_per_bit = %d\n", cycles_per_bit);
	if (cycles_per_bit < MAX_COUNTS_PER_BIT) {
    2e84:	21 36       	cpi	r18, 0x61	; 97
    2e86:	68 e1       	ldi	r22, 0x18	; 24
    2e88:	36 07       	cpc	r19, r22
    2e8a:	41 05       	cpc	r20, r1
    2e8c:	51 05       	cpc	r21, r1
    2e8e:	30 f4       	brcc	.+12     	; 0x2e9c <_ZN13AltSoftSerial4initEm+0x1c>
		CONFIG_TIMER_NOPRESCALE();
    2e90:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    2e94:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    2e98:	81 e8       	ldi	r24, 0x81	; 129
    2e9a:	28 c0       	rjmp	.+80     	; 0x2eec <_ZN13AltSoftSerial4initEm+0x6c>
	} else {
		cycles_per_bit /= 8;
    2e9c:	da 01       	movw	r26, r20
    2e9e:	c9 01       	movw	r24, r18
    2ea0:	73 e0       	ldi	r23, 0x03	; 3
    2ea2:	b6 95       	lsr	r27
    2ea4:	a7 95       	ror	r26
    2ea6:	97 95       	ror	r25
    2ea8:	87 95       	ror	r24
    2eaa:	7a 95       	dec	r23
    2eac:	d1 f7       	brne	.-12     	; 0x2ea2 <_ZN13AltSoftSerial4initEm+0x22>
		//Serial.printf("cycles_per_bit/8 = %d\n", cycles_per_bit);
		if (cycles_per_bit < MAX_COUNTS_PER_BIT) {
    2eae:	81 36       	cpi	r24, 0x61	; 97
    2eb0:	68 e1       	ldi	r22, 0x18	; 24
    2eb2:	96 07       	cpc	r25, r22
    2eb4:	a1 05       	cpc	r26, r1
    2eb6:	b1 05       	cpc	r27, r1
    2eb8:	50 f4       	brcc	.+20     	; 0x2ece <_ZN13AltSoftSerial4initEm+0x4e>
			CONFIG_TIMER_PRESCALE_8();
    2eba:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    2ebe:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    2ec2:	22 e8       	ldi	r18, 0x82	; 130
    2ec4:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    2ec8:	9c 01       	movw	r18, r24
    2eca:	ad 01       	movw	r20, r26
    2ecc:	11 c0       	rjmp	.+34     	; 0x2ef0 <_ZN13AltSoftSerial4initEm+0x70>
		} else {
#if defined(CONFIG_TIMER_PRESCALE_256)
			cycles_per_bit /= 32;
    2ece:	23 2f       	mov	r18, r19
    2ed0:	34 2f       	mov	r19, r20
    2ed2:	45 2f       	mov	r20, r21
    2ed4:	55 27       	eor	r21, r21
			//Serial.printf("cycles_per_bit/256 = %d\n", cycles_per_bit);
			if (cycles_per_bit < MAX_COUNTS_PER_BIT) {
    2ed6:	21 36       	cpi	r18, 0x61	; 97
    2ed8:	88 e1       	ldi	r24, 0x18	; 24
    2eda:	38 07       	cpc	r19, r24
    2edc:	41 05       	cpc	r20, r1
    2ede:	51 05       	cpc	r21, r1
    2ee0:	c0 f5       	brcc	.+112    	; 0x2f52 <_ZN13AltSoftSerial4initEm+0xd2>
				CONFIG_TIMER_PRESCALE_256();
    2ee2:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    2ee6:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    2eea:	84 e8       	ldi	r24, 0x84	; 132
    2eec:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#else
			return; // baud rate too low for AltSoftSerial
#endif
		}
	}
	ticks_per_bit = cycles_per_bit;
    2ef0:	30 93 3f 04 	sts	0x043F, r19	; 0x80043f <_ZL13ticks_per_bit+0x1>
    2ef4:	20 93 3e 04 	sts	0x043E, r18	; 0x80043e <_ZL13ticks_per_bit>
	rx_stop_ticks = cycles_per_bit * 37 / 4;
    2ef8:	a5 e2       	ldi	r26, 0x25	; 37
    2efa:	b0 e0       	ldi	r27, 0x00	; 0
    2efc:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    2f00:	dc 01       	movw	r26, r24
    2f02:	cb 01       	movw	r24, r22
    2f04:	22 e0       	ldi	r18, 0x02	; 2
    2f06:	b6 95       	lsr	r27
    2f08:	a7 95       	ror	r26
    2f0a:	97 95       	ror	r25
    2f0c:	87 95       	ror	r24
    2f0e:	2a 95       	dec	r18
    2f10:	d1 f7       	brne	.-12     	; 0x2f06 <_ZN13AltSoftSerial4initEm+0x86>
    2f12:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <_ZL13rx_stop_ticks+0x1>
    2f16:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <_ZL13rx_stop_ticks>
	pinMode(INPUT_CAPTURE_PIN, INPUT_PULLUP);
    2f1a:	62 e0       	ldi	r22, 0x02	; 2
    2f1c:	8e e0       	ldi	r24, 0x0E	; 14
    2f1e:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
	digitalWrite(OUTPUT_COMPARE_A_PIN, HIGH);
    2f22:	61 e0       	ldi	r22, 0x01	; 1
    2f24:	8d e0       	ldi	r24, 0x0D	; 13
    2f26:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
	pinMode(OUTPUT_COMPARE_A_PIN, OUTPUT);
    2f2a:	61 e0       	ldi	r22, 0x01	; 1
    2f2c:	8d e0       	ldi	r24, 0x0D	; 13
    2f2e:	0e 94 aa 24 	call	0x4954	; 0x4954 <pinMode>
	rx_state = 0;
    2f32:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <_ZL8rx_state>
	rx_buffer_head = 0;
    2f36:	10 92 36 04 	sts	0x0436, r1	; 0x800436 <_ZL14rx_buffer_head>
	rx_buffer_tail = 0;
    2f3a:	10 92 35 04 	sts	0x0435, r1	; 0x800435 <_ZL14rx_buffer_tail>
	tx_state = 0;
    2f3e:	10 92 e4 03 	sts	0x03E4, r1	; 0x8003e4 <_ZL8tx_state>
	tx_buffer_head = 0;
    2f42:	10 92 e1 03 	sts	0x03E1, r1	; 0x8003e1 <_ZL14tx_buffer_head>
	tx_buffer_tail = 0;
    2f46:	10 92 e0 03 	sts	0x03E0, r1	; 0x8003e0 <_ZL14tx_buffer_tail>
	ENABLE_INT_INPUT_CAPTURE();
    2f4a:	80 e2       	ldi	r24, 0x20	; 32
    2f4c:	86 bb       	out	0x16, r24	; 22
    2f4e:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    2f52:	08 95       	ret

00002f54 <_ZN13AltSoftSerial9writeByteEh>:

void AltSoftSerial::writeByte(uint8_t b)
{
	uint8_t intr_state, head;

	head = tx_buffer_head + 1;
    2f54:	90 91 e1 03 	lds	r25, 0x03E1	; 0x8003e1 <_ZL14tx_buffer_head>
    2f58:	9f 5f       	subi	r25, 0xFF	; 255
	if (head >= TX_BUFFER_SIZE) head = 0;
    2f5a:	94 34       	cpi	r25, 0x44	; 68
    2f5c:	08 f0       	brcs	.+2      	; 0x2f60 <_ZN13AltSoftSerial9writeByteEh+0xc>
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
	while (tx_buffer_tail == head) ; // wait until space in buffer
    2f60:	20 91 e0 03 	lds	r18, 0x03E0	; 0x8003e0 <_ZL14tx_buffer_tail>
    2f64:	29 17       	cp	r18, r25
    2f66:	e1 f3       	breq	.-8      	; 0x2f60 <_ZN13AltSoftSerial9writeByteEh+0xc>
	intr_state = SREG;
    2f68:	2f b7       	in	r18, 0x3f	; 63
	cli();
    2f6a:	f8 94       	cli
	if (tx_state) {
    2f6c:	30 91 e4 03 	lds	r19, 0x03E4	; 0x8003e4 <_ZL8tx_state>
    2f70:	33 23       	and	r19, r19
    2f72:	41 f0       	breq	.+16     	; 0x2f84 <_ZN13AltSoftSerial9writeByteEh+0x30>
		tx_buffer[head] = b;
    2f74:	e9 2f       	mov	r30, r25
    2f76:	f0 e0       	ldi	r31, 0x00	; 0
    2f78:	e4 56       	subi	r30, 0x64	; 100
    2f7a:	fc 4f       	sbci	r31, 0xFC	; 252
    2f7c:	80 83       	st	Z, r24
		tx_buffer_head = head;
    2f7e:	90 93 e1 03 	sts	0x03E1, r25	; 0x8003e1 <_ZL14tx_buffer_head>
    2f82:	1d c0       	rjmp	.+58     	; 0x2fbe <_ZN13AltSoftSerial9writeByteEh+0x6a>
	} else {
		tx_state = 1;
    2f84:	91 e0       	ldi	r25, 0x01	; 1
    2f86:	90 93 e4 03 	sts	0x03E4, r25	; 0x8003e4 <_ZL8tx_state>
		tx_byte = b;
    2f8a:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <_ZL7tx_byte>
		tx_bit = 0;
    2f8e:	10 92 e2 03 	sts	0x03E2, r1	; 0x8003e2 <_ZL6tx_bit>
		ENABLE_INT_COMPARE_A();
    2f92:	82 e0       	ldi	r24, 0x02	; 2
    2f94:	86 bb       	out	0x16, r24	; 22
    2f96:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    2f9a:	82 60       	ori	r24, 0x02	; 2
    2f9c:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
		CONFIG_MATCH_CLEAR();
    2fa0:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    2fa4:	8f 7b       	andi	r24, 0xBF	; 191
    2fa6:	80 68       	ori	r24, 0x80	; 128
    2fa8:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
		SET_COMPARE_A(GET_TIMER_COUNT() + 16);
    2fac:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    2fb0:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    2fb4:	40 96       	adiw	r24, 0x10	; 16
    2fb6:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    2fba:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	}
	SREG = intr_state;
    2fbe:	2f bf       	out	0x3f, r18	; 63
    2fc0:	08 95       	ret

00002fc2 <_ZN13AltSoftSerial5writeEh>:
	static void end();
	int peek();
	int read();
	int available();
#if ARDUINO >= 100
	size_t write(uint8_t byte) { writeByte(byte); return 1; }
    2fc2:	86 2f       	mov	r24, r22
    2fc4:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <_ZN13AltSoftSerial9writeByteEh>
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	90 e0       	ldi	r25, 0x00	; 0
    2fcc:	08 95       	ret

00002fce <__vector_13>:
}


ISR(COMPARE_A_INTERRUPT)
{
    2fce:	1f 92       	push	r1
    2fd0:	0f 92       	push	r0
    2fd2:	0f b6       	in	r0, 0x3f	; 63
    2fd4:	0f 92       	push	r0
    2fd6:	11 24       	eor	r1, r1
    2fd8:	2f 93       	push	r18
    2fda:	3f 93       	push	r19
    2fdc:	4f 93       	push	r20
    2fde:	5f 93       	push	r21
    2fe0:	6f 93       	push	r22
    2fe2:	7f 93       	push	r23
    2fe4:	8f 93       	push	r24
    2fe6:	9f 93       	push	r25
    2fe8:	ef 93       	push	r30
    2fea:	ff 93       	push	r31
	uint8_t state, byte, bit, head, tail;
	uint16_t target;

	state = tx_state;
    2fec:	80 91 e4 03 	lds	r24, 0x03E4	; 0x8003e4 <_ZL8tx_state>
	byte = tx_byte;
    2ff0:	60 91 e3 03 	lds	r22, 0x03E3	; 0x8003e3 <_ZL7tx_byte>
	target = GET_COMPARE_A();
    2ff4:	20 91 88 00 	lds	r18, 0x0088	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    2ff8:	30 91 89 00 	lds	r19, 0x0089	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	while (state < 10) {
		target += ticks_per_bit;
    2ffc:	40 91 3e 04 	lds	r20, 0x043E	; 0x80043e <_ZL13ticks_per_bit>
    3000:	50 91 3f 04 	lds	r21, 0x043F	; 0x80043f <_ZL13ticks_per_bit+0x1>
			bit = byte & 1;
		else
			bit = 1; // stopbit
		byte >>= 1;
		state++;
		if (bit != tx_bit) {
    3004:	90 91 e2 03 	lds	r25, 0x03E2	; 0x8003e2 <_ZL6tx_bit>
	uint16_t target;

	state = tx_state;
	byte = tx_byte;
	target = GET_COMPARE_A();
	while (state < 10) {
    3008:	8a 30       	cpi	r24, 0x0A	; 10
    300a:	f8 f4       	brcc	.+62     	; 0x304a <__vector_13+0x7c>
		target += ticks_per_bit;
    300c:	24 0f       	add	r18, r20
    300e:	35 1f       	adc	r19, r21
		if (state < 9)
    3010:	89 30       	cpi	r24, 0x09	; 9
    3012:	19 f0       	breq	.+6      	; 0x301a <__vector_13+0x4c>
			bit = byte & 1;
    3014:	76 2f       	mov	r23, r22
    3016:	71 70       	andi	r23, 0x01	; 1
    3018:	01 c0       	rjmp	.+2      	; 0x301c <__vector_13+0x4e>
		else
			bit = 1; // stopbit
    301a:	71 e0       	ldi	r23, 0x01	; 1
		byte >>= 1;
    301c:	66 95       	lsr	r22
		state++;
    301e:	8f 5f       	subi	r24, 0xFF	; 255
		if (bit != tx_bit) {
    3020:	79 17       	cp	r23, r25
    3022:	91 f3       	breq	.-28     	; 0x3008 <__vector_13+0x3a>
			if (bit) {
				CONFIG_MATCH_SET();
    3024:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
		else
			bit = 1; // stopbit
		byte >>= 1;
		state++;
		if (bit != tx_bit) {
			if (bit) {
    3028:	77 23       	and	r23, r23
    302a:	11 f0       	breq	.+4      	; 0x3030 <__vector_13+0x62>
				CONFIG_MATCH_SET();
    302c:	90 6c       	ori	r25, 0xC0	; 192
    302e:	02 c0       	rjmp	.+4      	; 0x3034 <__vector_13+0x66>
			} else {
				CONFIG_MATCH_CLEAR();
    3030:	9f 7b       	andi	r25, 0xBF	; 191
    3032:	90 68       	ori	r25, 0x80	; 128
    3034:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
			}
			SET_COMPARE_A(target);
    3038:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    303c:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
			tx_bit = bit;
    3040:	70 93 e2 03 	sts	0x03E2, r23	; 0x8003e2 <_ZL6tx_bit>
			tx_byte = byte;
    3044:	60 93 e3 03 	sts	0x03E3, r22	; 0x8003e3 <_ZL7tx_byte>
    3048:	4a c0       	rjmp	.+148    	; 0x30de <__vector_13+0x110>
			tx_state = state;
			// TODO: how to detect timing_error?
			return;
		}
	}
	head = tx_buffer_head;
    304a:	90 91 e1 03 	lds	r25, 0x03E1	; 0x8003e1 <_ZL14tx_buffer_head>
	tail = tx_buffer_tail;
    304e:	e0 91 e0 03 	lds	r30, 0x03E0	; 0x8003e0 <_ZL14tx_buffer_tail>
	if (head == tail) {
    3052:	9e 13       	cpse	r25, r30
    3054:	19 c0       	rjmp	.+50     	; 0x3088 <__vector_13+0xba>
		if (state == 10) {
    3056:	8a 30       	cpi	r24, 0x0A	; 10
    3058:	51 f4       	brne	.+20     	; 0x306e <__vector_13+0xa0>
			// Wait for final stop bit to finish
			tx_state = 11;
    305a:	8b e0       	ldi	r24, 0x0B	; 11
    305c:	80 93 e4 03 	sts	0x03E4, r24	; 0x8003e4 <_ZL8tx_state>
			SET_COMPARE_A(target + ticks_per_bit);
    3060:	24 0f       	add	r18, r20
    3062:	35 1f       	adc	r19, r21
    3064:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    3068:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    306c:	3a c0       	rjmp	.+116    	; 0x30e2 <__vector_13+0x114>
		} else {
			tx_state = 0;
    306e:	10 92 e4 03 	sts	0x03E4, r1	; 0x8003e4 <_ZL8tx_state>
			CONFIG_MATCH_NORMAL();
    3072:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    3076:	8f 73       	andi	r24, 0x3F	; 63
    3078:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
			DISABLE_INT_COMPARE_A();
    307c:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    3080:	8d 7f       	andi	r24, 0xFD	; 253
    3082:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    3086:	2d c0       	rjmp	.+90     	; 0x30e2 <__vector_13+0x114>
		}
	} else {
		if (++tail >= TX_BUFFER_SIZE) tail = 0;
    3088:	ef 5f       	subi	r30, 0xFF	; 255
    308a:	e4 34       	cpi	r30, 0x44	; 68
    308c:	08 f0       	brcs	.+2      	; 0x3090 <__vector_13+0xc2>
    308e:	e0 e0       	ldi	r30, 0x00	; 0
		tx_buffer_tail = tail;
    3090:	e0 93 e0 03 	sts	0x03E0, r30	; 0x8003e0 <_ZL14tx_buffer_tail>
		tx_byte = tx_buffer[tail];
    3094:	f0 e0       	ldi	r31, 0x00	; 0
    3096:	e4 56       	subi	r30, 0x64	; 100
    3098:	fc 4f       	sbci	r31, 0xFC	; 252
    309a:	90 81       	ld	r25, Z
    309c:	90 93 e3 03 	sts	0x03E3, r25	; 0x8003e3 <_ZL7tx_byte>
		tx_bit = 0;
    30a0:	10 92 e2 03 	sts	0x03E2, r1	; 0x8003e2 <_ZL6tx_bit>
		CONFIG_MATCH_CLEAR();
    30a4:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    30a8:	9f 7b       	andi	r25, 0xBF	; 191
    30aa:	90 68       	ori	r25, 0x80	; 128
    30ac:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
		if (state == 10)
    30b0:	8a 30       	cpi	r24, 0x0A	; 10
    30b2:	59 f4       	brne	.+22     	; 0x30ca <__vector_13+0xfc>
			SET_COMPARE_A(target + ticks_per_bit);
    30b4:	80 91 3e 04 	lds	r24, 0x043E	; 0x80043e <_ZL13ticks_per_bit>
    30b8:	90 91 3f 04 	lds	r25, 0x043F	; 0x80043f <_ZL13ticks_per_bit+0x1>
    30bc:	28 0f       	add	r18, r24
    30be:	39 1f       	adc	r19, r25
    30c0:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    30c4:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    30c8:	09 c0       	rjmp	.+18     	; 0x30dc <__vector_13+0x10e>
		else
			SET_COMPARE_A(GET_TIMER_COUNT() + 16);
    30ca:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    30ce:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    30d2:	40 96       	adiw	r24, 0x10	; 16
    30d4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    30d8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
		tx_state = 1;
    30dc:	81 e0       	ldi	r24, 0x01	; 1
    30de:	80 93 e4 03 	sts	0x03E4, r24	; 0x8003e4 <_ZL8tx_state>
		// TODO: how to detect timing_error?
	}
}
    30e2:	ff 91       	pop	r31
    30e4:	ef 91       	pop	r30
    30e6:	9f 91       	pop	r25
    30e8:	8f 91       	pop	r24
    30ea:	7f 91       	pop	r23
    30ec:	6f 91       	pop	r22
    30ee:	5f 91       	pop	r21
    30f0:	4f 91       	pop	r20
    30f2:	3f 91       	pop	r19
    30f4:	2f 91       	pop	r18
    30f6:	0f 90       	pop	r0
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	0f 90       	pop	r0
    30fc:	1f 90       	pop	r1
    30fe:	18 95       	reti

00003100 <_ZN13AltSoftSerial11flushOutputEv>:

void AltSoftSerial::flushOutput(void)
{
	while (tx_state) /* wait */ ;
    3100:	80 91 e4 03 	lds	r24, 0x03E4	; 0x8003e4 <_ZL8tx_state>
    3104:	81 11       	cpse	r24, r1
    3106:	fc cf       	rjmp	.-8      	; 0x3100 <_ZN13AltSoftSerial11flushOutputEv>
}
    3108:	08 95       	ret

0000310a <_ZN13AltSoftSerial5flushEv>:
	void flush() { flushOutput(); }
    310a:	0c 94 80 18 	jmp	0x3100	; 0x3100 <_ZN13AltSoftSerial11flushOutputEv>

0000310e <__vector_12>:
/****************************************/
/**            Reception               **/
/****************************************/

ISR(CAPTURE_INTERRUPT)
{
    310e:	1f 92       	push	r1
    3110:	0f 92       	push	r0
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	0f 92       	push	r0
    3116:	11 24       	eor	r1, r1
    3118:	2f 93       	push	r18
    311a:	3f 93       	push	r19
    311c:	4f 93       	push	r20
    311e:	5f 93       	push	r21
    3120:	6f 93       	push	r22
    3122:	7f 93       	push	r23
    3124:	8f 93       	push	r24
    3126:	9f 93       	push	r25
    3128:	af 93       	push	r26
    312a:	bf 93       	push	r27
    312c:	ef 93       	push	r30
    312e:	ff 93       	push	r31
	uint8_t state, bit, head;
	uint16_t capture, target;
	uint16_t offset, offset_overflow;

	capture = GET_INPUT_CAPTURE();
    3130:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
    3134:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
	bit = rx_bit;
    3138:	40 91 3b 04 	lds	r20, 0x043B	; 0x80043b <_ZL6rx_bit>
	if (bit) {
		CONFIG_CAPTURE_FALLING_EDGE();
    313c:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	uint16_t capture, target;
	uint16_t offset, offset_overflow;

	capture = GET_INPUT_CAPTURE();
	bit = rx_bit;
	if (bit) {
    3140:	44 23       	and	r20, r20
    3142:	31 f0       	breq	.+12     	; 0x3150 <__vector_12+0x42>
		CONFIG_CAPTURE_FALLING_EDGE();
    3144:	2f 7b       	andi	r18, 0xBF	; 191
    3146:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
		rx_bit = 0;
    314a:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <_ZL6rx_bit>
    314e:	06 c0       	rjmp	.+12     	; 0x315c <__vector_12+0x4e>
	} else {
		CONFIG_CAPTURE_RISING_EDGE();
    3150:	20 64       	ori	r18, 0x40	; 64
    3152:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
		rx_bit = 0x80;
    3156:	20 e8       	ldi	r18, 0x80	; 128
    3158:	20 93 3b 04 	sts	0x043B, r18	; 0x80043b <_ZL6rx_bit>
	}
	state = rx_state;
    315c:	30 91 3d 04 	lds	r19, 0x043D	; 0x80043d <_ZL8rx_state>
	if (state == 0) {
    3160:	31 11       	cpse	r19, r1
    3162:	25 c0       	rjmp	.+74     	; 0x31ae <__vector_12+0xa0>
		if (!bit) {
    3164:	41 11       	cpse	r20, r1
    3166:	6c c0       	rjmp	.+216    	; 0x3240 <__vector_12+0x132>
			uint16_t end = capture + rx_stop_ticks;
    3168:	20 91 37 04 	lds	r18, 0x0437	; 0x800437 <_ZL13rx_stop_ticks>
    316c:	30 91 38 04 	lds	r19, 0x0438	; 0x800438 <_ZL13rx_stop_ticks+0x1>
    3170:	28 0f       	add	r18, r24
    3172:	39 1f       	adc	r19, r25
			SET_COMPARE_B(end);
    3174:	30 93 8b 00 	sts	0x008B, r19	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    3178:	20 93 8a 00 	sts	0x008A, r18	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
			ENABLE_INT_COMPARE_B();
    317c:	24 e0       	ldi	r18, 0x04	; 4
    317e:	26 bb       	out	0x16, r18	; 22
    3180:	20 91 6f 00 	lds	r18, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    3184:	24 60       	ori	r18, 0x04	; 4
    3186:	20 93 6f 00 	sts	0x006F, r18	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
			rx_target = capture + ticks_per_bit + ticks_per_bit/2;
    318a:	20 91 3e 04 	lds	r18, 0x043E	; 0x80043e <_ZL13ticks_per_bit>
    318e:	30 91 3f 04 	lds	r19, 0x043F	; 0x80043f <_ZL13ticks_per_bit+0x1>
    3192:	82 0f       	add	r24, r18
    3194:	93 1f       	adc	r25, r19
    3196:	36 95       	lsr	r19
    3198:	27 95       	ror	r18
    319a:	82 0f       	add	r24, r18
    319c:	93 1f       	adc	r25, r19
    319e:	90 93 3a 04 	sts	0x043A, r25	; 0x80043a <_ZL9rx_target+0x1>
    31a2:	80 93 39 04 	sts	0x0439, r24	; 0x800439 <_ZL9rx_target>
			rx_state = 1;
    31a6:	81 e0       	ldi	r24, 0x01	; 1
    31a8:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <_ZL8rx_state>
    31ac:	49 c0       	rjmp	.+146    	; 0x3240 <__vector_12+0x132>
		}
	} else {
		target = rx_target;
    31ae:	40 91 39 04 	lds	r20, 0x0439	; 0x800439 <_ZL9rx_target>
    31b2:	50 91 3a 04 	lds	r21, 0x043A	; 0x80043a <_ZL9rx_target+0x1>
		offset_overflow = 65535 - ticks_per_bit;
    31b6:	60 91 3e 04 	lds	r22, 0x043E	; 0x80043e <_ZL13ticks_per_bit>
    31ba:	70 91 3f 04 	lds	r23, 0x043F	; 0x80043f <_ZL13ticks_per_bit+0x1>
    31be:	db 01       	movw	r26, r22
    31c0:	a0 95       	com	r26
    31c2:	b0 95       	com	r27
		while (1) {
			offset = capture - target;
			if (offset > offset_overflow) break;
			rx_byte = (rx_byte >> 1) | rx_bit;
    31c4:	e0 91 3b 04 	lds	r30, 0x043B	; 0x80043b <_ZL6rx_bit>
    31c8:	20 91 3c 04 	lds	r18, 0x043C	; 0x80043c <_ZL7rx_byte>
    31cc:	84 1b       	sub	r24, r20
    31ce:	95 0b       	sbc	r25, r21
	} else {
		target = rx_target;
		offset_overflow = 65535 - ticks_per_bit;
		while (1) {
			offset = capture - target;
			if (offset > offset_overflow) break;
    31d0:	a8 17       	cp	r26, r24
    31d2:	b9 07       	cpc	r27, r25
    31d4:	68 f1       	brcs	.+90     	; 0x3230 <__vector_12+0x122>
			rx_byte = (rx_byte >> 1) | rx_bit;
    31d6:	26 95       	lsr	r18
    31d8:	2e 2b       	or	r18, r30
			target += ticks_per_bit;
    31da:	46 0f       	add	r20, r22
    31dc:	57 1f       	adc	r21, r23
			state++;
    31de:	3f 5f       	subi	r19, 0xFF	; 255
    31e0:	86 1b       	sub	r24, r22
    31e2:	97 0b       	sbc	r25, r23
			if (state >= 9) {
    31e4:	39 30       	cpi	r19, 0x09	; 9
    31e6:	a0 f3       	brcs	.-24     	; 0x31d0 <__vector_12+0xc2>
    31e8:	20 93 3c 04 	sts	0x043C, r18	; 0x80043c <_ZL7rx_byte>
				DISABLE_INT_COMPARE_B();
    31ec:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    31f0:	8b 7f       	andi	r24, 0xFB	; 251
    31f2:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
				head = rx_buffer_head + 1;
    31f6:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <_ZL14rx_buffer_head>
    31fa:	8f 5f       	subi	r24, 0xFF	; 255
				if (head >= RX_BUFFER_SIZE) head = 0;
    31fc:	80 35       	cpi	r24, 0x50	; 80
    31fe:	08 f0       	brcs	.+2      	; 0x3202 <__vector_12+0xf4>
    3200:	80 e0       	ldi	r24, 0x00	; 0
				if (head != rx_buffer_tail) {
    3202:	90 91 35 04 	lds	r25, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
    3206:	89 17       	cp	r24, r25
    3208:	49 f0       	breq	.+18     	; 0x321c <__vector_12+0x10e>
					rx_buffer[head] = rx_byte;
    320a:	e8 2f       	mov	r30, r24
    320c:	f0 e0       	ldi	r31, 0x00	; 0
    320e:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <_ZL7rx_byte>
    3212:	eb 51       	subi	r30, 0x1B	; 27
    3214:	fc 4f       	sbci	r31, 0xFC	; 252
    3216:	90 83       	st	Z, r25
					rx_buffer_head = head;
    3218:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <_ZL14rx_buffer_head>
				}
				CONFIG_CAPTURE_FALLING_EDGE();
    321c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    3220:	8f 7b       	andi	r24, 0xBF	; 191
    3222:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
				rx_bit = 0;
    3226:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <_ZL6rx_bit>
				rx_state = 0;
    322a:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <_ZL8rx_state>
				return;
    322e:	08 c0       	rjmp	.+16     	; 0x3240 <__vector_12+0x132>
    3230:	20 93 3c 04 	sts	0x043C, r18	; 0x80043c <_ZL7rx_byte>
			}
		}
		rx_target = target;
    3234:	50 93 3a 04 	sts	0x043A, r21	; 0x80043a <_ZL9rx_target+0x1>
    3238:	40 93 39 04 	sts	0x0439, r20	; 0x800439 <_ZL9rx_target>
		rx_state = state;
    323c:	30 93 3d 04 	sts	0x043D, r19	; 0x80043d <_ZL8rx_state>
	}
	//if (GET_TIMER_COUNT() - capture > ticks_per_bit) AltSoftSerial::timing_error = true;
}
    3240:	ff 91       	pop	r31
    3242:	ef 91       	pop	r30
    3244:	bf 91       	pop	r27
    3246:	af 91       	pop	r26
    3248:	9f 91       	pop	r25
    324a:	8f 91       	pop	r24
    324c:	7f 91       	pop	r23
    324e:	6f 91       	pop	r22
    3250:	5f 91       	pop	r21
    3252:	4f 91       	pop	r20
    3254:	3f 91       	pop	r19
    3256:	2f 91       	pop	r18
    3258:	0f 90       	pop	r0
    325a:	0f be       	out	0x3f, r0	; 63
    325c:	0f 90       	pop	r0
    325e:	1f 90       	pop	r1
    3260:	18 95       	reti

00003262 <__vector_14>:

ISR(COMPARE_B_INTERRUPT)
{
    3262:	1f 92       	push	r1
    3264:	0f 92       	push	r0
    3266:	0f b6       	in	r0, 0x3f	; 63
    3268:	0f 92       	push	r0
    326a:	11 24       	eor	r1, r1
    326c:	2f 93       	push	r18
    326e:	8f 93       	push	r24
    3270:	9f 93       	push	r25
    3272:	ef 93       	push	r30
    3274:	ff 93       	push	r31
	uint8_t head, state, bit;

	DISABLE_INT_COMPARE_B();
    3276:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    327a:	8b 7f       	andi	r24, 0xFB	; 251
    327c:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
	CONFIG_CAPTURE_FALLING_EDGE();
    3280:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    3284:	8f 7b       	andi	r24, 0xBF	; 191
    3286:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	state = rx_state;
    328a:	80 91 3d 04 	lds	r24, 0x043D	; 0x80043d <_ZL8rx_state>
	bit = rx_bit ^ 0x80;
    328e:	20 91 3b 04 	lds	r18, 0x043B	; 0x80043b <_ZL6rx_bit>
    3292:	20 58       	subi	r18, 0x80	; 128
    3294:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <_ZL7rx_byte>
	while (state < 9) {
    3298:	89 30       	cpi	r24, 0x09	; 9
    329a:	20 f4       	brcc	.+8      	; 0x32a4 <__vector_14+0x42>
		rx_byte = (rx_byte >> 1) | bit;
    329c:	96 95       	lsr	r25
    329e:	92 2b       	or	r25, r18
		state++;
    32a0:	8f 5f       	subi	r24, 0xFF	; 255

	DISABLE_INT_COMPARE_B();
	CONFIG_CAPTURE_FALLING_EDGE();
	state = rx_state;
	bit = rx_bit ^ 0x80;
	while (state < 9) {
    32a2:	fa cf       	rjmp	.-12     	; 0x3298 <__vector_14+0x36>
    32a4:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <_ZL7rx_byte>
		rx_byte = (rx_byte >> 1) | bit;
		state++;
	}
	head = rx_buffer_head + 1;
    32a8:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <_ZL14rx_buffer_head>
    32ac:	8f 5f       	subi	r24, 0xFF	; 255
	if (head >= RX_BUFFER_SIZE) head = 0;
    32ae:	80 35       	cpi	r24, 0x50	; 80
    32b0:	08 f0       	brcs	.+2      	; 0x32b4 <__vector_14+0x52>
    32b2:	80 e0       	ldi	r24, 0x00	; 0
	if (head != rx_buffer_tail) {
    32b4:	20 91 35 04 	lds	r18, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
    32b8:	82 17       	cp	r24, r18
    32ba:	39 f0       	breq	.+14     	; 0x32ca <__vector_14+0x68>
		rx_buffer[head] = rx_byte;
    32bc:	e8 2f       	mov	r30, r24
    32be:	f0 e0       	ldi	r31, 0x00	; 0
    32c0:	eb 51       	subi	r30, 0x1B	; 27
    32c2:	fc 4f       	sbci	r31, 0xFC	; 252
    32c4:	90 83       	st	Z, r25
		rx_buffer_head = head;
    32c6:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <_ZL14rx_buffer_head>
	}
	rx_state = 0;
    32ca:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <_ZL8rx_state>
	CONFIG_CAPTURE_FALLING_EDGE();
    32ce:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    32d2:	8f 7b       	andi	r24, 0xBF	; 191
    32d4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	rx_bit = 0;
    32d8:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <_ZL6rx_bit>
}
    32dc:	ff 91       	pop	r31
    32de:	ef 91       	pop	r30
    32e0:	9f 91       	pop	r25
    32e2:	8f 91       	pop	r24
    32e4:	2f 91       	pop	r18
    32e6:	0f 90       	pop	r0
    32e8:	0f be       	out	0x3f, r0	; 63
    32ea:	0f 90       	pop	r0
    32ec:	1f 90       	pop	r1
    32ee:	18 95       	reti

000032f0 <_ZN13AltSoftSerial10flushInputEv>:
	return RX_BUFFER_SIZE + head - tail;
}

void AltSoftSerial::flushInput(void)
{
	rx_buffer_head = rx_buffer_tail;
    32f0:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <_ZL14rx_buffer_tail>
    32f4:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <_ZL14rx_buffer_head>
    32f8:	08 95       	ret

000032fa <_ZN13AltSoftSerial3endEv>:
	tx_buffer_tail = 0;
	ENABLE_INT_INPUT_CAPTURE();
}

void AltSoftSerial::end(void)
{
    32fa:	cf 93       	push	r28
    32fc:	df 93       	push	r29
	DISABLE_INT_COMPARE_B();
    32fe:	cf e6       	ldi	r28, 0x6F	; 111
    3300:	d0 e0       	ldi	r29, 0x00	; 0
    3302:	88 81       	ld	r24, Y
    3304:	8b 7f       	andi	r24, 0xFB	; 251
    3306:	88 83       	st	Y, r24
	DISABLE_INT_INPUT_CAPTURE();
    3308:	88 81       	ld	r24, Y
    330a:	8f 7d       	andi	r24, 0xDF	; 223
    330c:	88 83       	st	Y, r24
	flushInput();
    330e:	0e 94 78 19 	call	0x32f0	; 0x32f0 <_ZN13AltSoftSerial10flushInputEv>
	flushOutput();
    3312:	0e 94 80 18 	call	0x3100	; 0x3100 <_ZN13AltSoftSerial11flushOutputEv>
	DISABLE_INT_COMPARE_A();
    3316:	88 81       	ld	r24, Y
    3318:	8d 7f       	andi	r24, 0xFD	; 253
    331a:	88 83       	st	Y, r24
	// TODO: restore timer to original settings?
}
    331c:	df 91       	pop	r29
    331e:	cf 91       	pop	r28
    3320:	08 95       	ret

00003322 <_ZN4CRGB7nscale8Eh>:
        heatcolor.g = 0; // no green
        heatcolor.b = 0; // no blue
    }

    return heatcolor;
}
    3322:	fc 01       	movw	r30, r24
    3324:	20 81       	ld	r18, Z
    3326:	26 9f       	mul	r18, r22
    3328:	02 0e       	add	r0, r18
    332a:	20 e0       	ldi	r18, 0x00	; 0
    332c:	21 1d       	adc	r18, r1
    332e:	20 83       	st	Z, r18
    3330:	21 81       	ldd	r18, Z+1	; 0x01
    3332:	26 9f       	mul	r18, r22
    3334:	02 0e       	add	r0, r18
    3336:	20 e0       	ldi	r18, 0x00	; 0
    3338:	21 1d       	adc	r18, r1
    333a:	21 83       	std	Z+1, r18	; 0x01
    333c:	22 81       	ldd	r18, Z+2	; 0x02
    333e:	26 9f       	mul	r18, r22
    3340:	02 0e       	add	r0, r18
    3342:	20 e0       	ldi	r18, 0x00	; 0
    3344:	21 1d       	adc	r18, r1
    3346:	22 83       	std	Z+2, r18	; 0x02
    3348:	11 24       	eor	r1, r1
    334a:	08 95       	ret

0000334c <_Z10fill_solidP4CRGBiRKS_>:
    334c:	da 01       	movw	r26, r20
    334e:	fc 01       	movw	r30, r24
    3350:	80 e0       	ldi	r24, 0x00	; 0
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	86 17       	cp	r24, r22
    3356:	97 07       	cpc	r25, r23
    3358:	6c f4       	brge	.+26     	; 0x3374 <_Z10fill_solidP4CRGBiRKS_+0x28>
    335a:	2c 91       	ld	r18, X
    335c:	20 83       	st	Z, r18
    335e:	11 96       	adiw	r26, 0x01	; 1
    3360:	2c 91       	ld	r18, X
    3362:	11 97       	sbiw	r26, 0x01	; 1
    3364:	21 83       	std	Z+1, r18	; 0x01
    3366:	12 96       	adiw	r26, 0x02	; 2
    3368:	2c 91       	ld	r18, X
    336a:	12 97       	sbiw	r26, 0x02	; 2
    336c:	22 83       	std	Z+2, r18	; 0x02
    336e:	01 96       	adiw	r24, 0x01	; 1
    3370:	33 96       	adiw	r30, 0x03	; 3
    3372:	f0 cf       	rjmp	.-32     	; 0x3354 <_Z10fill_solidP4CRGBiRKS_+0x8>
    3374:	08 95       	ret

00003376 <_Z12fill_rainbowP4CRGBihh>:
    3376:	af 92       	push	r10
    3378:	bf 92       	push	r11
    337a:	df 92       	push	r13
    337c:	ef 92       	push	r14
    337e:	ff 92       	push	r15
    3380:	0f 93       	push	r16
    3382:	1f 93       	push	r17
    3384:	cf 93       	push	r28
    3386:	df 93       	push	r29
    3388:	00 d0       	rcall	.+0      	; 0x338a <_Z12fill_rainbowP4CRGBihh+0x14>
    338a:	1f 92       	push	r1
    338c:	cd b7       	in	r28, 0x3d	; 61
    338e:	de b7       	in	r29, 0x3e	; 62
    3390:	5b 01       	movw	r10, r22
    3392:	d2 2e       	mov	r13, r18
    3394:	49 83       	std	Y+1, r20	; 0x01
    3396:	2f ef       	ldi	r18, 0xFF	; 255
    3398:	2b 83       	std	Y+3, r18	; 0x03
    339a:	20 ef       	ldi	r18, 0xF0	; 240
    339c:	2a 83       	std	Y+2, r18	; 0x02
    339e:	8c 01       	movw	r16, r24
    33a0:	e1 2c       	mov	r14, r1
    33a2:	f1 2c       	mov	r15, r1
    33a4:	ea 14       	cp	r14, r10
    33a6:	fb 04       	cpc	r15, r11
    33a8:	74 f4       	brge	.+28     	; 0x33c6 <_Z12fill_rainbowP4CRGBihh+0x50>
    33aa:	b8 01       	movw	r22, r16
    33ac:	ce 01       	movw	r24, r28
    33ae:	01 96       	adiw	r24, 0x01	; 1
    33b0:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>
    33b4:	89 81       	ldd	r24, Y+1	; 0x01
    33b6:	8d 0d       	add	r24, r13
    33b8:	89 83       	std	Y+1, r24	; 0x01
    33ba:	8f ef       	ldi	r24, 0xFF	; 255
    33bc:	e8 1a       	sub	r14, r24
    33be:	f8 0a       	sbc	r15, r24
    33c0:	0d 5f       	subi	r16, 0xFD	; 253
    33c2:	1f 4f       	sbci	r17, 0xFF	; 255
    33c4:	ef cf       	rjmp	.-34     	; 0x33a4 <_Z12fill_rainbowP4CRGBihh+0x2e>
    33c6:	0f 90       	pop	r0
    33c8:	0f 90       	pop	r0
    33ca:	0f 90       	pop	r0
    33cc:	df 91       	pop	r29
    33ce:	cf 91       	pop	r28
    33d0:	1f 91       	pop	r17
    33d2:	0f 91       	pop	r16
    33d4:	ff 90       	pop	r15
    33d6:	ef 90       	pop	r14
    33d8:	df 90       	pop	r13
    33da:	bf 90       	pop	r11
    33dc:	af 90       	pop	r10
    33de:	08 95       	ret

000033e0 <_Z17fill_gradient_RGBP4CRGBjS_jS_>:
    33e0:	5f 92       	push	r5
    33e2:	6f 92       	push	r6
    33e4:	7f 92       	push	r7
    33e6:	8f 92       	push	r8
    33e8:	9f 92       	push	r9
    33ea:	af 92       	push	r10
    33ec:	bf 92       	push	r11
    33ee:	cf 92       	push	r12
    33f0:	df 92       	push	r13
    33f2:	ef 92       	push	r14
    33f4:	ff 92       	push	r15
    33f6:	0f 93       	push	r16
    33f8:	1f 93       	push	r17
    33fa:	cf 93       	push	r28
    33fc:	df 93       	push	r29
    33fe:	3c 01       	movw	r6, r24
    3400:	fb 01       	movw	r30, r22
    3402:	ea 01       	movw	r28, r20
    3404:	d8 01       	movw	r26, r16
    3406:	26 17       	cp	r18, r22
    3408:	37 07       	cpc	r19, r23
    340a:	c0 f4       	brcc	.+48     	; 0x343c <_Z17fill_gradient_RGBP4CRGBjS_jS_+0x5c>
    340c:	4c 91       	ld	r20, X
    340e:	11 96       	adiw	r26, 0x01	; 1
    3410:	9c 91       	ld	r25, X
    3412:	11 97       	sbiw	r26, 0x01	; 1
    3414:	12 96       	adiw	r26, 0x02	; 2
    3416:	8c 91       	ld	r24, X
    3418:	12 97       	sbiw	r26, 0x02	; 2
    341a:	58 81       	ld	r21, Y
    341c:	5c 93       	st	X, r21
    341e:	59 81       	ldd	r21, Y+1	; 0x01
    3420:	11 96       	adiw	r26, 0x01	; 1
    3422:	5c 93       	st	X, r21
    3424:	11 97       	sbiw	r26, 0x01	; 1
    3426:	5a 81       	ldd	r21, Y+2	; 0x02
    3428:	12 96       	adiw	r26, 0x02	; 2
    342a:	5c 93       	st	X, r21
    342c:	12 97       	sbiw	r26, 0x02	; 2
    342e:	48 83       	st	Y, r20
    3430:	99 83       	std	Y+1, r25	; 0x01
    3432:	8a 83       	std	Y+2, r24	; 0x02
    3434:	8f 2f       	mov	r24, r31
    3436:	f9 01       	movw	r30, r18
    3438:	26 2f       	mov	r18, r22
    343a:	38 2f       	mov	r19, r24
    343c:	c8 80       	ld	r12, Y
    343e:	d1 2c       	mov	r13, r1
    3440:	8c 91       	ld	r24, X
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	8c 19       	sub	r24, r12
    3446:	9d 09       	sbc	r25, r13
    3448:	96 95       	lsr	r25
    344a:	98 2f       	mov	r25, r24
    344c:	88 27       	eor	r24, r24
    344e:	97 95       	ror	r25
    3450:	87 95       	ror	r24
    3452:	e9 80       	ldd	r14, Y+1	; 0x01
    3454:	f1 2c       	mov	r15, r1
    3456:	11 96       	adiw	r26, 0x01	; 1
    3458:	ac 90       	ld	r10, X
    345a:	11 97       	sbiw	r26, 0x01	; 1
    345c:	b1 2c       	mov	r11, r1
    345e:	ae 18       	sub	r10, r14
    3460:	bf 08       	sbc	r11, r15
    3462:	b6 94       	lsr	r11
    3464:	ba 2c       	mov	r11, r10
    3466:	aa 24       	eor	r10, r10
    3468:	b7 94       	ror	r11
    346a:	a7 94       	ror	r10
    346c:	ca 81       	ldd	r28, Y+2	; 0x02
    346e:	d0 e0       	ldi	r29, 0x00	; 0
    3470:	12 96       	adiw	r26, 0x02	; 2
    3472:	0c 91       	ld	r16, X
    3474:	10 e0       	ldi	r17, 0x00	; 0
    3476:	0c 1b       	sub	r16, r28
    3478:	1d 0b       	sbc	r17, r29
    347a:	16 95       	lsr	r17
    347c:	10 2f       	mov	r17, r16
    347e:	00 27       	eor	r16, r16
    3480:	17 95       	ror	r17
    3482:	07 95       	ror	r16
    3484:	a9 01       	movw	r20, r18
    3486:	4e 1b       	sub	r20, r30
    3488:	5f 0b       	sbc	r21, r31
    348a:	19 f0       	breq	.+6      	; 0x3492 <_Z17fill_gradient_RGBP4CRGBjS_jS_+0xb2>
    348c:	54 2e       	mov	r5, r20
    348e:	45 2f       	mov	r20, r21
    3490:	03 c0       	rjmp	.+6      	; 0x3498 <_Z17fill_gradient_RGBP4CRGBjS_jS_+0xb8>
    3492:	55 24       	eor	r5, r5
    3494:	53 94       	inc	r5
    3496:	40 e0       	ldi	r20, 0x00	; 0
    3498:	65 2d       	mov	r22, r5
    349a:	74 2f       	mov	r23, r20
    349c:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    34a0:	4b 01       	movw	r8, r22
    34a2:	c5 01       	movw	r24, r10
    34a4:	65 2d       	mov	r22, r5
    34a6:	74 2f       	mov	r23, r20
    34a8:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    34ac:	5b 01       	movw	r10, r22
    34ae:	c8 01       	movw	r24, r16
    34b0:	65 2d       	mov	r22, r5
    34b2:	74 2f       	mov	r23, r20
    34b4:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <__divmodhi4>
    34b8:	88 0c       	add	r8, r8
    34ba:	99 1c       	adc	r9, r9
    34bc:	aa 0c       	add	r10, r10
    34be:	bb 1c       	adc	r11, r11
    34c0:	66 0f       	add	r22, r22
    34c2:	77 1f       	adc	r23, r23
    34c4:	dc 2c       	mov	r13, r12
    34c6:	cc 24       	eor	r12, r12
    34c8:	fe 2c       	mov	r15, r14
    34ca:	ee 24       	eor	r14, r14
    34cc:	dc 2f       	mov	r29, r28
    34ce:	cc 27       	eor	r28, r28
    34d0:	df 01       	movw	r26, r30
    34d2:	aa 0f       	add	r26, r26
    34d4:	bb 1f       	adc	r27, r27
    34d6:	ae 0f       	add	r26, r30
    34d8:	bf 1f       	adc	r27, r31
    34da:	a6 0d       	add	r26, r6
    34dc:	b7 1d       	adc	r27, r7
    34de:	2e 17       	cp	r18, r30
    34e0:	3f 07       	cpc	r19, r31
    34e2:	80 f0       	brcs	.+32     	; 0x3504 <_Z17fill_gradient_RGBP4CRGBjS_jS_+0x124>
    34e4:	dc 92       	st	X, r13
    34e6:	11 96       	adiw	r26, 0x01	; 1
    34e8:	fc 92       	st	X, r15
    34ea:	11 97       	sbiw	r26, 0x01	; 1
    34ec:	12 96       	adiw	r26, 0x02	; 2
    34ee:	dc 93       	st	X, r29
    34f0:	12 97       	sbiw	r26, 0x02	; 2
    34f2:	c8 0c       	add	r12, r8
    34f4:	d9 1c       	adc	r13, r9
    34f6:	ea 0c       	add	r14, r10
    34f8:	fb 1c       	adc	r15, r11
    34fa:	c6 0f       	add	r28, r22
    34fc:	d7 1f       	adc	r29, r23
    34fe:	31 96       	adiw	r30, 0x01	; 1
    3500:	13 96       	adiw	r26, 0x03	; 3
    3502:	ed cf       	rjmp	.-38     	; 0x34de <_Z17fill_gradient_RGBP4CRGBjS_jS_+0xfe>
    3504:	df 91       	pop	r29
    3506:	cf 91       	pop	r28
    3508:	1f 91       	pop	r17
    350a:	0f 91       	pop	r16
    350c:	ff 90       	pop	r15
    350e:	ef 90       	pop	r14
    3510:	df 90       	pop	r13
    3512:	cf 90       	pop	r12
    3514:	bf 90       	pop	r11
    3516:	af 90       	pop	r10
    3518:	9f 90       	pop	r9
    351a:	8f 90       	pop	r8
    351c:	7f 90       	pop	r7
    351e:	6f 90       	pop	r6
    3520:	5f 90       	pop	r5
    3522:	08 95       	ret

00003524 <_Z17fill_gradient_RGBP4CRGBjRKS_S2_S2_S2_>:
    3524:	2f 92       	push	r2
    3526:	3f 92       	push	r3
    3528:	4f 92       	push	r4
    352a:	5f 92       	push	r5
    352c:	6f 92       	push	r6
    352e:	7f 92       	push	r7
    3530:	8f 92       	push	r8
    3532:	9f 92       	push	r9
    3534:	af 92       	push	r10
    3536:	bf 92       	push	r11
    3538:	cf 92       	push	r12
    353a:	df 92       	push	r13
    353c:	ef 92       	push	r14
    353e:	ff 92       	push	r15
    3540:	0f 93       	push	r16
    3542:	1f 93       	push	r17
    3544:	cf 93       	push	r28
    3546:	df 93       	push	r29
    3548:	00 d0       	rcall	.+0      	; 0x354a <_Z17fill_gradient_RGBP4CRGBjRKS_S2_S2_S2_+0x26>
    354a:	00 d0       	rcall	.+0      	; 0x354c <_Z17fill_gradient_RGBP4CRGBjRKS_S2_S2_S2_+0x28>
    354c:	00 d0       	rcall	.+0      	; 0x354e <_Z17fill_gradient_RGBP4CRGBjRKS_S2_S2_S2_+0x2a>
    354e:	cd b7       	in	r28, 0x3d	; 61
    3550:	de b7       	in	r29, 0x3e	; 62
    3552:	3c 01       	movw	r6, r24
    3554:	4b 01       	movw	r8, r22
    3556:	fa 01       	movw	r30, r20
    3558:	59 01       	movw	r10, r18
    355a:	68 01       	movw	r12, r16
    355c:	17 01       	movw	r2, r14
    355e:	23 e0       	ldi	r18, 0x03	; 3
    3560:	30 e0       	ldi	r19, 0x00	; 0
    3562:	cb 01       	movw	r24, r22
    3564:	b9 01       	movw	r22, r18
    3566:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <__udivmodhi4>
    356a:	7b 01       	movw	r14, r22
    356c:	c4 01       	movw	r24, r8
    356e:	88 0f       	add	r24, r24
    3570:	99 1f       	adc	r25, r25
    3572:	b9 01       	movw	r22, r18
    3574:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <__udivmodhi4>
    3578:	2b 01       	movw	r4, r22
    357a:	d5 01       	movw	r26, r10
    357c:	8c 91       	ld	r24, X
    357e:	89 83       	std	Y+1, r24	; 0x01
    3580:	11 96       	adiw	r26, 0x01	; 1
    3582:	8c 91       	ld	r24, X
    3584:	11 97       	sbiw	r26, 0x01	; 1
    3586:	8a 83       	std	Y+2, r24	; 0x02
    3588:	12 96       	adiw	r26, 0x02	; 2
    358a:	8c 91       	ld	r24, X
    358c:	8b 83       	std	Y+3, r24	; 0x03
    358e:	80 81       	ld	r24, Z
    3590:	8c 83       	std	Y+4, r24	; 0x04
    3592:	81 81       	ldd	r24, Z+1	; 0x01
    3594:	8d 83       	std	Y+5, r24	; 0x05
    3596:	82 81       	ldd	r24, Z+2	; 0x02
    3598:	8e 83       	std	Y+6, r24	; 0x06
    359a:	8e 01       	movw	r16, r28
    359c:	0f 5f       	subi	r16, 0xFF	; 255
    359e:	1f 4f       	sbci	r17, 0xFF	; 255
    35a0:	97 01       	movw	r18, r14
    35a2:	ae 01       	movw	r20, r28
    35a4:	4c 5f       	subi	r20, 0xFC	; 252
    35a6:	5f 4f       	sbci	r21, 0xFF	; 255
    35a8:	60 e0       	ldi	r22, 0x00	; 0
    35aa:	70 e0       	ldi	r23, 0x00	; 0
    35ac:	c3 01       	movw	r24, r6
    35ae:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_Z17fill_gradient_RGBP4CRGBjS_jS_>
    35b2:	f6 01       	movw	r30, r12
    35b4:	80 81       	ld	r24, Z
    35b6:	89 83       	std	Y+1, r24	; 0x01
    35b8:	81 81       	ldd	r24, Z+1	; 0x01
    35ba:	8a 83       	std	Y+2, r24	; 0x02
    35bc:	82 81       	ldd	r24, Z+2	; 0x02
    35be:	8b 83       	std	Y+3, r24	; 0x03
    35c0:	d5 01       	movw	r26, r10
    35c2:	8c 91       	ld	r24, X
    35c4:	8c 83       	std	Y+4, r24	; 0x04
    35c6:	11 96       	adiw	r26, 0x01	; 1
    35c8:	8c 91       	ld	r24, X
    35ca:	11 97       	sbiw	r26, 0x01	; 1
    35cc:	8d 83       	std	Y+5, r24	; 0x05
    35ce:	12 96       	adiw	r26, 0x02	; 2
    35d0:	8c 91       	ld	r24, X
    35d2:	8e 83       	std	Y+6, r24	; 0x06
    35d4:	92 01       	movw	r18, r4
    35d6:	ae 01       	movw	r20, r28
    35d8:	4c 5f       	subi	r20, 0xFC	; 252
    35da:	5f 4f       	sbci	r21, 0xFF	; 255
    35dc:	b7 01       	movw	r22, r14
    35de:	c3 01       	movw	r24, r6
    35e0:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_Z17fill_gradient_RGBP4CRGBjS_jS_>
    35e4:	f1 01       	movw	r30, r2
    35e6:	80 81       	ld	r24, Z
    35e8:	89 83       	std	Y+1, r24	; 0x01
    35ea:	81 81       	ldd	r24, Z+1	; 0x01
    35ec:	8a 83       	std	Y+2, r24	; 0x02
    35ee:	82 81       	ldd	r24, Z+2	; 0x02
    35f0:	8b 83       	std	Y+3, r24	; 0x03
    35f2:	d6 01       	movw	r26, r12
    35f4:	8c 91       	ld	r24, X
    35f6:	8c 83       	std	Y+4, r24	; 0x04
    35f8:	11 96       	adiw	r26, 0x01	; 1
    35fa:	8c 91       	ld	r24, X
    35fc:	11 97       	sbiw	r26, 0x01	; 1
    35fe:	8d 83       	std	Y+5, r24	; 0x05
    3600:	12 96       	adiw	r26, 0x02	; 2
    3602:	8c 91       	ld	r24, X
    3604:	8e 83       	std	Y+6, r24	; 0x06
    3606:	94 01       	movw	r18, r8
    3608:	21 50       	subi	r18, 0x01	; 1
    360a:	31 09       	sbc	r19, r1
    360c:	ae 01       	movw	r20, r28
    360e:	4c 5f       	subi	r20, 0xFC	; 252
    3610:	5f 4f       	sbci	r21, 0xFF	; 255
    3612:	b2 01       	movw	r22, r4
    3614:	c3 01       	movw	r24, r6
    3616:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_Z17fill_gradient_RGBP4CRGBjS_jS_>
    361a:	26 96       	adiw	r28, 0x06	; 6
    361c:	0f b6       	in	r0, 0x3f	; 63
    361e:	f8 94       	cli
    3620:	de bf       	out	0x3e, r29	; 62
    3622:	0f be       	out	0x3f, r0	; 63
    3624:	cd bf       	out	0x3d, r28	; 61
    3626:	df 91       	pop	r29
    3628:	cf 91       	pop	r28
    362a:	1f 91       	pop	r17
    362c:	0f 91       	pop	r16
    362e:	ff 90       	pop	r15
    3630:	ef 90       	pop	r14
    3632:	df 90       	pop	r13
    3634:	cf 90       	pop	r12
    3636:	bf 90       	pop	r11
    3638:	af 90       	pop	r10
    363a:	9f 90       	pop	r9
    363c:	8f 90       	pop	r8
    363e:	7f 90       	pop	r7
    3640:	6f 90       	pop	r6
    3642:	5f 90       	pop	r5
    3644:	4f 90       	pop	r4
    3646:	3f 90       	pop	r3
    3648:	2f 90       	pop	r2
    364a:	08 95       	ret

0000364c <_Z7nscale8P4CRGBjh>:
    364c:	cf 92       	push	r12
    364e:	df 92       	push	r13
    3650:	ff 92       	push	r15
    3652:	0f 93       	push	r16
    3654:	1f 93       	push	r17
    3656:	cf 93       	push	r28
    3658:	df 93       	push	r29
    365a:	6b 01       	movw	r12, r22
    365c:	f4 2e       	mov	r15, r20
    365e:	ec 01       	movw	r28, r24
    3660:	00 e0       	ldi	r16, 0x00	; 0
    3662:	10 e0       	ldi	r17, 0x00	; 0
    3664:	0c 15       	cp	r16, r12
    3666:	1d 05       	cpc	r17, r13
    3668:	41 f0       	breq	.+16     	; 0x367a <_Z7nscale8P4CRGBjh+0x2e>
    366a:	6f 2d       	mov	r22, r15
    366c:	ce 01       	movw	r24, r28
    366e:	0e 94 91 19 	call	0x3322	; 0x3322 <_ZN4CRGB7nscale8Eh>
    3672:	0f 5f       	subi	r16, 0xFF	; 255
    3674:	1f 4f       	sbci	r17, 0xFF	; 255
    3676:	23 96       	adiw	r28, 0x03	; 3
    3678:	f5 cf       	rjmp	.-22     	; 0x3664 <_Z7nscale8P4CRGBjh+0x18>
    367a:	df 91       	pop	r29
    367c:	cf 91       	pop	r28
    367e:	1f 91       	pop	r17
    3680:	0f 91       	pop	r16
    3682:	ff 90       	pop	r15
    3684:	df 90       	pop	r13
    3686:	cf 90       	pop	r12
    3688:	08 95       	ret

0000368a <_Z8fade_rawP4CRGBjh>:
    368a:	40 95       	com	r20
    368c:	0c 94 26 1b 	jmp	0x364c	; 0x364c <_Z7nscale8P4CRGBjh>

00003690 <_Z13fadeToBlackByP4CRGBjh>:
    3690:	0c 94 45 1b 	jmp	0x368a	; 0x368a <_Z8fade_rawP4CRGBjh>

00003694 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType>:
    return dividend;
}


CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
    3694:	0f 93       	push	r16
    3696:	1f 93       	push	r17
    3698:	cf 93       	push	r28
    369a:	df 93       	push	r29
    369c:	fc 01       	movw	r30, r24
{
#if defined(__AVR__)
    dividend /= 2;
    dividend /= 2;
    dividend /= 2;
    dividend /= 2;
    369e:	84 2f       	mov	r24, r20
    36a0:	82 95       	swap	r24
    36a2:	8f 70       	andi	r24, 0x0F	; 15

CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
    //      hi4 = index >> 4;
    uint8_t hi4 = lsrX4(index);
    uint8_t lo4 = index & 0x0F;
    36a4:	4f 70       	andi	r20, 0x0F	; 15
    {
        return entries[(uint8_t)x];
    }
    inline const CRGB& operator[] (int x) const __attribute__((always_inline))
    {
        return entries[(uint8_t)x];
    36a6:	db 01       	movw	r26, r22
    // since hi4 is always 0..15, hi4 * sizeof(CRGB) can be a single-byte value,
    // instead of the two byte 'int' that avr-gcc defaults to.
    // So, we multiply hi4 X sizeof(CRGB), giving hi4XsizeofCRGB;
    uint8_t hi4XsizeofCRGB = hi4 * sizeof(CRGB);
    // We then add that to a base array pointer.
    const CRGB* entry = (CRGB*)( (uint8_t*)(&(pal[0])) + hi4XsizeofCRGB);
    36a8:	98 2f       	mov	r25, r24
    36aa:	99 0f       	add	r25, r25
    36ac:	98 0f       	add	r25, r24
    36ae:	eb 01       	movw	r28, r22
    36b0:	c9 0f       	add	r28, r25
    36b2:	d1 1d       	adc	r29, r1
    
    uint8_t blend = lo4 && (blendType != NOBLEND);
    36b4:	44 23       	and	r20, r20
    36b6:	19 f0       	breq	.+6      	; 0x36be <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0x2a>
    36b8:	31 e0       	ldi	r19, 0x01	; 1
    36ba:	01 11       	cpse	r16, r1
    36bc:	01 c0       	rjmp	.+2      	; 0x36c0 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0x2c>
    36be:	30 e0       	ldi	r19, 0x00	; 0
    
    uint8_t red1   = entry->red;
    36c0:	68 81       	ld	r22, Y
    uint8_t green1 = entry->green;
    36c2:	59 81       	ldd	r21, Y+1	; 0x01
    uint8_t blue1  = entry->blue;
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
    
    
    if( blend ) {
    36c6:	33 23       	and	r19, r19
    36c8:	09 f4       	brne	.+2      	; 0x36cc <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0x38>
    36ca:	2c c0       	rjmp	.+88     	; 0x3724 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0x90>
        
        if( hi4 == 15 ) {
    36cc:	8f 30       	cpi	r24, 0x0F	; 15
    36ce:	11 f0       	breq	.+4      	; 0x36d4 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0x40>
            entry = &(pal[0]);
        } else {
            entry++;
    36d0:	de 01       	movw	r26, r28
    36d2:	13 96       	adiw	r26, 0x03	; 3
        }
        
        uint8_t f2 = lo4 << 4;
    36d4:	42 95       	swap	r20
    36d6:	40 7f       	andi	r20, 0xF0	; 240
        uint8_t f1 = 255 - f2;
    36d8:	14 2f       	mov	r17, r20
    36da:	10 95       	com	r17
        
        //    rgb1.nscale8(f1);
        uint8_t red2   = entry->red;
    36dc:	3c 91       	ld	r19, X
         /* R1 IS LEFT DIRTY HERE; YOU MUST ZERO IT OUT YOURSELF  */
         /* "clr __zero_reg__    \n\t" */

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    36de:	61 9f       	mul	r22, r17
    36e0:	06 0e       	add	r0, r22
    36e2:	60 e0       	ldi	r22, 0x00	; 0
    36e4:	61 1d       	adc	r22, r1
    36e6:	34 9f       	mul	r19, r20
    36e8:	03 0e       	add	r0, r19
    36ea:	30 e0       	ldi	r19, 0x00	; 0
    36ec:	31 1d       	adc	r19, r1
        red1   = scale8_LEAVING_R1_DIRTY( red1,   f1);
        red2   = scale8_LEAVING_R1_DIRTY( red2,   f2);
        red1   += red2;
    36ee:	63 0f       	add	r22, r19

        uint8_t green2 = entry->green;
    36f0:	11 96       	adiw	r26, 0x01	; 1
    36f2:	3c 91       	ld	r19, X
    36f4:	11 97       	sbiw	r26, 0x01	; 1
    36f6:	51 9f       	mul	r21, r17
    36f8:	05 0e       	add	r0, r21
    36fa:	50 e0       	ldi	r21, 0x00	; 0
    36fc:	51 1d       	adc	r21, r1
    36fe:	34 9f       	mul	r19, r20
    3700:	03 0e       	add	r0, r19
    3702:	30 e0       	ldi	r19, 0x00	; 0
    3704:	31 1d       	adc	r19, r1
        green1 = scale8_LEAVING_R1_DIRTY( green1, f1);
        green2 = scale8_LEAVING_R1_DIRTY( green2, f2);
        green1 += green2;
    3706:	53 0f       	add	r21, r19

        uint8_t blue2  = entry->blue;
    3708:	12 96       	adiw	r26, 0x02	; 2
    370a:	7c 91       	ld	r23, X
    370c:	39 2f       	mov	r19, r25
    370e:	31 9f       	mul	r19, r17
    3710:	03 0e       	add	r0, r19
    3712:	30 e0       	ldi	r19, 0x00	; 0
    3714:	31 1d       	adc	r19, r1
    3716:	74 9f       	mul	r23, r20
    3718:	07 0e       	add	r0, r23
    371a:	70 e0       	ldi	r23, 0x00	; 0
    371c:	71 1d       	adc	r23, r1
        blue1  = scale8_LEAVING_R1_DIRTY( blue1,  f1);
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);
        blue1  += blue2;
    371e:	93 2f       	mov	r25, r19
    3720:	97 0f       	add	r25, r23
/// Clean up the r1 register after a series of *LEAVING_R1_DIRTY calls
LIB8STATIC_ALWAYS_INLINE void cleanup_R1()
{
#if CLEANUP_R1_AVRASM == 1
    // Restore r1 to "0"; it's expected to always be that
    asm volatile( "clr __zero_reg__  \n\t" : : : "r1" );
    3722:	11 24       	eor	r1, r1
        
        cleanup_R1();
    }
    
    if( brightness != 255) {
    3724:	2f 3f       	cpi	r18, 0xFF	; 255
    3726:	e1 f0       	breq	.+56     	; 0x3760 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xcc>
        if( brightness ) {
    3728:	22 23       	and	r18, r18
    372a:	b9 f0       	breq	.+46     	; 0x375a <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xc6>
            brightness++; // adjust for rounding
    372c:	2f 5f       	subi	r18, 0xFF	; 255
            // Now, since brightness is nonzero, we don't need the full scale8_video logic;
            // we can just to scale8 and then add one (unless scale8 fixed) to all nonzero inputs.
            if( red1 )   {
    372e:	66 23       	and	r22, r22
    3730:	21 f0       	breq	.+8      	; 0x373a <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xa6>
         /* R1 IS LEFT DIRTY HERE; YOU MUST ZERO IT OUT YOURSELF  */
         /* "clr __zero_reg__    \n\t" */

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    3732:	62 9f       	mul	r22, r18
    3734:	06 0e       	add	r0, r22
    3736:	60 e0       	ldi	r22, 0x00	; 0
    3738:	61 1d       	adc	r22, r1
                red1 = scale8_LEAVING_R1_DIRTY( red1, brightness);
#if !(FASTLED_SCALE8_FIXED==1)
                red1++;
#endif
            }
            if( green1 ) {
    373a:	55 23       	and	r21, r21
    373c:	21 f0       	breq	.+8      	; 0x3746 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xb2>
    373e:	52 9f       	mul	r21, r18
    3740:	05 0e       	add	r0, r21
    3742:	50 e0       	ldi	r21, 0x00	; 0
    3744:	51 1d       	adc	r21, r1
                green1 = scale8_LEAVING_R1_DIRTY( green1, brightness);
#if !(FASTLED_SCALE8_FIXED==1)
                green1++;
#endif
            }
            if( blue1 )  {
    3746:	99 23       	and	r25, r25
    3748:	31 f0       	breq	.+12     	; 0x3756 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xc2>
    374a:	39 2f       	mov	r19, r25
    374c:	32 9f       	mul	r19, r18
    374e:	03 0e       	add	r0, r19
    3750:	30 e0       	ldi	r19, 0x00	; 0
    3752:	31 1d       	adc	r19, r1
    3754:	93 2f       	mov	r25, r19
/// Clean up the r1 register after a series of *LEAVING_R1_DIRTY calls
LIB8STATIC_ALWAYS_INLINE void cleanup_R1()
{
#if CLEANUP_R1_AVRASM == 1
    // Restore r1 to "0"; it's expected to always be that
    asm volatile( "clr __zero_reg__  \n\t" : : : "r1" );
    3756:	11 24       	eor	r1, r1
    3758:	03 c0       	rjmp	.+6      	; 0x3760 <_Z16ColorFromPaletteRK13CRGBPalette16hh10TBlendType+0xcc>
            }
            cleanup_R1();
        } else {
            red1 = 0;
            green1 = 0;
            blue1 = 0;
    375a:	90 e0       	ldi	r25, 0x00	; 0
#endif
            }
            cleanup_R1();
        } else {
            red1 = 0;
            green1 = 0;
    375c:	50 e0       	ldi	r21, 0x00	; 0
                blue1++;
#endif
            }
            cleanup_R1();
        } else {
            red1 = 0;
    375e:	60 e0       	ldi	r22, 0x00	; 0
    {
    }

    /// allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
    3760:	60 83       	st	Z, r22
    3762:	51 83       	std	Z+1, r21	; 0x01
    3764:	92 83       	std	Z+2, r25	; 0x02
            blue1 = 0;
        }
    }
    
    return CRGB( red1, green1, blue1);
}
    3766:	cf 01       	movw	r24, r30
    3768:	df 91       	pop	r29
    376a:	cf 91       	pop	r28
    376c:	1f 91       	pop	r17
    376e:	0f 91       	pop	r16
    3770:	08 95       	ret

00003772 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>:
  } else {
    m_nMinMicros = 0;
  }
}

extern "C" int atexit(void (* /*func*/ )()) { return 0; }
    3772:	8f 92       	push	r8
    3774:	9f 92       	push	r9
    3776:	af 92       	push	r10
    3778:	bf 92       	push	r11
    377a:	cf 92       	push	r12
    377c:	df 92       	push	r13
    377e:	ef 92       	push	r14
    3780:	ff 92       	push	r15
    3782:	0f 93       	push	r16
    3784:	1f 93       	push	r17
    3786:	cf 93       	push	r28
    3788:	df 93       	push	r29
    378a:	ec 01       	movw	r28, r24
    378c:	18 82       	st	Y, r1
    378e:	19 82       	std	Y+1, r1	; 0x01
    3790:	1a 82       	std	Y+2, r1	; 0x02
    3792:	66 23       	and	r22, r22
    3794:	c1 f1       	breq	.+112    	; 0x3806 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x94>
    3796:	fa 01       	movw	r30, r20
    3798:	89 01       	movw	r16, r18
    379a:	7c 01       	movw	r14, r24
    379c:	6a 01       	movw	r12, r20
    379e:	83 e0       	ldi	r24, 0x03	; 3
    37a0:	c8 0e       	add	r12, r24
    37a2:	d1 1c       	adc	r13, r1
    37a4:	86 2e       	mov	r8, r22
    37a6:	91 2c       	mov	r9, r1
    37a8:	a1 2c       	mov	r10, r1
    37aa:	b1 2c       	mov	r11, r1
    37ac:	21 91       	ld	r18, Z+
    37ae:	22 23       	and	r18, r18
    37b0:	11 f1       	breq	.+68     	; 0x37f6 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
    37b2:	d8 01       	movw	r26, r16
    37b4:	6c 91       	ld	r22, X
    37b6:	66 23       	and	r22, r22
    37b8:	f1 f0       	breq	.+60     	; 0x37f6 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
    37ba:	82 2f       	mov	r24, r18
    37bc:	90 e0       	ldi	r25, 0x00	; 0
    37be:	a0 e0       	ldi	r26, 0x00	; 0
    37c0:	b0 e0       	ldi	r27, 0x00	; 0
    37c2:	9c 01       	movw	r18, r24
    37c4:	ad 01       	movw	r20, r26
    37c6:	2f 5f       	subi	r18, 0xFF	; 255
    37c8:	3f 4f       	sbci	r19, 0xFF	; 255
    37ca:	4f 4f       	sbci	r20, 0xFF	; 255
    37cc:	5f 4f       	sbci	r21, 0xFF	; 255
    37ce:	86 2f       	mov	r24, r22
    37d0:	90 e0       	ldi	r25, 0x00	; 0
    37d2:	a0 e0       	ldi	r26, 0x00	; 0
    37d4:	b0 e0       	ldi	r27, 0x00	; 0
    37d6:	bc 01       	movw	r22, r24
    37d8:	cd 01       	movw	r24, r26
    37da:	6f 5f       	subi	r22, 0xFF	; 255
    37dc:	7f 4f       	sbci	r23, 0xFF	; 255
    37de:	8f 4f       	sbci	r24, 0xFF	; 255
    37e0:	9f 4f       	sbci	r25, 0xFF	; 255
    37e2:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <__mulsi3>
    37e6:	9b 01       	movw	r18, r22
    37e8:	ac 01       	movw	r20, r24
    37ea:	c5 01       	movw	r24, r10
    37ec:	b4 01       	movw	r22, r8
    37ee:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <__mulsi3>
    37f2:	d7 01       	movw	r26, r14
    37f4:	8c 93       	st	X, r24
    37f6:	0f 5f       	subi	r16, 0xFF	; 255
    37f8:	1f 4f       	sbci	r17, 0xFF	; 255
    37fa:	bf ef       	ldi	r27, 0xFF	; 255
    37fc:	eb 1a       	sub	r14, r27
    37fe:	fb 0a       	sbc	r15, r27
    3800:	ec 15       	cp	r30, r12
    3802:	fd 05       	cpc	r31, r13
    3804:	99 f6       	brne	.-90     	; 0x37ac <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x3a>
    3806:	ce 01       	movw	r24, r28
    3808:	df 91       	pop	r29
    380a:	cf 91       	pop	r28
    380c:	1f 91       	pop	r17
    380e:	0f 91       	pop	r16
    3810:	ff 90       	pop	r15
    3812:	ef 90       	pop	r14
    3814:	df 90       	pop	r13
    3816:	cf 90       	pop	r12
    3818:	bf 90       	pop	r11
    381a:	af 90       	pop	r10
    381c:	9f 90       	pop	r9
    381e:	8f 90       	pop	r8
    3820:	08 95       	ret

00003822 <_ZN8CFastLEDC1Ev>:
    3822:	fc 01       	movw	r30, r24
    3824:	8f ef       	ldi	r24, 0xFF	; 255
    3826:	80 83       	st	Z, r24
    3828:	12 82       	std	Z+2, r1	; 0x02
    382a:	11 82       	std	Z+1, r1	; 0x01
    382c:	14 86       	std	Z+12, r1	; 0x0c
    382e:	13 86       	std	Z+11, r1	; 0x0b
    3830:	8f ef       	ldi	r24, 0xFF	; 255
    3832:	9f ef       	ldi	r25, 0xFF	; 255
    3834:	dc 01       	movw	r26, r24
    3836:	87 83       	std	Z+7, r24	; 0x07
    3838:	90 87       	std	Z+8, r25	; 0x08
    383a:	a1 87       	std	Z+9, r26	; 0x09
    383c:	b2 87       	std	Z+10, r27	; 0x0a
    383e:	08 95       	ret

00003840 <_ZN8CFastLED8countFPSEi>:
    3840:	cf 92       	push	r12
    3842:	df 92       	push	r13
    3844:	ef 92       	push	r14
    3846:	ff 92       	push	r15
    3848:	0f 93       	push	r16
    384a:	1f 93       	push	r17
    384c:	cf 93       	push	r28
    384e:	df 93       	push	r29
    3850:	20 91 44 04 	lds	r18, 0x0444	; 0x800444 <_ZZN8CFastLED8countFPSEiE2br>
    3854:	30 91 45 04 	lds	r19, 0x0445	; 0x800445 <_ZZN8CFastLED8countFPSEiE2br+0x1>
    3858:	a9 01       	movw	r20, r18
    385a:	4f 5f       	subi	r20, 0xFF	; 255
    385c:	5f 4f       	sbci	r21, 0xFF	; 255
    385e:	50 93 45 04 	sts	0x0445, r21	; 0x800445 <_ZZN8CFastLED8countFPSEiE2br+0x1>
    3862:	40 93 44 04 	sts	0x0444, r20	; 0x800444 <_ZZN8CFastLED8countFPSEiE2br>
    3866:	26 17       	cp	r18, r22
    3868:	37 07       	cpc	r19, r23
    386a:	b4 f1       	brlt	.+108    	; 0x38d8 <_ZN8CFastLED8countFPSEi+0x98>
    386c:	ec 01       	movw	r28, r24
    386e:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    3872:	8b 01       	movw	r16, r22
    3874:	9c 01       	movw	r18, r24
    3876:	e0 91 44 04 	lds	r30, 0x0444	; 0x800444 <_ZZN8CFastLED8countFPSEiE2br>
    387a:	f0 91 45 04 	lds	r31, 0x0445	; 0x800445 <_ZZN8CFastLED8countFPSEiE2br+0x1>
    387e:	88 ee       	ldi	r24, 0xE8	; 232
    3880:	93 e0       	ldi	r25, 0x03	; 3
    3882:	e8 9f       	mul	r30, r24
    3884:	b0 01       	movw	r22, r0
    3886:	e9 9f       	mul	r30, r25
    3888:	70 0d       	add	r23, r0
    388a:	f8 9f       	mul	r31, r24
    388c:	70 0d       	add	r23, r0
    388e:	11 24       	eor	r1, r1
    3890:	07 2e       	mov	r0, r23
    3892:	00 0c       	add	r0, r0
    3894:	88 0b       	sbc	r24, r24
    3896:	99 0b       	sbc	r25, r25
    3898:	c0 90 40 04 	lds	r12, 0x0440	; 0x800440 <_ZZN8CFastLED8countFPSEiE9lastframe>
    389c:	d0 90 41 04 	lds	r13, 0x0441	; 0x800441 <_ZZN8CFastLED8countFPSEiE9lastframe+0x1>
    38a0:	e0 90 42 04 	lds	r14, 0x0442	; 0x800442 <_ZZN8CFastLED8countFPSEiE9lastframe+0x2>
    38a4:	f0 90 43 04 	lds	r15, 0x0443	; 0x800443 <_ZZN8CFastLED8countFPSEiE9lastframe+0x3>
    38a8:	a9 01       	movw	r20, r18
    38aa:	98 01       	movw	r18, r16
    38ac:	2c 19       	sub	r18, r12
    38ae:	3d 09       	sbc	r19, r13
    38b0:	4e 09       	sbc	r20, r14
    38b2:	5f 09       	sbc	r21, r15
    38b4:	0e 94 6e 27 	call	0x4edc	; 0x4edc <__udivmodsi4>
    38b8:	3a 83       	std	Y+2, r19	; 0x02
    38ba:	29 83       	std	Y+1, r18	; 0x01
    38bc:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <_ZZN8CFastLED8countFPSEiE2br+0x1>
    38c0:	10 92 44 04 	sts	0x0444, r1	; 0x800444 <_ZZN8CFastLED8countFPSEiE2br>
    38c4:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    38c8:	60 93 40 04 	sts	0x0440, r22	; 0x800440 <_ZZN8CFastLED8countFPSEiE9lastframe>
    38cc:	70 93 41 04 	sts	0x0441, r23	; 0x800441 <_ZZN8CFastLED8countFPSEiE9lastframe+0x1>
    38d0:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <_ZZN8CFastLED8countFPSEiE9lastframe+0x2>
    38d4:	90 93 43 04 	sts	0x0443, r25	; 0x800443 <_ZZN8CFastLED8countFPSEiE9lastframe+0x3>
    38d8:	df 91       	pop	r29
    38da:	cf 91       	pop	r28
    38dc:	1f 91       	pop	r17
    38de:	0f 91       	pop	r16
    38e0:	ff 90       	pop	r15
    38e2:	ef 90       	pop	r14
    38e4:	df 90       	pop	r13
    38e6:	cf 90       	pop	r12
    38e8:	08 95       	ret

000038ea <_ZN8CFastLED4showEh>:
    38ea:	af 92       	push	r10
    38ec:	bf 92       	push	r11
    38ee:	cf 92       	push	r12
    38f0:	df 92       	push	r13
    38f2:	ef 92       	push	r14
    38f4:	ff 92       	push	r15
    38f6:	0f 93       	push	r16
    38f8:	1f 93       	push	r17
    38fa:	cf 93       	push	r28
    38fc:	df 93       	push	r29
    38fe:	00 d0       	rcall	.+0      	; 0x3900 <_ZN8CFastLED4showEh+0x16>
    3900:	1f 92       	push	r1
    3902:	cd b7       	in	r28, 0x3d	; 61
    3904:	de b7       	in	r29, 0x3e	; 62
    3906:	7c 01       	movw	r14, r24
    3908:	d6 2e       	mov	r13, r22
    390a:	f7 01       	movw	r30, r14
    390c:	83 81       	ldd	r24, Z+3	; 0x03
    390e:	94 81       	ldd	r25, Z+4	; 0x04
    3910:	a5 81       	ldd	r26, Z+5	; 0x05
    3912:	b6 81       	ldd	r27, Z+6	; 0x06
    3914:	89 2b       	or	r24, r25
    3916:	8a 2b       	or	r24, r26
    3918:	8b 2b       	or	r24, r27
    391a:	d1 f0       	breq	.+52     	; 0x3950 <_ZN8CFastLED4showEh+0x66>
    391c:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
    3920:	00 91 46 04 	lds	r16, 0x0446	; 0x800446 <_ZL8lastshow>
    3924:	10 91 47 04 	lds	r17, 0x0447	; 0x800447 <_ZL8lastshow+0x1>
    3928:	20 91 48 04 	lds	r18, 0x0448	; 0x800448 <_ZL8lastshow+0x2>
    392c:	30 91 49 04 	lds	r19, 0x0449	; 0x800449 <_ZL8lastshow+0x3>
    3930:	dc 01       	movw	r26, r24
    3932:	cb 01       	movw	r24, r22
    3934:	80 1b       	sub	r24, r16
    3936:	91 0b       	sbc	r25, r17
    3938:	a2 0b       	sbc	r26, r18
    393a:	b3 0b       	sbc	r27, r19
    393c:	f7 01       	movw	r30, r14
    393e:	03 81       	ldd	r16, Z+3	; 0x03
    3940:	14 81       	ldd	r17, Z+4	; 0x04
    3942:	25 81       	ldd	r18, Z+5	; 0x05
    3944:	36 81       	ldd	r19, Z+6	; 0x06
    3946:	80 17       	cp	r24, r16
    3948:	91 07       	cpc	r25, r17
    394a:	a2 07       	cpc	r26, r18
    394c:	b3 07       	cpc	r27, r19
    394e:	e8 f2       	brcs	.-70     	; 0x390a <_ZN8CFastLED4showEh+0x20>
    3950:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
    3954:	60 93 46 04 	sts	0x0446, r22	; 0x800446 <_ZL8lastshow>
    3958:	70 93 47 04 	sts	0x0447, r23	; 0x800447 <_ZL8lastshow+0x1>
    395c:	80 93 48 04 	sts	0x0448, r24	; 0x800448 <_ZL8lastshow+0x2>
    3960:	90 93 49 04 	sts	0x0449, r25	; 0x800449 <_ZL8lastshow+0x3>
    3964:	d7 01       	movw	r26, r14
    3966:	1b 96       	adiw	r26, 0x0b	; 11
    3968:	ed 91       	ld	r30, X+
    396a:	fc 91       	ld	r31, X
    396c:	1c 97       	sbiw	r26, 0x0c	; 12
    396e:	30 97       	sbiw	r30, 0x00	; 0
    3970:	51 f0       	breq	.+20     	; 0x3986 <_ZN8CFastLED4showEh+0x9c>
    3972:	d7 01       	movw	r26, r14
    3974:	17 96       	adiw	r26, 0x07	; 7
    3976:	4d 91       	ld	r20, X+
    3978:	5d 91       	ld	r21, X+
    397a:	6d 91       	ld	r22, X+
    397c:	7c 91       	ld	r23, X
    397e:	1a 97       	sbiw	r26, 0x0a	; 10
    3980:	8d 2d       	mov	r24, r13
    3982:	09 95       	icall
    3984:	d8 2e       	mov	r13, r24
    3986:	00 91 4c 04 	lds	r16, 0x044C	; 0x80044c <_ZN14CLEDController7m_pHeadE>
    398a:	10 91 4d 04 	lds	r17, 0x044D	; 0x80044d <_ZN14CLEDController7m_pHeadE+0x1>
    398e:	01 15       	cp	r16, r1
    3990:	11 05       	cpc	r17, r1
    3992:	79 f1       	breq	.+94     	; 0x39f2 <_ZN8CFastLED4showEh+0x108>
    3994:	f8 01       	movw	r30, r16
    3996:	c4 84       	ldd	r12, Z+12	; 0x0c
    3998:	d7 01       	movw	r26, r14
    399a:	11 96       	adiw	r26, 0x01	; 1
    399c:	8d 91       	ld	r24, X+
    399e:	9c 91       	ld	r25, X
    39a0:	12 97       	sbiw	r26, 0x02	; 2
    39a2:	84 36       	cpi	r24, 0x64	; 100
    39a4:	91 05       	cpc	r25, r1
    39a6:	08 f4       	brcc	.+2      	; 0x39aa <_ZN8CFastLED4showEh+0xc0>
    39a8:	14 86       	std	Z+12, r1	; 0x0c
    39aa:	d8 01       	movw	r26, r16
    39ac:	ed 91       	ld	r30, X+
    39ae:	fc 91       	ld	r31, X
    39b0:	a2 80       	ldd	r10, Z+2	; 0x02
    39b2:	b3 80       	ldd	r11, Z+3	; 0x03
    39b4:	98 01       	movw	r18, r16
    39b6:	27 5f       	subi	r18, 0xF7	; 247
    39b8:	3f 4f       	sbci	r19, 0xFF	; 255
    39ba:	a8 01       	movw	r20, r16
    39bc:	4a 5f       	subi	r20, 0xFA	; 250
    39be:	5f 4f       	sbci	r21, 0xFF	; 255
    39c0:	6d 2d       	mov	r22, r13
    39c2:	ce 01       	movw	r24, r28
    39c4:	01 96       	adiw	r24, 0x01	; 1
    39c6:	0e 94 b9 1b 	call	0x3772	; 0x3772 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>
    39ca:	f8 01       	movw	r30, r16
    39cc:	45 85       	ldd	r20, Z+13	; 0x0d
    39ce:	56 85       	ldd	r21, Z+14	; 0x0e
    39d0:	62 81       	ldd	r22, Z+2	; 0x02
    39d2:	73 81       	ldd	r23, Z+3	; 0x03
    39d4:	9e 01       	movw	r18, r28
    39d6:	2f 5f       	subi	r18, 0xFF	; 255
    39d8:	3f 4f       	sbci	r19, 0xFF	; 255
    39da:	c8 01       	movw	r24, r16
    39dc:	f5 01       	movw	r30, r10
    39de:	09 95       	icall
    39e0:	d8 01       	movw	r26, r16
    39e2:	1c 96       	adiw	r26, 0x0c	; 12
    39e4:	cc 92       	st	X, r12
    39e6:	1c 97       	sbiw	r26, 0x0c	; 12
    39e8:	14 96       	adiw	r26, 0x04	; 4
    39ea:	0d 91       	ld	r16, X+
    39ec:	1c 91       	ld	r17, X
    39ee:	15 97       	sbiw	r26, 0x05	; 5
    39f0:	ce cf       	rjmp	.-100    	; 0x398e <_ZN8CFastLED4showEh+0xa4>
    39f2:	69 e1       	ldi	r22, 0x19	; 25
    39f4:	70 e0       	ldi	r23, 0x00	; 0
    39f6:	c7 01       	movw	r24, r14
    39f8:	0e 94 20 1c 	call	0x3840	; 0x3840 <_ZN8CFastLED8countFPSEi>
    39fc:	0f 90       	pop	r0
    39fe:	0f 90       	pop	r0
    3a00:	0f 90       	pop	r0
    3a02:	df 91       	pop	r29
    3a04:	cf 91       	pop	r28
    3a06:	1f 91       	pop	r17
    3a08:	0f 91       	pop	r16
    3a0a:	ff 90       	pop	r15
    3a0c:	ef 90       	pop	r14
    3a0e:	df 90       	pop	r13
    3a10:	cf 90       	pop	r12
    3a12:	bf 90       	pop	r11
    3a14:	af 90       	pop	r10
    3a16:	08 95       	ret

00003a18 <_ZN8CFastLED5delayEm>:
    3a18:	8f 92       	push	r8
    3a1a:	9f 92       	push	r9
    3a1c:	af 92       	push	r10
    3a1e:	bf 92       	push	r11
    3a20:	cf 92       	push	r12
    3a22:	df 92       	push	r13
    3a24:	ef 92       	push	r14
    3a26:	ff 92       	push	r15
    3a28:	cf 93       	push	r28
    3a2a:	df 93       	push	r29
    3a2c:	ec 01       	movw	r28, r24
    3a2e:	6a 01       	movw	r12, r20
    3a30:	7b 01       	movw	r14, r22
    3a32:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    3a36:	4b 01       	movw	r8, r22
    3a38:	5c 01       	movw	r10, r24
    3a3a:	61 e0       	ldi	r22, 0x01	; 1
    3a3c:	70 e0       	ldi	r23, 0x00	; 0
    3a3e:	80 e0       	ldi	r24, 0x00	; 0
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	0e 94 0a 24 	call	0x4814	; 0x4814 <delay>
    3a46:	68 81       	ld	r22, Y
    3a48:	ce 01       	movw	r24, r28
    3a4a:	0e 94 75 1c 	call	0x38ea	; 0x38ea <_ZN8CFastLED4showEh>
    3a4e:	0e 94 74 22 	call	0x44e8	; 0x44e8 <yield>
    3a52:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <millis>
    3a56:	dc 01       	movw	r26, r24
    3a58:	cb 01       	movw	r24, r22
    3a5a:	88 19       	sub	r24, r8
    3a5c:	99 09       	sbc	r25, r9
    3a5e:	aa 09       	sbc	r26, r10
    3a60:	bb 09       	sbc	r27, r11
    3a62:	8c 15       	cp	r24, r12
    3a64:	9d 05       	cpc	r25, r13
    3a66:	ae 05       	cpc	r26, r14
    3a68:	bf 05       	cpc	r27, r15
    3a6a:	38 f3       	brcs	.-50     	; 0x3a3a <_ZN8CFastLED5delayEm+0x22>
    3a6c:	df 91       	pop	r29
    3a6e:	cf 91       	pop	r28
    3a70:	ff 90       	pop	r15
    3a72:	ef 90       	pop	r14
    3a74:	df 90       	pop	r13
    3a76:	cf 90       	pop	r12
    3a78:	bf 90       	pop	r11
    3a7a:	af 90       	pop	r10
    3a7c:	9f 90       	pop	r9
    3a7e:	8f 90       	pop	r8
    3a80:	08 95       	ret

00003a82 <_ZN8CFastLED17setMaxRefreshRateEjb>:
    3a82:	cf 93       	push	r28
    3a84:	df 93       	push	r29
    3a86:	ec 01       	movw	r28, r24
    3a88:	44 23       	and	r20, r20
    3a8a:	e1 f0       	breq	.+56     	; 0x3ac4 <_ZN8CFastLED17setMaxRefreshRateEjb+0x42>
    3a8c:	61 15       	cp	r22, r1
    3a8e:	71 05       	cpc	r23, r1
    3a90:	71 f1       	breq	.+92     	; 0x3aee <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
    3a92:	9b 01       	movw	r18, r22
    3a94:	40 e0       	ldi	r20, 0x00	; 0
    3a96:	50 e0       	ldi	r21, 0x00	; 0
    3a98:	60 e4       	ldi	r22, 0x40	; 64
    3a9a:	72 e4       	ldi	r23, 0x42	; 66
    3a9c:	8f e0       	ldi	r24, 0x0F	; 15
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    3aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    3aa8:	ad 81       	ldd	r26, Y+5	; 0x05
    3aaa:	be 81       	ldd	r27, Y+6	; 0x06
    3aac:	82 17       	cp	r24, r18
    3aae:	93 07       	cpc	r25, r19
    3ab0:	a4 07       	cpc	r26, r20
    3ab2:	b5 07       	cpc	r27, r21
    3ab4:	10 f4       	brcc	.+4      	; 0x3aba <_ZN8CFastLED17setMaxRefreshRateEjb+0x38>
    3ab6:	da 01       	movw	r26, r20
    3ab8:	c9 01       	movw	r24, r18
    3aba:	8b 83       	std	Y+3, r24	; 0x03
    3abc:	9c 83       	std	Y+4, r25	; 0x04
    3abe:	ad 83       	std	Y+5, r26	; 0x05
    3ac0:	be 83       	std	Y+6, r27	; 0x06
    3ac2:	15 c0       	rjmp	.+42     	; 0x3aee <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
    3ac4:	61 15       	cp	r22, r1
    3ac6:	71 05       	cpc	r23, r1
    3ac8:	71 f0       	breq	.+28     	; 0x3ae6 <_ZN8CFastLED17setMaxRefreshRateEjb+0x64>
    3aca:	9b 01       	movw	r18, r22
    3acc:	40 e0       	ldi	r20, 0x00	; 0
    3ace:	50 e0       	ldi	r21, 0x00	; 0
    3ad0:	60 e4       	ldi	r22, 0x40	; 64
    3ad2:	72 e4       	ldi	r23, 0x42	; 66
    3ad4:	8f e0       	ldi	r24, 0x0F	; 15
    3ad6:	90 e0       	ldi	r25, 0x00	; 0
    3ad8:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    3adc:	2b 83       	std	Y+3, r18	; 0x03
    3ade:	3c 83       	std	Y+4, r19	; 0x04
    3ae0:	4d 83       	std	Y+5, r20	; 0x05
    3ae2:	5e 83       	std	Y+6, r21	; 0x06
    3ae4:	04 c0       	rjmp	.+8      	; 0x3aee <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
    3ae6:	1b 82       	std	Y+3, r1	; 0x03
    3ae8:	1c 82       	std	Y+4, r1	; 0x04
    3aea:	1d 82       	std	Y+5, r1	; 0x05
    3aec:	1e 82       	std	Y+6, r1	; 0x06
    3aee:	df 91       	pop	r29
    3af0:	cf 91       	pop	r28
    3af2:	08 95       	ret

00003af4 <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>:
    3af4:	cf 92       	push	r12
    3af6:	df 92       	push	r13
    3af8:	ef 92       	push	r14
    3afa:	ff 92       	push	r15
    3afc:	0f 93       	push	r16
    3afe:	1f 93       	push	r17
    3b00:	cf 93       	push	r28
    3b02:	df 93       	push	r29
    3b04:	8c 01       	movw	r16, r24
    3b06:	6b 01       	movw	r12, r22
    3b08:	ea 01       	movw	r28, r20
    3b0a:	79 01       	movw	r14, r18
    3b0c:	12 16       	cp	r1, r18
    3b0e:	13 06       	cpc	r1, r19
    3b10:	1c f0       	brlt	.+6      	; 0x3b18 <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii+0x24>
    3b12:	7a 01       	movw	r14, r20
    3b14:	c0 e0       	ldi	r28, 0x00	; 0
    3b16:	d0 e0       	ldi	r29, 0x00	; 0
    3b18:	d8 01       	movw	r26, r16
    3b1a:	ed 91       	ld	r30, X+
    3b1c:	fc 91       	ld	r31, X
    3b1e:	04 80       	ldd	r0, Z+4	; 0x04
    3b20:	f5 81       	ldd	r31, Z+5	; 0x05
    3b22:	e0 2d       	mov	r30, r0
    3b24:	c8 01       	movw	r24, r16
    3b26:	09 95       	icall
    3b28:	ce 01       	movw	r24, r28
    3b2a:	88 0f       	add	r24, r24
    3b2c:	99 1f       	adc	r25, r25
    3b2e:	c8 0f       	add	r28, r24
    3b30:	d9 1f       	adc	r29, r25
    3b32:	cc 0d       	add	r28, r12
    3b34:	dd 1d       	adc	r29, r13
    3b36:	f8 01       	movw	r30, r16
    3b38:	d3 83       	std	Z+3, r29	; 0x03
    3b3a:	c2 83       	std	Z+2, r28	; 0x02
    3b3c:	f6 86       	std	Z+14, r15	; 0x0e
    3b3e:	e5 86       	std	Z+13, r14	; 0x0d
    3b40:	01 90       	ld	r0, Z+
    3b42:	f0 81       	ld	r31, Z
    3b44:	e0 2d       	mov	r30, r0
    3b46:	02 84       	ldd	r0, Z+10	; 0x0a
    3b48:	f3 85       	ldd	r31, Z+11	; 0x0b
    3b4a:	e0 2d       	mov	r30, r0
    3b4c:	c8 01       	movw	r24, r16
    3b4e:	09 95       	icall
    3b50:	41 e0       	ldi	r20, 0x01	; 1
    3b52:	bc 01       	movw	r22, r24
    3b54:	8e e4       	ldi	r24, 0x4E	; 78
    3b56:	94 e0       	ldi	r25, 0x04	; 4
    3b58:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <_ZN8CFastLED17setMaxRefreshRateEjb>
    3b5c:	c8 01       	movw	r24, r16
    3b5e:	df 91       	pop	r29
    3b60:	cf 91       	pop	r28
    3b62:	1f 91       	pop	r17
    3b64:	0f 91       	pop	r16
    3b66:	ff 90       	pop	r15
    3b68:	ef 90       	pop	r14
    3b6a:	df 90       	pop	r13
    3b6c:	cf 90       	pop	r12
    3b6e:	08 95       	ret

00003b70 <_GLOBAL__sub_I_pSmartMatrix>:

FASTLED_NAMESPACE_BEGIN

void *pSmartMatrix = NULL;

CFastLED FastLED;
    3b70:	8e e4       	ldi	r24, 0x4E	; 78
    3b72:	94 e0       	ldi	r25, 0x04	; 4
    3b74:	0c 94 11 1c 	jmp	0x3822	; 0x3822 <_ZN8CFastLEDC1Ev>

00003b78 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB>:
#define K171 171
#define K170 170
#define K85  85

void hsv2rgb_rainbow( const CHSV& hsv, CRGB& rgb)
{
    3b78:	1f 93       	push	r17
    3b7a:	dc 01       	movw	r26, r24
    3b7c:	fb 01       	movw	r30, r22
    // Gscale: what to scale green down by.
    // Depends GREATLY on your particular LEDs
    const uint8_t Gscale = 0;
    
    
    uint8_t hue = hsv.hue;
    3b7e:	7c 91       	ld	r23, X
    uint8_t sat = hsv.sat;
    3b80:	11 96       	adiw	r26, 0x01	; 1
    3b82:	4c 91       	ld	r20, X
    3b84:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t val = hsv.val;
    3b86:	12 96       	adiw	r26, 0x02	; 2
    3b88:	1c 91       	ld	r17, X
    
    uint8_t offset = hue & 0x1F; // 0..31
    3b8a:	97 2f       	mov	r25, r23
    3b8c:	9f 71       	andi	r25, 0x1F	; 31
    {
#if defined(__AVR__)
        // Left to its own devices, gcc turns "x <<= 3" into a loop
        // It's much faster and smaller to just do three single-bit shifts
        // So this business is to force that.
        offset8 <<= 1;
    3b8e:	99 0f       	add	r25, r25
        asm volatile("");
        offset8 <<= 1;
    3b90:	99 0f       	add	r25, r25
        asm volatile("");
        offset8 <<= 1;
    3b92:	99 0f       	add	r25, r25
#endif
         "clr __zero_reg__    \n\t"

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    3b94:	35 e5       	ldi	r19, 0x55	; 85
    3b96:	29 2f       	mov	r18, r25
    3b98:	23 9f       	mul	r18, r19
    3b9a:	02 0e       	add	r0, r18
    3b9c:	20 e0       	ldi	r18, 0x00	; 0
    3b9e:	21 1d       	adc	r18, r1
    3ba0:	11 24       	eor	r1, r1
    3ba2:	82 2f       	mov	r24, r18
    3ba4:	67 2f       	mov	r22, r23
    3ba6:	60 74       	andi	r22, 0x40	; 64
    3ba8:	57 2f       	mov	r21, r23
    3baa:	50 72       	andi	r21, 0x20	; 32
    
    uint8_t third = scale8( offset8, (256 / 3)); // max = 85
    
    uint8_t r, g, b;
    
    if( ! (hue & 0x80) ) {
    3bac:	77 fd       	sbrc	r23, 7
    3bae:	1f c0       	rjmp	.+62     	; 0x3bee <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x76>
        // 0XX
        if( ! (hue & 0x40) ) {
    3bb0:	61 11       	cpse	r22, r1
    3bb2:	0a c0       	rjmp	.+20     	; 0x3bc8 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x50>
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
    3bb4:	51 11       	cpse	r21, r1
    3bb6:	03 c0       	rjmp	.+6      	; 0x3bbe <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x46>
                // 000
                //case 0: // R -> O
                r = K255 - third;
    3bb8:	92 2f       	mov	r25, r18
    3bba:	90 95       	com	r25
                g = third;
                b = 0;
                FORCE_REFERENCE(b);
    3bbc:	11 c0       	rjmp	.+34     	; 0x3be0 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x68>
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
                    g = K85 + third ;
    3bbe:	25 e5       	ldi	r18, 0x55	; 85
    3bc0:	28 0f       	add	r18, r24
                    b = 0;
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
                FORCE_REFERENCE(b);
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
    3bc4:	8b ea       	ldi	r24, 0xAB	; 171
    3bc6:	34 c0       	rjmp	.+104    	; 0x3c30 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xb8>
                }
            }
        } else {
            //01X
            // section 2-3
            if( !  (hue & 0x20) ) {
    3bc8:	51 11       	cpse	r21, r1
    3bca:	0d c0       	rjmp	.+26     	; 0x3be6 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x6e>
    3bcc:	39 2f       	mov	r19, r25
    3bce:	2a ea       	ldi	r18, 0xAA	; 170
    3bd0:	32 9f       	mul	r19, r18
    3bd2:	03 0e       	add	r0, r19
    3bd4:	30 e0       	ldi	r19, 0x00	; 0
    3bd6:	31 1d       	adc	r19, r1
    3bd8:	11 24       	eor	r1, r1
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                    r = K171 - twothirds;
    3bda:	9b ea       	ldi	r25, 0xAB	; 171
    3bdc:	93 1b       	sub	r25, r19
                    g = K170 + third;
    3bde:	28 0f       	add	r18, r24
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                    r = K171 - twothirds;
    3be0:	89 2f       	mov	r24, r25
                    g = K170 + third;
                    b = 0;
    3be2:	90 e0       	ldi	r25, 0x00	; 0
    3be4:	25 c0       	rjmp	.+74     	; 0x3c30 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xb8>
                }
            } else {
                // 011
                // case 3: // G -> A
                r = 0;
                FORCE_REFERENCE(r);
    3be6:	90 e0       	ldi	r25, 0x00	; 0
                g = K255 - third;
    3be8:	20 95       	com	r18
                b = third;
    3bea:	98 2f       	mov	r25, r24
    3bec:	0f c0       	rjmp	.+30     	; 0x3c0c <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x94>
            }
        }
    } else {
        // section 4-7
        // 1XX
        if( ! (hue & 0x40) ) {
    3bee:	61 11       	cpse	r22, r1
    3bf0:	12 c0       	rjmp	.+36     	; 0x3c16 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x9e>
            // 10X
            if( ! ( hue & 0x20) ) {
    3bf2:	51 11       	cpse	r21, r1
    3bf4:	0d c0       	rjmp	.+26     	; 0x3c10 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x98>
    3bf6:	39 2f       	mov	r19, r25
    3bf8:	2a ea       	ldi	r18, 0xAA	; 170
    3bfa:	32 9f       	mul	r19, r18
    3bfc:	03 0e       	add	r0, r19
    3bfe:	30 e0       	ldi	r19, 0x00	; 0
    3c00:	31 1d       	adc	r19, r1
    3c02:	11 24       	eor	r1, r1
                //case 4: // A -> B
                r = 0;
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                g = K171 - twothirds; //K170?
    3c04:	2b ea       	ldi	r18, 0xAB	; 171
    3c06:	23 1b       	sub	r18, r19
                b = K85  + twothirds;
    3c08:	95 e5       	ldi	r25, 0x55	; 85
    3c0a:	93 0f       	add	r25, r19
        if( ! (hue & 0x40) ) {
            // 10X
            if( ! ( hue & 0x20) ) {
                // 100
                //case 4: // A -> B
                r = 0;
    3c0c:	80 e0       	ldi	r24, 0x00	; 0
    3c0e:	10 c0       	rjmp	.+32     	; 0x3c30 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xb8>
                // 101
                //case 5: // B -> P
                r = third;
                g = 0;
                FORCE_REFERENCE(g);
                b = K255 - third;
    3c10:	92 2f       	mov	r25, r18
    3c12:	90 95       	com	r25
    3c14:	0c c0       	rjmp	.+24     	; 0x3c2e <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xb6>
                
            }
        } else {
            if( !  (hue & 0x20)  ) {
    3c16:	51 11       	cpse	r21, r1
    3c18:	04 c0       	rjmp	.+8      	; 0x3c22 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xaa>
                // 110
                //case 6: // P -- K
                r = K85 + third;
    3c1a:	25 e5       	ldi	r18, 0x55	; 85
    3c1c:	28 0f       	add	r18, r24
                g = 0;
                FORCE_REFERENCE(g);
                b = K171 - third;
    3c1e:	9b ea       	ldi	r25, 0xAB	; 171
    3c20:	04 c0       	rjmp	.+8      	; 0x3c2a <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xb2>
                
            } else {
                // 111
                //case 7: // K -> R
                r = K170 + third;
    3c22:	2a ea       	ldi	r18, 0xAA	; 170
    3c24:	28 0f       	add	r18, r24
                g = 0;
                FORCE_REFERENCE(g);
    3c26:	90 e0       	ldi	r25, 0x00	; 0
                b = K85 - third;
    3c28:	93 2f       	mov	r25, r19
    3c2a:	98 1b       	sub	r25, r24
                b = K171 - third;
                
            } else {
                // 111
                //case 7: // K -> R
                r = K170 + third;
    3c2c:	82 2f       	mov	r24, r18
                g = 0;
    3c2e:	20 e0       	ldi	r18, 0x00	; 0
    if( G2 ) g = g >> 1;
    if( Gscale ) g = scale8_video_LEAVING_R1_DIRTY( g, Gscale);
    
    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
    3c30:	4f 3f       	cpi	r20, 0xFF	; 255
    3c32:	09 f4       	brne	.+2      	; 0x3c36 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xbe>
    3c34:	27 c0       	rjmp	.+78     	; 0x3c84 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x10c>
        if( sat == 0) {
    3c36:	44 23       	and	r20, r20
    3c38:	11 f1       	breq	.+68     	; 0x3c7e <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x106>
            r = 255; b = 255; g = 255;
        } else {
            //nscale8x3_video( r, g, b, sat);
#if (FASTLED_SCALE8_FIXED==1)
            if( r ) r = scale8_LEAVING_R1_DIRTY( r, sat);
    3c3a:	88 23       	and	r24, r24
    3c3c:	31 f0       	breq	.+12     	; 0x3c4a <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xd2>
         /* R1 IS LEFT DIRTY HERE; YOU MUST ZERO IT OUT YOURSELF  */
         /* "clr __zero_reg__    \n\t" */

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    3c3e:	38 2f       	mov	r19, r24
    3c40:	34 9f       	mul	r19, r20
    3c42:	03 0e       	add	r0, r19
    3c44:	30 e0       	ldi	r19, 0x00	; 0
    3c46:	31 1d       	adc	r19, r1
    3c48:	83 2f       	mov	r24, r19
            if( g ) g = scale8_LEAVING_R1_DIRTY( g, sat);
    3c4a:	22 23       	and	r18, r18
    3c4c:	21 f0       	breq	.+8      	; 0x3c56 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xde>
    3c4e:	24 9f       	mul	r18, r20
    3c50:	02 0e       	add	r0, r18
    3c52:	20 e0       	ldi	r18, 0x00	; 0
    3c54:	21 1d       	adc	r18, r1
            if( b ) b = scale8_LEAVING_R1_DIRTY( b, sat);
    3c56:	99 23       	and	r25, r25
    3c58:	31 f0       	breq	.+12     	; 0x3c66 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0xee>
    3c5a:	39 2f       	mov	r19, r25
    3c5c:	34 9f       	mul	r19, r20
    3c5e:	03 0e       	add	r0, r19
    3c60:	30 e0       	ldi	r19, 0x00	; 0
    3c62:	31 1d       	adc	r19, r1
    3c64:	93 2f       	mov	r25, r19
/// Clean up the r1 register after a series of *LEAVING_R1_DIRTY calls
LIB8STATIC_ALWAYS_INLINE void cleanup_R1()
{
#if CLEANUP_R1_AVRASM == 1
    // Restore r1 to "0"; it's expected to always be that
    asm volatile( "clr __zero_reg__  \n\t" : : : "r1" );
    3c66:	11 24       	eor	r1, r1
            if( g ) g = scale8_LEAVING_R1_DIRTY( g, sat) + 1;
            if( b ) b = scale8_LEAVING_R1_DIRTY( b, sat) + 1;
#endif
            cleanup_R1();
            
            uint8_t desat = 255 - sat;
    3c68:	34 2f       	mov	r19, r20
    3c6a:	30 95       	com	r19
#endif
         "clr __zero_reg__    \n\t"

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    3c6c:	33 9f       	mul	r19, r19
    3c6e:	03 0e       	add	r0, r19
    3c70:	30 e0       	ldi	r19, 0x00	; 0
    3c72:	31 1d       	adc	r19, r1
    3c74:	11 24       	eor	r1, r1
            desat = scale8( desat, desat);
            
            uint8_t brightness_floor = desat;
            r += brightness_floor;
    3c76:	83 0f       	add	r24, r19
            g += brightness_floor;
    3c78:	23 0f       	add	r18, r19
            b += brightness_floor;
    3c7a:	93 0f       	add	r25, r19
    3c7c:	03 c0       	rjmp	.+6      	; 0x3c84 <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x10c>
    
    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
        if( sat == 0) {
            r = 255; b = 255; g = 255;
    3c7e:	9f ef       	ldi	r25, 0xFF	; 255
    3c80:	2f ef       	ldi	r18, 0xFF	; 255
    3c82:	8f ef       	ldi	r24, 0xFF	; 255
            b += brightness_floor;
        }
    }
    
    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
    3c84:	1f 3f       	cpi	r17, 0xFF	; 255
    3c86:	09 f4       	brne	.+2      	; 0x3c8a <_Z15hsv2rgb_rainbowRK4CHSVR4CRGB+0x112>
    3c88:	24 c0       	rjmp	.+72     	; 0x3cd2 <L_822+0x3a>
        "  breq L_%=\n\t"
        "  subi %[j], 0xFF\n\t"
        "L_%=: \n\t"
        : [j] "+a" (j)
        : [i] "a" (i), [scale] "a" (scale)
        : "r0", "r1");
    3c8a:	30 e0       	ldi	r19, 0x00	; 0
    3c8c:	11 23       	and	r17, r17
    3c8e:	21 f0       	breq	.+8      	; 0x3c98 <L_822>
    3c90:	11 9f       	mul	r17, r17
    3c92:	31 2d       	mov	r19, r1
    3c94:	09 f0       	breq	.+2      	; 0x3c98 <L_822>
    3c96:	3f 5f       	subi	r19, 0xFF	; 255

00003c98 <L_822>:
        
        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        if( val == 0 ) {
    3c98:	33 23       	and	r19, r19
    3c9a:	c1 f0       	breq	.+48     	; 0x3ccc <L_822+0x34>
            r=0; g=0; b=0;
        } else {
            // nscale8x3_video( r, g, b, val);
#if (FASTLED_SCALE8_FIXED==1)
            if( r ) r = scale8_LEAVING_R1_DIRTY( r, val);
    3c9c:	88 23       	and	r24, r24
    3c9e:	31 f0       	breq	.+12     	; 0x3cac <L_822+0x14>
         /* R1 IS LEFT DIRTY HERE; YOU MUST ZERO IT OUT YOURSELF  */
         /* "clr __zero_reg__    \n\t" */

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    3ca0:	48 2f       	mov	r20, r24
    3ca2:	43 9f       	mul	r20, r19
    3ca4:	04 0e       	add	r0, r20
    3ca6:	40 e0       	ldi	r20, 0x00	; 0
    3ca8:	41 1d       	adc	r20, r1
    3caa:	84 2f       	mov	r24, r20
            if( g ) g = scale8_LEAVING_R1_DIRTY( g, val);
    3cac:	22 23       	and	r18, r18
    3cae:	21 f0       	breq	.+8      	; 0x3cb8 <L_822+0x20>
    3cb0:	23 9f       	mul	r18, r19
    3cb2:	02 0e       	add	r0, r18
    3cb4:	20 e0       	ldi	r18, 0x00	; 0
    3cb6:	21 1d       	adc	r18, r1
            if( b ) b = scale8_LEAVING_R1_DIRTY( b, val);
    3cb8:	99 23       	and	r25, r25
    3cba:	31 f0       	breq	.+12     	; 0x3cc8 <L_822+0x30>
    3cbc:	49 2f       	mov	r20, r25
    3cbe:	43 9f       	mul	r20, r19
    3cc0:	04 0e       	add	r0, r20
    3cc2:	40 e0       	ldi	r20, 0x00	; 0
    3cc4:	41 1d       	adc	r20, r1
    3cc6:	94 2f       	mov	r25, r20
/// Clean up the r1 register after a series of *LEAVING_R1_DIRTY calls
LIB8STATIC_ALWAYS_INLINE void cleanup_R1()
{
#if CLEANUP_R1_AVRASM == 1
    // Restore r1 to "0"; it's expected to always be that
    asm volatile( "clr __zero_reg__  \n\t" : : : "r1" );
    3cc8:	11 24       	eor	r1, r1
    3cca:	03 c0       	rjmp	.+6      	; 0x3cd2 <L_822+0x3a>
    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
        
        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        if( val == 0 ) {
            r=0; g=0; b=0;
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	20 e0       	ldi	r18, 0x00	; 0
    3cd0:	80 e0       	ldi	r24, 0x00	; 0
    // It turns out that fixing it winds up costing more than
    // not fixing it.
    // To paraphrase Dr Bronner, profile! profile! profile!
    //asm volatile(  ""  :  :  : "r26", "r27" );
    //asm volatile (" movw r30, r26 \n" : : : "r30", "r31");
    rgb.r = r;
    3cd2:	80 83       	st	Z, r24
    rgb.g = g;
    3cd4:	21 83       	std	Z+1, r18	; 0x01
    rgb.b = b;
    3cd6:	92 83       	std	Z+2, r25	; 0x02
}
    3cd8:	1f 91       	pop	r17
    3cda:	08 95       	ret

00003cdc <memcpy8>:
         "  brcc Lcpyloop_%=        \n\t"
         : [num] "+r" (num)
         : [src] "r" (src),
           [dst] "r" (dst)
         : "memory"
         );
    3cdc:	fb 01       	movw	r30, r22
    3cde:	dc 01       	movw	r26, r24
    3ce0:	40 ff       	sbrs	r20, 0
    3ce2:	05 c0       	rjmp	.+10     	; 0x3cee <Lcpyeven_22>
    3ce4:	02 c0       	rjmp	.+4      	; 0x3cea <Lcpyodd_22>

00003ce6 <Lcpyloop_22>:
    3ce6:	01 90       	ld	r0, Z+
    3ce8:	0d 92       	st	X+, r0

00003cea <Lcpyodd_22>:
    3cea:	01 90       	ld	r0, Z+
    3cec:	0d 92       	st	X+, r0

00003cee <Lcpyeven_22>:
    3cee:	42 50       	subi	r20, 0x02	; 2
    3cf0:	d0 f7       	brcc	.-12     	; 0x3ce6 <Lcpyloop_22>
    3cf2:	50 40       	sbci	r21, 0x00	; 0
    3cf4:	c0 f7       	brcc	.-16     	; 0x3ce6 <Lcpyloop_22>
    return dst;
}
    3cf6:	08 95       	ret

00003cf8 <memmove8>:

//__attribute__ ((noinline))
void * memmove8 ( void * dst, const void* src, uint16_t num )
{
    if( src > dst) {
    3cf8:	86 17       	cp	r24, r22
    3cfa:	97 07       	cpc	r25, r23
    3cfc:	10 f4       	brcc	.+4      	; 0x3d02 <memmove8+0xa>
        // if src > dst then we can use the forward-stepping memcpy8
        return memcpy8( dst, src, num);
    3cfe:	0c 94 6e 1e 	jmp	0x3cdc	; 0x3cdc <memcpy8>
    } else {
        // if src < dst then we have to step backward:
        dst = (char*)dst + num;
    3d02:	84 0f       	add	r24, r20
    3d04:	95 1f       	adc	r25, r21
        src = (char*)src + num;
    3d06:	64 0f       	add	r22, r20
    3d08:	75 1f       	adc	r23, r21
             "  brcc Lmovloop_%=        \n\t"
             : [num] "+r" (num)
             : [src] "r" (src),
               [dst] "r" (dst)
             : "memory"
             );
    3d0a:	fb 01       	movw	r30, r22
    3d0c:	dc 01       	movw	r26, r24
    3d0e:	40 ff       	sbrs	r20, 0
    3d10:	05 c0       	rjmp	.+10     	; 0x3d1c <Lmoveven_56>
    3d12:	02 c0       	rjmp	.+4      	; 0x3d18 <Lmovodd_56>

00003d14 <Lmovloop_56>:
    3d14:	02 90       	ld	r0, -Z
    3d16:	0e 92       	st	-X, r0

00003d18 <Lmovodd_56>:
    3d18:	02 90       	ld	r0, -Z
    3d1a:	0e 92       	st	-X, r0

00003d1c <Lmoveven_56>:
    3d1c:	42 50       	subi	r20, 0x02	; 2
    3d1e:	d0 f7       	brcc	.-12     	; 0x3d14 <Lmovloop_56>
    3d20:	50 40       	sbci	r21, 0x00	; 0
    3d22:	c0 f7       	brcc	.-16     	; 0x3d14 <Lmovloop_56>
        return dst;
    }
}
    3d24:	08 95       	ret

00003d26 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    3d26:	10 92 c8 04 	sts	0x04C8, r1	; 0x8004c8 <twi_state>
    3d2a:	81 e0       	ldi	r24, 0x01	; 1
    3d2c:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <twi_sendStop>
    3d30:	10 92 c5 04 	sts	0x04C5, r1	; 0x8004c5 <twi_inRepStart>
    3d34:	61 e0       	ldi	r22, 0x01	; 1
    3d36:	81 e1       	ldi	r24, 0x11	; 17
    3d38:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
    3d3c:	61 e0       	ldi	r22, 0x01	; 1
    3d3e:	80 e1       	ldi	r24, 0x10	; 16
    3d40:	0e 94 e6 24 	call	0x49cc	; 0x49cc <digitalWrite>
    3d44:	e9 eb       	ldi	r30, 0xB9	; 185
    3d46:	f0 e0       	ldi	r31, 0x00	; 0
    3d48:	80 81       	ld	r24, Z
    3d4a:	8e 7f       	andi	r24, 0xFE	; 254
    3d4c:	80 83       	st	Z, r24
    3d4e:	80 81       	ld	r24, Z
    3d50:	8d 7f       	andi	r24, 0xFD	; 253
    3d52:	80 83       	st	Z, r24
    3d54:	88 e4       	ldi	r24, 0x48	; 72
    3d56:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    3d5a:	85 e4       	ldi	r24, 0x45	; 69
    3d5c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3d60:	08 95       	ret

00003d62 <twi_readFrom>:
    3d62:	41 32       	cpi	r20, 0x21	; 33
    3d64:	08 f0       	brcs	.+2      	; 0x3d68 <twi_readFrom+0x6>
    3d66:	43 c0       	rjmp	.+134    	; 0x3dee <twi_readFrom+0x8c>
    3d68:	90 91 c8 04 	lds	r25, 0x04C8	; 0x8004c8 <twi_state>
    3d6c:	91 11       	cpse	r25, r1
    3d6e:	fc cf       	rjmp	.-8      	; 0x3d68 <twi_readFrom+0x6>
    3d70:	91 e0       	ldi	r25, 0x01	; 1
    3d72:	90 93 c8 04 	sts	0x04C8, r25	; 0x8004c8 <twi_state>
    3d76:	20 93 c6 04 	sts	0x04C6, r18	; 0x8004c6 <twi_sendStop>
    3d7a:	2f ef       	ldi	r18, 0xFF	; 255
    3d7c:	20 93 5b 04 	sts	0x045B, r18	; 0x80045b <twi_error>
    3d80:	10 92 a0 04 	sts	0x04A0, r1	; 0x8004a0 <twi_masterBufferIndex>
    3d84:	24 0f       	add	r18, r20
    3d86:	20 93 9f 04 	sts	0x049F, r18	; 0x80049f <twi_masterBufferLength>
    3d8a:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <twi_slarw>
    3d8e:	90 91 c7 04 	lds	r25, 0x04C7	; 0x8004c7 <twi_slarw>
    3d92:	88 0f       	add	r24, r24
    3d94:	89 2b       	or	r24, r25
    3d96:	80 93 c7 04 	sts	0x04C7, r24	; 0x8004c7 <twi_slarw>
    3d9a:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <twi_inRepStart>
    3d9e:	81 30       	cpi	r24, 0x01	; 1
    3da0:	61 f4       	brne	.+24     	; 0x3dba <twi_readFrom+0x58>
    3da2:	10 92 c5 04 	sts	0x04C5, r1	; 0x8004c5 <twi_inRepStart>
    3da6:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <twi_slarw>
    3daa:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    3dae:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3db2:	83 fd       	sbrc	r24, 3
    3db4:	f8 cf       	rjmp	.-16     	; 0x3da6 <twi_readFrom+0x44>
    3db6:	85 ec       	ldi	r24, 0xC5	; 197
    3db8:	01 c0       	rjmp	.+2      	; 0x3dbc <twi_readFrom+0x5a>
    3dba:	85 ee       	ldi	r24, 0xE5	; 229
    3dbc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3dc0:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <twi_state>
    3dc4:	81 30       	cpi	r24, 0x01	; 1
    3dc6:	e1 f3       	breq	.-8      	; 0x3dc0 <twi_readFrom+0x5e>
    3dc8:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    3dcc:	84 17       	cp	r24, r20
    3dce:	10 f4       	brcc	.+4      	; 0x3dd4 <twi_readFrom+0x72>
    3dd0:	40 91 a0 04 	lds	r20, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    3dd4:	a1 ea       	ldi	r26, 0xA1	; 161
    3dd6:	b4 e0       	ldi	r27, 0x04	; 4
    3dd8:	96 2f       	mov	r25, r22
    3dda:	fb 01       	movw	r30, r22
    3ddc:	8e 2f       	mov	r24, r30
    3dde:	89 1b       	sub	r24, r25
    3de0:	84 17       	cp	r24, r20
    3de2:	18 f4       	brcc	.+6      	; 0x3dea <twi_readFrom+0x88>
    3de4:	8d 91       	ld	r24, X+
    3de6:	81 93       	st	Z+, r24
    3de8:	f9 cf       	rjmp	.-14     	; 0x3ddc <twi_readFrom+0x7a>
    3dea:	84 2f       	mov	r24, r20
    3dec:	08 95       	ret
    3dee:	80 e0       	ldi	r24, 0x00	; 0
    3df0:	08 95       	ret

00003df2 <twi_writeTo>:
    3df2:	0f 93       	push	r16
    3df4:	41 32       	cpi	r20, 0x21	; 33
    3df6:	08 f0       	brcs	.+2      	; 0x3dfa <twi_writeTo+0x8>
    3df8:	4a c0       	rjmp	.+148    	; 0x3e8e <twi_writeTo+0x9c>
    3dfa:	90 91 c8 04 	lds	r25, 0x04C8	; 0x8004c8 <twi_state>
    3dfe:	91 11       	cpse	r25, r1
    3e00:	fc cf       	rjmp	.-8      	; 0x3dfa <twi_writeTo+0x8>
    3e02:	32 e0       	ldi	r19, 0x02	; 2
    3e04:	30 93 c8 04 	sts	0x04C8, r19	; 0x8004c8 <twi_state>
    3e08:	00 93 c6 04 	sts	0x04C6, r16	; 0x8004c6 <twi_sendStop>
    3e0c:	3f ef       	ldi	r19, 0xFF	; 255
    3e0e:	30 93 5b 04 	sts	0x045B, r19	; 0x80045b <twi_error>
    3e12:	10 92 a0 04 	sts	0x04A0, r1	; 0x8004a0 <twi_masterBufferIndex>
    3e16:	40 93 9f 04 	sts	0x049F, r20	; 0x80049f <twi_masterBufferLength>
    3e1a:	56 2f       	mov	r21, r22
    3e1c:	a1 ea       	ldi	r26, 0xA1	; 161
    3e1e:	b4 e0       	ldi	r27, 0x04	; 4
    3e20:	fb 01       	movw	r30, r22
    3e22:	3e 2f       	mov	r19, r30
    3e24:	35 1b       	sub	r19, r21
    3e26:	34 17       	cp	r19, r20
    3e28:	18 f4       	brcc	.+6      	; 0x3e30 <twi_writeTo+0x3e>
    3e2a:	31 91       	ld	r19, Z+
    3e2c:	3d 93       	st	X+, r19
    3e2e:	f9 cf       	rjmp	.-14     	; 0x3e22 <twi_writeTo+0x30>
    3e30:	10 92 c7 04 	sts	0x04C7, r1	; 0x8004c7 <twi_slarw>
    3e34:	30 91 c7 04 	lds	r19, 0x04C7	; 0x8004c7 <twi_slarw>
    3e38:	88 0f       	add	r24, r24
    3e3a:	83 2b       	or	r24, r19
    3e3c:	80 93 c7 04 	sts	0x04C7, r24	; 0x8004c7 <twi_slarw>
    3e40:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <twi_inRepStart>
    3e44:	81 30       	cpi	r24, 0x01	; 1
    3e46:	61 f4       	brne	.+24     	; 0x3e60 <twi_writeTo+0x6e>
    3e48:	10 92 c5 04 	sts	0x04C5, r1	; 0x8004c5 <twi_inRepStart>
    3e4c:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <twi_slarw>
    3e50:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    3e54:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3e58:	83 fd       	sbrc	r24, 3
    3e5a:	f8 cf       	rjmp	.-16     	; 0x3e4c <twi_writeTo+0x5a>
    3e5c:	85 ec       	ldi	r24, 0xC5	; 197
    3e5e:	01 c0       	rjmp	.+2      	; 0x3e62 <twi_writeTo+0x70>
    3e60:	85 ee       	ldi	r24, 0xE5	; 229
    3e62:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3e66:	22 23       	and	r18, r18
    3e68:	21 f0       	breq	.+8      	; 0x3e72 <twi_writeTo+0x80>
    3e6a:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <twi_state>
    3e6e:	82 30       	cpi	r24, 0x02	; 2
    3e70:	d1 f3       	breq	.-12     	; 0x3e66 <twi_writeTo+0x74>
    3e72:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <twi_error>
    3e76:	8f 3f       	cpi	r24, 0xFF	; 255
    3e78:	79 f0       	breq	.+30     	; 0x3e98 <twi_writeTo+0xa6>
    3e7a:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <twi_error>
    3e7e:	80 32       	cpi	r24, 0x20	; 32
    3e80:	41 f0       	breq	.+16     	; 0x3e92 <twi_writeTo+0xa0>
    3e82:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <twi_error>
    3e86:	80 33       	cpi	r24, 0x30	; 48
    3e88:	31 f0       	breq	.+12     	; 0x3e96 <twi_writeTo+0xa4>
    3e8a:	94 e0       	ldi	r25, 0x04	; 4
    3e8c:	05 c0       	rjmp	.+10     	; 0x3e98 <twi_writeTo+0xa6>
    3e8e:	91 e0       	ldi	r25, 0x01	; 1
    3e90:	03 c0       	rjmp	.+6      	; 0x3e98 <twi_writeTo+0xa6>
    3e92:	92 e0       	ldi	r25, 0x02	; 2
    3e94:	01 c0       	rjmp	.+2      	; 0x3e98 <twi_writeTo+0xa6>
    3e96:	93 e0       	ldi	r25, 0x03	; 3
    3e98:	89 2f       	mov	r24, r25
    3e9a:	0f 91       	pop	r16
    3e9c:	08 95       	ret

00003e9e <twi_transmit>:
    3e9e:	40 91 7d 04 	lds	r20, 0x047D	; 0x80047d <twi_txBufferLength>
    3ea2:	26 2f       	mov	r18, r22
    3ea4:	30 e0       	ldi	r19, 0x00	; 0
    3ea6:	24 0f       	add	r18, r20
    3ea8:	31 1d       	adc	r19, r1
    3eaa:	21 32       	cpi	r18, 0x21	; 33
    3eac:	31 05       	cpc	r19, r1
    3eae:	dc f4       	brge	.+54     	; 0x3ee6 <twi_transmit+0x48>
    3eb0:	20 91 c8 04 	lds	r18, 0x04C8	; 0x8004c8 <twi_state>
    3eb4:	24 30       	cpi	r18, 0x04	; 4
    3eb6:	c9 f4       	brne	.+50     	; 0x3eea <twi_transmit+0x4c>
    3eb8:	fc 01       	movw	r30, r24
    3eba:	80 e0       	ldi	r24, 0x00	; 0
    3ebc:	90 e0       	ldi	r25, 0x00	; 0
    3ebe:	86 17       	cp	r24, r22
    3ec0:	58 f4       	brcc	.+22     	; 0x3ed8 <twi_transmit+0x3a>
    3ec2:	30 91 7d 04 	lds	r19, 0x047D	; 0x80047d <twi_txBufferLength>
    3ec6:	21 91       	ld	r18, Z+
    3ec8:	dc 01       	movw	r26, r24
    3eca:	a1 58       	subi	r26, 0x81	; 129
    3ecc:	bb 4f       	sbci	r27, 0xFB	; 251
    3ece:	a3 0f       	add	r26, r19
    3ed0:	b1 1d       	adc	r27, r1
    3ed2:	2c 93       	st	X, r18
    3ed4:	01 96       	adiw	r24, 0x01	; 1
    3ed6:	f3 cf       	rjmp	.-26     	; 0x3ebe <twi_transmit+0x20>
    3ed8:	80 91 7d 04 	lds	r24, 0x047D	; 0x80047d <twi_txBufferLength>
    3edc:	68 0f       	add	r22, r24
    3ede:	60 93 7d 04 	sts	0x047D, r22	; 0x80047d <twi_txBufferLength>
    3ee2:	80 e0       	ldi	r24, 0x00	; 0
    3ee4:	08 95       	ret
    3ee6:	81 e0       	ldi	r24, 0x01	; 1
    3ee8:	08 95       	ret
    3eea:	82 e0       	ldi	r24, 0x02	; 2
    3eec:	08 95       	ret

00003eee <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    3eee:	85 ed       	ldi	r24, 0xD5	; 213
    3ef0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    3ef4:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    3ef8:	84 fd       	sbrc	r24, 4
    3efa:	fc cf       	rjmp	.-8      	; 0x3ef4 <twi_stop+0x6>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    3efc:	10 92 c8 04 	sts	0x04C8, r1	; 0x8004c8 <twi_state>
    3f00:	08 95       	ret

00003f02 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    3f02:	85 ec       	ldi	r24, 0xC5	; 197
    3f04:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // update twi state
  twi_state = TWI_READY;
    3f08:	10 92 c8 04 	sts	0x04C8, r1	; 0x8004c8 <twi_state>
    3f0c:	08 95       	ret

00003f0e <__vector_26>:
}

ISR(TWI_vect)
{
    3f0e:	1f 92       	push	r1
    3f10:	0f 92       	push	r0
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	0f 92       	push	r0
    3f16:	11 24       	eor	r1, r1
    3f18:	2f 93       	push	r18
    3f1a:	3f 93       	push	r19
    3f1c:	4f 93       	push	r20
    3f1e:	5f 93       	push	r21
    3f20:	6f 93       	push	r22
    3f22:	7f 93       	push	r23
    3f24:	8f 93       	push	r24
    3f26:	9f 93       	push	r25
    3f28:	af 93       	push	r26
    3f2a:	bf 93       	push	r27
    3f2c:	ef 93       	push	r30
    3f2e:	ff 93       	push	r31
  switch(TW_STATUS){
    3f30:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    3f34:	88 7f       	andi	r24, 0xF8	; 248
    3f36:	80 36       	cpi	r24, 0x60	; 96
    3f38:	09 f4       	brne	.+2      	; 0x3f3c <__vector_26+0x2e>
    3f3a:	9e c0       	rjmp	.+316    	; 0x4078 <__vector_26+0x16a>
    3f3c:	78 f5       	brcc	.+94     	; 0x3f9c <__vector_26+0x8e>
    3f3e:	88 32       	cpi	r24, 0x28	; 40
    3f40:	09 f4       	brne	.+2      	; 0x3f44 <__vector_26+0x36>
    3f42:	5d c0       	rjmp	.+186    	; 0x3ffe <__vector_26+0xf0>
    3f44:	90 f4       	brcc	.+36     	; 0x3f6a <__vector_26+0x5c>
    3f46:	80 31       	cpi	r24, 0x10	; 16
    3f48:	09 f4       	brne	.+2      	; 0x3f4c <__vector_26+0x3e>
    3f4a:	56 c0       	rjmp	.+172    	; 0x3ff8 <__vector_26+0xea>
    3f4c:	38 f4       	brcc	.+14     	; 0x3f5c <__vector_26+0x4e>
    3f4e:	88 23       	and	r24, r24
    3f50:	09 f4       	brne	.+2      	; 0x3f54 <__vector_26+0x46>
    3f52:	f5 c0       	rjmp	.+490    	; 0x413e <__vector_26+0x230>
    3f54:	88 30       	cpi	r24, 0x08	; 8
    3f56:	09 f4       	brne	.+2      	; 0x3f5a <__vector_26+0x4c>
    3f58:	4f c0       	rjmp	.+158    	; 0x3ff8 <__vector_26+0xea>
    3f5a:	f5 c0       	rjmp	.+490    	; 0x4146 <__vector_26+0x238>
    3f5c:	88 31       	cpi	r24, 0x18	; 24
    3f5e:	09 f4       	brne	.+2      	; 0x3f62 <__vector_26+0x54>
    3f60:	4e c0       	rjmp	.+156    	; 0x3ffe <__vector_26+0xf0>
    3f62:	80 32       	cpi	r24, 0x20	; 32
    3f64:	09 f4       	brne	.+2      	; 0x3f68 <__vector_26+0x5a>
    3f66:	5f c0       	rjmp	.+190    	; 0x4026 <__vector_26+0x118>
    3f68:	ee c0       	rjmp	.+476    	; 0x4146 <__vector_26+0x238>
    3f6a:	80 34       	cpi	r24, 0x40	; 64
    3f6c:	09 f4       	brne	.+2      	; 0x3f70 <__vector_26+0x62>
    3f6e:	6a c0       	rjmp	.+212    	; 0x4044 <__vector_26+0x136>
    3f70:	58 f4       	brcc	.+22     	; 0x3f88 <__vector_26+0x7a>
    3f72:	80 33       	cpi	r24, 0x30	; 48
    3f74:	09 f4       	brne	.+2      	; 0x3f78 <__vector_26+0x6a>
    3f76:	57 c0       	rjmp	.+174    	; 0x4026 <__vector_26+0x118>
    3f78:	88 33       	cpi	r24, 0x38	; 56
    3f7a:	09 f0       	breq	.+2      	; 0x3f7e <__vector_26+0x70>
    3f7c:	e4 c0       	rjmp	.+456    	; 0x4146 <__vector_26+0x238>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    3f7e:	80 93 5b 04 	sts	0x045B, r24	; 0x80045b <twi_error>
      twi_releaseBus();
    3f82:	0e 94 81 1f 	call	0x3f02	; 0x3f02 <twi_releaseBus>
      break;
    3f86:	df c0       	rjmp	.+446    	; 0x4146 <__vector_26+0x238>
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    3f88:	80 35       	cpi	r24, 0x50	; 80
    3f8a:	09 f4       	brne	.+2      	; 0x3f8e <__vector_26+0x80>
    3f8c:	4f c0       	rjmp	.+158    	; 0x402c <__vector_26+0x11e>
    3f8e:	88 35       	cpi	r24, 0x58	; 88
    3f90:	09 f4       	brne	.+2      	; 0x3f94 <__vector_26+0x86>
    3f92:	5d c0       	rjmp	.+186    	; 0x404e <__vector_26+0x140>
    3f94:	88 34       	cpi	r24, 0x48	; 72
    3f96:	09 f0       	breq	.+2      	; 0x3f9a <__vector_26+0x8c>
    3f98:	d6 c0       	rjmp	.+428    	; 0x4146 <__vector_26+0x238>
    3f9a:	d3 c0       	rjmp	.+422    	; 0x4142 <__vector_26+0x234>
    3f9c:	88 39       	cpi	r24, 0x98	; 152
    3f9e:	09 f4       	brne	.+2      	; 0x3fa2 <__vector_26+0x94>
    3fa0:	c4 c0       	rjmp	.+392    	; 0x412a <__vector_26+0x21c>
    3fa2:	a8 f4       	brcc	.+42     	; 0x3fce <__vector_26+0xc0>
    3fa4:	88 37       	cpi	r24, 0x78	; 120
    3fa6:	09 f4       	brne	.+2      	; 0x3faa <__vector_26+0x9c>
    3fa8:	67 c0       	rjmp	.+206    	; 0x4078 <__vector_26+0x16a>
    3faa:	38 f4       	brcc	.+14     	; 0x3fba <__vector_26+0xac>
    3fac:	88 36       	cpi	r24, 0x68	; 104
    3fae:	09 f4       	brne	.+2      	; 0x3fb2 <__vector_26+0xa4>
    3fb0:	63 c0       	rjmp	.+198    	; 0x4078 <__vector_26+0x16a>
    3fb2:	80 37       	cpi	r24, 0x70	; 112
    3fb4:	09 f4       	brne	.+2      	; 0x3fb8 <__vector_26+0xaa>
    3fb6:	60 c0       	rjmp	.+192    	; 0x4078 <__vector_26+0x16a>
    3fb8:	c6 c0       	rjmp	.+396    	; 0x4146 <__vector_26+0x238>
    3fba:	88 38       	cpi	r24, 0x88	; 136
    3fbc:	09 f4       	brne	.+2      	; 0x3fc0 <__vector_26+0xb2>
    3fbe:	b5 c0       	rjmp	.+362    	; 0x412a <__vector_26+0x21c>
    3fc0:	80 39       	cpi	r24, 0x90	; 144
    3fc2:	09 f4       	brne	.+2      	; 0x3fc6 <__vector_26+0xb8>
    3fc4:	5f c0       	rjmp	.+190    	; 0x4084 <__vector_26+0x176>
    3fc6:	80 38       	cpi	r24, 0x80	; 128
    3fc8:	09 f0       	breq	.+2      	; 0x3fcc <__vector_26+0xbe>
    3fca:	bd c0       	rjmp	.+378    	; 0x4146 <__vector_26+0x238>
    3fcc:	5b c0       	rjmp	.+182    	; 0x4084 <__vector_26+0x176>
    3fce:	80 3b       	cpi	r24, 0xB0	; 176
    3fd0:	09 f4       	brne	.+2      	; 0x3fd4 <__vector_26+0xc6>
    3fd2:	83 c0       	rjmp	.+262    	; 0x40da <__vector_26+0x1cc>
    3fd4:	38 f4       	brcc	.+14     	; 0x3fe4 <__vector_26+0xd6>
    3fd6:	80 3a       	cpi	r24, 0xA0	; 160
    3fd8:	09 f4       	brne	.+2      	; 0x3fdc <__vector_26+0xce>
    3fda:	66 c0       	rjmp	.+204    	; 0x40a8 <__vector_26+0x19a>
    3fdc:	88 3a       	cpi	r24, 0xA8	; 168
    3fde:	09 f4       	brne	.+2      	; 0x3fe2 <__vector_26+0xd4>
    3fe0:	7c c0       	rjmp	.+248    	; 0x40da <__vector_26+0x1cc>
    3fe2:	b1 c0       	rjmp	.+354    	; 0x4146 <__vector_26+0x238>
    3fe4:	80 3c       	cpi	r24, 0xC0	; 192
    3fe6:	09 f4       	brne	.+2      	; 0x3fea <__vector_26+0xdc>
    3fe8:	a4 c0       	rjmp	.+328    	; 0x4132 <__vector_26+0x224>
    3fea:	88 3c       	cpi	r24, 0xC8	; 200
    3fec:	09 f4       	brne	.+2      	; 0x3ff0 <__vector_26+0xe2>
    3fee:	a1 c0       	rjmp	.+322    	; 0x4132 <__vector_26+0x224>
    3ff0:	88 3b       	cpi	r24, 0xB8	; 184
    3ff2:	09 f4       	brne	.+2      	; 0x3ff6 <__vector_26+0xe8>
    3ff4:	87 c0       	rjmp	.+270    	; 0x4104 <__vector_26+0x1f6>
    3ff6:	a7 c0       	rjmp	.+334    	; 0x4146 <__vector_26+0x238>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    3ff8:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <twi_slarw>
    3ffc:	10 c0       	rjmp	.+32     	; 0x401e <__vector_26+0x110>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    3ffe:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    4002:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <twi_masterBufferLength>
    4006:	98 17       	cp	r25, r24
    4008:	70 f5       	brcc	.+92     	; 0x4066 <__vector_26+0x158>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    400a:	e0 91 a0 04 	lds	r30, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    400e:	81 e0       	ldi	r24, 0x01	; 1
    4010:	8e 0f       	add	r24, r30
    4012:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <twi_masterBufferIndex>
    4016:	f0 e0       	ldi	r31, 0x00	; 0
    4018:	ef 55       	subi	r30, 0x5F	; 95
    401a:	fb 4f       	sbci	r31, 0xFB	; 251
    401c:	80 81       	ld	r24, Z
    401e:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    4022:	85 ec       	ldi	r24, 0xC5	; 197
    4024:	83 c0       	rjmp	.+262    	; 0x412c <__vector_26+0x21e>
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    4026:	80 93 5b 04 	sts	0x045B, r24	; 0x80045b <twi_error>
    402a:	8b c0       	rjmp	.+278    	; 0x4142 <__vector_26+0x234>
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    402c:	e0 91 a0 04 	lds	r30, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    4030:	81 e0       	ldi	r24, 0x01	; 1
    4032:	8e 0f       	add	r24, r30
    4034:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <twi_masterBufferIndex>
    4038:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    403c:	f0 e0       	ldi	r31, 0x00	; 0
    403e:	ef 55       	subi	r30, 0x5F	; 95
    4040:	fb 4f       	sbci	r31, 0xFB	; 251
    4042:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    4044:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    4048:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <twi_masterBufferLength>
    404c:	6b c0       	rjmp	.+214    	; 0x4124 <__vector_26+0x216>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    404e:	e0 91 a0 04 	lds	r30, 0x04A0	; 0x8004a0 <twi_masterBufferIndex>
    4052:	81 e0       	ldi	r24, 0x01	; 1
    4054:	8e 0f       	add	r24, r30
    4056:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <twi_masterBufferIndex>
    405a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    405e:	f0 e0       	ldi	r31, 0x00	; 0
    4060:	ef 55       	subi	r30, 0x5F	; 95
    4062:	fb 4f       	sbci	r31, 0xFB	; 251
    4064:	80 83       	st	Z, r24
	if (twi_sendStop)
    4066:	80 91 c6 04 	lds	r24, 0x04C6	; 0x8004c6 <twi_sendStop>
    406a:	81 11       	cpse	r24, r1
    406c:	6a c0       	rjmp	.+212    	; 0x4142 <__vector_26+0x234>
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    406e:	81 e0       	ldi	r24, 0x01	; 1
    4070:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <twi_inRepStart>
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    4074:	84 ea       	ldi	r24, 0xA4	; 164
    4076:	5e c0       	rjmp	.+188    	; 0x4134 <__vector_26+0x226>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    4078:	83 e0       	ldi	r24, 0x03	; 3
    407a:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <twi_state>
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    407e:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <twi_rxBufferIndex>
    4082:	cf cf       	rjmp	.-98     	; 0x4022 <__vector_26+0x114>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    4084:	80 91 5c 04 	lds	r24, 0x045C	; 0x80045c <twi_rxBufferIndex>
    4088:	80 32       	cpi	r24, 0x20	; 32
    408a:	08 f0       	brcs	.+2      	; 0x408e <__vector_26+0x180>
    408c:	4e c0       	rjmp	.+156    	; 0x412a <__vector_26+0x21c>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    408e:	e0 91 5c 04 	lds	r30, 0x045C	; 0x80045c <twi_rxBufferIndex>
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	8e 0f       	add	r24, r30
    4096:	80 93 5c 04 	sts	0x045C, r24	; 0x80045c <twi_rxBufferIndex>
    409a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    409e:	f0 e0       	ldi	r31, 0x00	; 0
    40a0:	e3 5a       	subi	r30, 0xA3	; 163
    40a2:	fb 4f       	sbci	r31, 0xFB	; 251
    40a4:	80 83       	st	Z, r24
    40a6:	bd cf       	rjmp	.-134    	; 0x4022 <__vector_26+0x114>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    40a8:	0e 94 81 1f 	call	0x3f02	; 0x3f02 <twi_releaseBus>
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    40ac:	80 91 5c 04 	lds	r24, 0x045C	; 0x80045c <twi_rxBufferIndex>
    40b0:	80 32       	cpi	r24, 0x20	; 32
    40b2:	30 f4       	brcc	.+12     	; 0x40c0 <__vector_26+0x1b2>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    40b4:	e0 91 5c 04 	lds	r30, 0x045C	; 0x80045c <twi_rxBufferIndex>
    40b8:	f0 e0       	ldi	r31, 0x00	; 0
    40ba:	e3 5a       	subi	r30, 0xA3	; 163
    40bc:	fb 4f       	sbci	r31, 0xFB	; 251
    40be:	10 82       	st	Z, r1
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    40c0:	60 91 5c 04 	lds	r22, 0x045C	; 0x80045c <twi_rxBufferIndex>
    40c4:	70 e0       	ldi	r23, 0x00	; 0
    40c6:	e0 91 c1 04 	lds	r30, 0x04C1	; 0x8004c1 <twi_onSlaveReceive>
    40ca:	f0 91 c2 04 	lds	r31, 0x04C2	; 0x8004c2 <twi_onSlaveReceive+0x1>
    40ce:	8d e5       	ldi	r24, 0x5D	; 93
    40d0:	94 e0       	ldi	r25, 0x04	; 4
    40d2:	09 95       	icall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    40d4:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <twi_rxBufferIndex>
      break;
    40d8:	36 c0       	rjmp	.+108    	; 0x4146 <__vector_26+0x238>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    40da:	84 e0       	ldi	r24, 0x04	; 4
    40dc:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <twi_state>
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    40e0:	10 92 7e 04 	sts	0x047E, r1	; 0x80047e <twi_txBufferIndex>
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    40e4:	10 92 7d 04 	sts	0x047D, r1	; 0x80047d <twi_txBufferLength>
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    40e8:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <twi_onSlaveTransmit>
    40ec:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <twi_onSlaveTransmit+0x1>
    40f0:	09 95       	icall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    40f2:	80 91 7d 04 	lds	r24, 0x047D	; 0x80047d <twi_txBufferLength>
    40f6:	81 11       	cpse	r24, r1
    40f8:	05 c0       	rjmp	.+10     	; 0x4104 <__vector_26+0x1f6>
        twi_txBufferLength = 1;
    40fa:	81 e0       	ldi	r24, 0x01	; 1
    40fc:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <twi_txBufferLength>
        twi_txBuffer[0] = 0x00;
    4100:	10 92 7f 04 	sts	0x047F, r1	; 0x80047f <twi_txBuffer>
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    4104:	e0 91 7e 04 	lds	r30, 0x047E	; 0x80047e <twi_txBufferIndex>
    4108:	81 e0       	ldi	r24, 0x01	; 1
    410a:	8e 0f       	add	r24, r30
    410c:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <twi_txBufferIndex>
    4110:	f0 e0       	ldi	r31, 0x00	; 0
    4112:	e1 58       	subi	r30, 0x81	; 129
    4114:	fb 4f       	sbci	r31, 0xFB	; 251
    4116:	80 81       	ld	r24, Z
    4118:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    411c:	90 91 7e 04 	lds	r25, 0x047E	; 0x80047e <twi_txBufferIndex>
    4120:	80 91 7d 04 	lds	r24, 0x047D	; 0x80047d <twi_txBufferLength>
    4124:	98 17       	cp	r25, r24
    4126:	08 f4       	brcc	.+2      	; 0x412a <__vector_26+0x21c>
    4128:	7c cf       	rjmp	.-264    	; 0x4022 <__vector_26+0x114>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    412a:	85 e8       	ldi	r24, 0x85	; 133
    412c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    4130:	0a c0       	rjmp	.+20     	; 0x4146 <__vector_26+0x238>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    4132:	85 ec       	ldi	r24, 0xC5	; 197
    4134:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    4138:	10 92 c8 04 	sts	0x04C8, r1	; 0x8004c8 <twi_state>
      break;
    413c:	04 c0       	rjmp	.+8      	; 0x4146 <__vector_26+0x238>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    413e:	10 92 5b 04 	sts	0x045B, r1	; 0x80045b <twi_error>
      twi_stop();
    4142:	0e 94 77 1f 	call	0x3eee	; 0x3eee <twi_stop>
      break;
  }
}
    4146:	ff 91       	pop	r31
    4148:	ef 91       	pop	r30
    414a:	bf 91       	pop	r27
    414c:	af 91       	pop	r26
    414e:	9f 91       	pop	r25
    4150:	8f 91       	pop	r24
    4152:	7f 91       	pop	r23
    4154:	6f 91       	pop	r22
    4156:	5f 91       	pop	r21
    4158:	4f 91       	pop	r20
    415a:	3f 91       	pop	r19
    415c:	2f 91       	pop	r18
    415e:	0f 90       	pop	r0
    4160:	0f be       	out	0x3f, r0	; 63
    4162:	0f 90       	pop	r0
    4164:	1f 90       	pop	r1
    4166:	18 95       	reti

00004168 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    4168:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <_ZN7TwoWire14rxBufferLengthE>
    416c:	90 e0       	ldi	r25, 0x00	; 0
    416e:	20 91 fa 04 	lds	r18, 0x04FA	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    4172:	82 1b       	sub	r24, r18
    4174:	91 09       	sbc	r25, r1
    4176:	08 95       	ret

00004178 <_ZN7TwoWire4readEv>:
    4178:	90 91 fa 04 	lds	r25, 0x04FA	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    417c:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <_ZN7TwoWire14rxBufferLengthE>
    4180:	98 17       	cp	r25, r24
    4182:	50 f4       	brcc	.+20     	; 0x4198 <_ZN7TwoWire4readEv+0x20>
    4184:	e9 2f       	mov	r30, r25
    4186:	f0 e0       	ldi	r31, 0x00	; 0
    4188:	e5 50       	subi	r30, 0x05	; 5
    418a:	fb 4f       	sbci	r31, 0xFB	; 251
    418c:	20 81       	ld	r18, Z
    418e:	30 e0       	ldi	r19, 0x00	; 0
    4190:	9f 5f       	subi	r25, 0xFF	; 255
    4192:	90 93 fa 04 	sts	0x04FA, r25	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    4196:	02 c0       	rjmp	.+4      	; 0x419c <_ZN7TwoWire4readEv+0x24>
    4198:	2f ef       	ldi	r18, 0xFF	; 255
    419a:	3f ef       	ldi	r19, 0xFF	; 255
    419c:	c9 01       	movw	r24, r18
    419e:	08 95       	ret

000041a0 <_ZN7TwoWire4peekEv>:
    41a0:	e0 91 fa 04 	lds	r30, 0x04FA	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    41a4:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <_ZN7TwoWire14rxBufferLengthE>
    41a8:	e8 17       	cp	r30, r24
    41aa:	30 f4       	brcc	.+12     	; 0x41b8 <_ZN7TwoWire4peekEv+0x18>
    41ac:	f0 e0       	ldi	r31, 0x00	; 0
    41ae:	e5 50       	subi	r30, 0x05	; 5
    41b0:	fb 4f       	sbci	r31, 0xFB	; 251
    41b2:	80 81       	ld	r24, Z
    41b4:	90 e0       	ldi	r25, 0x00	; 0
    41b6:	08 95       	ret
    41b8:	8f ef       	ldi	r24, 0xFF	; 255
    41ba:	9f ef       	ldi	r25, 0xFF	; 255
    41bc:	08 95       	ret

000041be <_ZN7TwoWire5flushEv>:
    41be:	08 95       	ret

000041c0 <_ZN7TwoWire5writeEPKhj>:
    41c0:	cf 92       	push	r12
    41c2:	df 92       	push	r13
    41c4:	ef 92       	push	r14
    41c6:	ff 92       	push	r15
    41c8:	0f 93       	push	r16
    41ca:	1f 93       	push	r17
    41cc:	cf 93       	push	r28
    41ce:	df 93       	push	r29
    41d0:	7c 01       	movw	r14, r24
    41d2:	cb 01       	movw	r24, r22
    41d4:	8a 01       	movw	r16, r20
    41d6:	20 91 d5 04 	lds	r18, 0x04D5	; 0x8004d5 <_ZN7TwoWire12transmittingE>
    41da:	22 23       	and	r18, r18
    41dc:	89 f0       	breq	.+34     	; 0x4200 <_ZN7TwoWire5writeEPKhj+0x40>
    41de:	eb 01       	movw	r28, r22
    41e0:	6b 01       	movw	r12, r22
    41e2:	c4 0e       	add	r12, r20
    41e4:	d5 1e       	adc	r13, r21
    41e6:	cc 15       	cp	r28, r12
    41e8:	dd 05       	cpc	r29, r13
    41ea:	69 f0       	breq	.+26     	; 0x4206 <_ZN7TwoWire5writeEPKhj+0x46>
    41ec:	69 91       	ld	r22, Y+
    41ee:	d7 01       	movw	r26, r14
    41f0:	ed 91       	ld	r30, X+
    41f2:	fc 91       	ld	r31, X
    41f4:	01 90       	ld	r0, Z+
    41f6:	f0 81       	ld	r31, Z
    41f8:	e0 2d       	mov	r30, r0
    41fa:	c7 01       	movw	r24, r14
    41fc:	09 95       	icall
    41fe:	f3 cf       	rjmp	.-26     	; 0x41e6 <_ZN7TwoWire5writeEPKhj+0x26>
    4200:	64 2f       	mov	r22, r20
    4202:	0e 94 4f 1f 	call	0x3e9e	; 0x3e9e <twi_transmit>
    4206:	c8 01       	movw	r24, r16
    4208:	df 91       	pop	r29
    420a:	cf 91       	pop	r28
    420c:	1f 91       	pop	r17
    420e:	0f 91       	pop	r16
    4210:	ff 90       	pop	r15
    4212:	ef 90       	pop	r14
    4214:	df 90       	pop	r13
    4216:	cf 90       	pop	r12
    4218:	08 95       	ret

0000421a <_ZN7TwoWire5writeEh>:
    421a:	cf 93       	push	r28
    421c:	df 93       	push	r29
    421e:	1f 92       	push	r1
    4220:	cd b7       	in	r28, 0x3d	; 61
    4222:	de b7       	in	r29, 0x3e	; 62
    4224:	69 83       	std	Y+1, r22	; 0x01
    4226:	20 91 d5 04 	lds	r18, 0x04D5	; 0x8004d5 <_ZN7TwoWire12transmittingE>
    422a:	22 23       	and	r18, r18
    422c:	d1 f0       	breq	.+52     	; 0x4262 <_ZN7TwoWire5writeEh+0x48>
    422e:	20 91 d6 04 	lds	r18, 0x04D6	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    4232:	20 32       	cpi	r18, 0x20	; 32
    4234:	40 f0       	brcs	.+16     	; 0x4246 <_ZN7TwoWire5writeEh+0x2c>
    4236:	21 e0       	ldi	r18, 0x01	; 1
    4238:	30 e0       	ldi	r19, 0x00	; 0
    423a:	fc 01       	movw	r30, r24
    423c:	33 83       	std	Z+3, r19	; 0x03
    423e:	22 83       	std	Z+2, r18	; 0x02
    4240:	80 e0       	ldi	r24, 0x00	; 0
    4242:	90 e0       	ldi	r25, 0x00	; 0
    4244:	15 c0       	rjmp	.+42     	; 0x4270 <_ZN7TwoWire5writeEh+0x56>
    4246:	80 91 d7 04 	lds	r24, 0x04D7	; 0x8004d7 <_ZN7TwoWire13txBufferIndexE>
    424a:	e8 2f       	mov	r30, r24
    424c:	f0 e0       	ldi	r31, 0x00	; 0
    424e:	e8 52       	subi	r30, 0x28	; 40
    4250:	fb 4f       	sbci	r31, 0xFB	; 251
    4252:	99 81       	ldd	r25, Y+1	; 0x01
    4254:	90 83       	st	Z, r25
    4256:	8f 5f       	subi	r24, 0xFF	; 255
    4258:	80 93 d7 04 	sts	0x04D7, r24	; 0x8004d7 <_ZN7TwoWire13txBufferIndexE>
    425c:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    4260:	05 c0       	rjmp	.+10     	; 0x426c <_ZN7TwoWire5writeEh+0x52>
    4262:	61 e0       	ldi	r22, 0x01	; 1
    4264:	ce 01       	movw	r24, r28
    4266:	01 96       	adiw	r24, 0x01	; 1
    4268:	0e 94 4f 1f 	call	0x3e9e	; 0x3e9e <twi_transmit>
    426c:	81 e0       	ldi	r24, 0x01	; 1
    426e:	90 e0       	ldi	r25, 0x00	; 0
    4270:	0f 90       	pop	r0
    4272:	df 91       	pop	r29
    4274:	cf 91       	pop	r28
    4276:	08 95       	ret

00004278 <_ZN7TwoWireC1Ev>:
    4278:	fc 01       	movw	r30, r24
    427a:	13 82       	std	Z+3, r1	; 0x03
    427c:	12 82       	std	Z+2, r1	; 0x02
    427e:	88 ee       	ldi	r24, 0xE8	; 232
    4280:	93 e0       	ldi	r25, 0x03	; 3
    4282:	a0 e0       	ldi	r26, 0x00	; 0
    4284:	b0 e0       	ldi	r27, 0x00	; 0
    4286:	84 83       	std	Z+4, r24	; 0x04
    4288:	95 83       	std	Z+5, r25	; 0x05
    428a:	a6 83       	std	Z+6, r26	; 0x06
    428c:	b7 83       	std	Z+7, r27	; 0x07
    428e:	86 ef       	ldi	r24, 0xF6	; 246
    4290:	91 e0       	ldi	r25, 0x01	; 1
    4292:	91 83       	std	Z+1, r25	; 0x01
    4294:	80 83       	st	Z, r24
    4296:	08 95       	ret

00004298 <_ZN7TwoWire5beginEv>:
    4298:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    429c:	10 92 f9 04 	sts	0x04F9, r1	; 0x8004f9 <_ZN7TwoWire14rxBufferLengthE>
    42a0:	10 92 d7 04 	sts	0x04D7, r1	; 0x8004d7 <_ZN7TwoWire13txBufferIndexE>
    42a4:	10 92 d6 04 	sts	0x04D6, r1	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    42a8:	0c 94 93 1e 	jmp	0x3d26	; 0x3d26 <twi_init>

000042ac <_ZN7TwoWire17beginTransmissionEh>:
    42ac:	81 e0       	ldi	r24, 0x01	; 1
    42ae:	80 93 d5 04 	sts	0x04D5, r24	; 0x8004d5 <_ZN7TwoWire12transmittingE>
    42b2:	60 93 f8 04 	sts	0x04F8, r22	; 0x8004f8 <_ZN7TwoWire9txAddressE>
    42b6:	10 92 d7 04 	sts	0x04D7, r1	; 0x8004d7 <_ZN7TwoWire13txBufferIndexE>
    42ba:	10 92 d6 04 	sts	0x04D6, r1	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    42be:	08 95       	ret

000042c0 <_ZN7TwoWire17beginTransmissionEi>:
    42c0:	0c 94 56 21 	jmp	0x42ac	; 0x42ac <_ZN7TwoWire17beginTransmissionEh>

000042c4 <_ZN7TwoWire15endTransmissionEh>:
    42c4:	0f 93       	push	r16
    42c6:	06 2f       	mov	r16, r22
    42c8:	21 e0       	ldi	r18, 0x01	; 1
    42ca:	40 91 d6 04 	lds	r20, 0x04D6	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    42ce:	68 ed       	ldi	r22, 0xD8	; 216
    42d0:	74 e0       	ldi	r23, 0x04	; 4
    42d2:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <_ZN7TwoWire9txAddressE>
    42d6:	0e 94 f9 1e 	call	0x3df2	; 0x3df2 <twi_writeTo>
    42da:	10 92 d7 04 	sts	0x04D7, r1	; 0x8004d7 <_ZN7TwoWire13txBufferIndexE>
    42de:	10 92 d6 04 	sts	0x04D6, r1	; 0x8004d6 <_ZN7TwoWire14txBufferLengthE>
    42e2:	10 92 d5 04 	sts	0x04D5, r1	; 0x8004d5 <_ZN7TwoWire12transmittingE>
    42e6:	0f 91       	pop	r16
    42e8:	08 95       	ret

000042ea <_ZN7TwoWire11requestFromEhhmhh>:
    42ea:	4f 92       	push	r4
    42ec:	5f 92       	push	r5
    42ee:	6f 92       	push	r6
    42f0:	7f 92       	push	r7
    42f2:	af 92       	push	r10
    42f4:	bf 92       	push	r11
    42f6:	cf 92       	push	r12
    42f8:	ef 92       	push	r14
    42fa:	ff 92       	push	r15
    42fc:	0f 93       	push	r16
    42fe:	1f 93       	push	r17
    4300:	cf 93       	push	r28
    4302:	df 93       	push	r29
    4304:	5c 01       	movw	r10, r24
    4306:	f6 2e       	mov	r15, r22
    4308:	d4 2f       	mov	r29, r20
    430a:	28 01       	movw	r4, r16
    430c:	39 01       	movw	r6, r18
    430e:	ee 20       	and	r14, r14
    4310:	21 f1       	breq	.+72     	; 0x435a <_ZN7TwoWire11requestFromEhhmhh+0x70>
    4312:	0e 94 56 21 	call	0x42ac	; 0x42ac <_ZN7TwoWire17beginTransmissionEh>
    4316:	ce 2d       	mov	r28, r14
    4318:	c4 30       	cpi	r28, 0x04	; 4
    431a:	08 f0       	brcs	.+2      	; 0x431e <_ZN7TwoWire11requestFromEhhmhh+0x34>
    431c:	c3 e0       	ldi	r28, 0x03	; 3
    431e:	c1 50       	subi	r28, 0x01	; 1
    4320:	c0 f0       	brcs	.+48     	; 0x4352 <_ZN7TwoWire11requestFromEhhmhh+0x68>
    4322:	28 e0       	ldi	r18, 0x08	; 8
    4324:	c2 9f       	mul	r28, r18
    4326:	c0 01       	movw	r24, r0
    4328:	11 24       	eor	r1, r1
    432a:	a3 01       	movw	r20, r6
    432c:	92 01       	movw	r18, r4
    432e:	04 c0       	rjmp	.+8      	; 0x4338 <_ZN7TwoWire11requestFromEhhmhh+0x4e>
    4330:	56 95       	lsr	r21
    4332:	47 95       	ror	r20
    4334:	37 95       	ror	r19
    4336:	27 95       	ror	r18
    4338:	8a 95       	dec	r24
    433a:	d2 f7       	brpl	.-12     	; 0x4330 <_ZN7TwoWire11requestFromEhhmhh+0x46>
    433c:	ca 01       	movw	r24, r20
    433e:	b9 01       	movw	r22, r18
    4340:	d5 01       	movw	r26, r10
    4342:	ed 91       	ld	r30, X+
    4344:	fc 91       	ld	r31, X
    4346:	01 90       	ld	r0, Z+
    4348:	f0 81       	ld	r31, Z
    434a:	e0 2d       	mov	r30, r0
    434c:	c5 01       	movw	r24, r10
    434e:	09 95       	icall
    4350:	e6 cf       	rjmp	.-52     	; 0x431e <_ZN7TwoWire11requestFromEhhmhh+0x34>
    4352:	60 e0       	ldi	r22, 0x00	; 0
    4354:	c5 01       	movw	r24, r10
    4356:	0e 94 62 21 	call	0x42c4	; 0x42c4 <_ZN7TwoWire15endTransmissionEh>
    435a:	4d 2f       	mov	r20, r29
    435c:	d1 32       	cpi	r29, 0x21	; 33
    435e:	08 f0       	brcs	.+2      	; 0x4362 <_ZN7TwoWire11requestFromEhhmhh+0x78>
    4360:	40 e2       	ldi	r20, 0x20	; 32
    4362:	2c 2d       	mov	r18, r12
    4364:	6b ef       	ldi	r22, 0xFB	; 251
    4366:	74 e0       	ldi	r23, 0x04	; 4
    4368:	8f 2d       	mov	r24, r15
    436a:	0e 94 b1 1e 	call	0x3d62	; 0x3d62 <twi_readFrom>
    436e:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <_ZN7TwoWire13rxBufferIndexE>
    4372:	80 93 f9 04 	sts	0x04F9, r24	; 0x8004f9 <_ZN7TwoWire14rxBufferLengthE>
    4376:	df 91       	pop	r29
    4378:	cf 91       	pop	r28
    437a:	1f 91       	pop	r17
    437c:	0f 91       	pop	r16
    437e:	ff 90       	pop	r15
    4380:	ef 90       	pop	r14
    4382:	cf 90       	pop	r12
    4384:	bf 90       	pop	r11
    4386:	af 90       	pop	r10
    4388:	7f 90       	pop	r7
    438a:	6f 90       	pop	r6
    438c:	5f 90       	pop	r5
    438e:	4f 90       	pop	r4
    4390:	08 95       	ret

00004392 <_ZN7TwoWire11requestFromEhhh>:
    4392:	cf 92       	push	r12
    4394:	ef 92       	push	r14
    4396:	0f 93       	push	r16
    4398:	1f 93       	push	r17
    439a:	c2 2e       	mov	r12, r18
    439c:	e1 2c       	mov	r14, r1
    439e:	00 e0       	ldi	r16, 0x00	; 0
    43a0:	10 e0       	ldi	r17, 0x00	; 0
    43a2:	98 01       	movw	r18, r16
    43a4:	0e 94 75 21 	call	0x42ea	; 0x42ea <_ZN7TwoWire11requestFromEhhmhh>
    43a8:	1f 91       	pop	r17
    43aa:	0f 91       	pop	r16
    43ac:	ef 90       	pop	r14
    43ae:	cf 90       	pop	r12
    43b0:	08 95       	ret

000043b2 <_ZN7TwoWire11requestFromEii>:
    43b2:	21 e0       	ldi	r18, 0x01	; 1
    43b4:	0c 94 c9 21 	jmp	0x4392	; 0x4392 <_ZN7TwoWire11requestFromEhhh>

000043b8 <_ZN7TwoWire15endTransmissionEv>:
    43b8:	61 e0       	ldi	r22, 0x01	; 1
    43ba:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <_ZN7TwoWire15endTransmissionEh>

000043be <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    43be:	89 ec       	ldi	r24, 0xC9	; 201
    43c0:	94 e0       	ldi	r25, 0x04	; 4
    43c2:	0c 94 3c 21 	jmp	0x4278	; 0x4278 <_ZN7TwoWireC1Ev>

000043c6 <__cxa_pure_virtual>:
    43c6:	0e 94 5f 2a 	call	0x54be	; 0x54be <abort>

000043ca <__vector_20>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    43ca:	1f 92       	push	r1
    43cc:	0f 92       	push	r0
    43ce:	0f b6       	in	r0, 0x3f	; 63
    43d0:	0f 92       	push	r0
    43d2:	11 24       	eor	r1, r1
    43d4:	2f 93       	push	r18
    43d6:	8f 93       	push	r24
    43d8:	9f 93       	push	r25
    43da:	ef 93       	push	r30
    43dc:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    43de:	e0 91 2b 05 	lds	r30, 0x052B	; 0x80052b <Serial+0x10>
    43e2:	f0 91 2c 05 	lds	r31, 0x052C	; 0x80052c <Serial+0x11>
    43e6:	80 81       	ld	r24, Z
    43e8:	e0 91 31 05 	lds	r30, 0x0531	; 0x800531 <Serial+0x16>
    43ec:	f0 91 32 05 	lds	r31, 0x0532	; 0x800532 <Serial+0x17>
    43f0:	82 fd       	sbrc	r24, 2
    43f2:	12 c0       	rjmp	.+36     	; 0x4418 <__vector_20+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    43f4:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    43f6:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <Serial+0x19>
    43fa:	8f 5f       	subi	r24, 0xFF	; 255
    43fc:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    43fe:	20 91 35 05 	lds	r18, 0x0535	; 0x800535 <Serial+0x1a>
    4402:	82 17       	cp	r24, r18
    4404:	51 f0       	breq	.+20     	; 0x441a <__vector_20+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    4406:	e0 91 34 05 	lds	r30, 0x0534	; 0x800534 <Serial+0x19>
    440a:	f0 e0       	ldi	r31, 0x00	; 0
    440c:	e5 5e       	subi	r30, 0xE5	; 229
    440e:	fa 4f       	sbci	r31, 0xFA	; 250
    4410:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    4412:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <Serial+0x19>
    4416:	01 c0       	rjmp	.+2      	; 0x441a <__vector_20+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    4418:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    441a:	ff 91       	pop	r31
    441c:	ef 91       	pop	r30
    441e:	9f 91       	pop	r25
    4420:	8f 91       	pop	r24
    4422:	2f 91       	pop	r18
    4424:	0f 90       	pop	r0
    4426:	0f be       	out	0x3f, r0	; 63
    4428:	0f 90       	pop	r0
    442a:	1f 90       	pop	r1
    442c:	18 95       	reti

0000442e <__vector_21>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    442e:	1f 92       	push	r1
    4430:	0f 92       	push	r0
    4432:	0f b6       	in	r0, 0x3f	; 63
    4434:	0f 92       	push	r0
    4436:	11 24       	eor	r1, r1
    4438:	2f 93       	push	r18
    443a:	3f 93       	push	r19
    443c:	4f 93       	push	r20
    443e:	5f 93       	push	r21
    4440:	6f 93       	push	r22
    4442:	7f 93       	push	r23
    4444:	8f 93       	push	r24
    4446:	9f 93       	push	r25
    4448:	af 93       	push	r26
    444a:	bf 93       	push	r27
    444c:	ef 93       	push	r30
    444e:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    4450:	8b e1       	ldi	r24, 0x1B	; 27
    4452:	95 e0       	ldi	r25, 0x05	; 5
    4454:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    4458:	ff 91       	pop	r31
    445a:	ef 91       	pop	r30
    445c:	bf 91       	pop	r27
    445e:	af 91       	pop	r26
    4460:	9f 91       	pop	r25
    4462:	8f 91       	pop	r24
    4464:	7f 91       	pop	r23
    4466:	6f 91       	pop	r22
    4468:	5f 91       	pop	r21
    446a:	4f 91       	pop	r20
    446c:	3f 91       	pop	r19
    446e:	2f 91       	pop	r18
    4470:	0f 90       	pop	r0
    4472:	0f be       	out	0x3f, r0	; 63
    4474:	0f 90       	pop	r0
    4476:	1f 90       	pop	r1
    4478:	18 95       	reti

0000447a <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    447a:	8b e1       	ldi	r24, 0x1B	; 27
    447c:	95 e0       	ldi	r25, 0x05	; 5
    447e:	0e 94 55 26 	call	0x4caa	; 0x4caa <_ZN14HardwareSerial9availableEv>
    4482:	21 e0       	ldi	r18, 0x01	; 1
    4484:	89 2b       	or	r24, r25
    4486:	09 f4       	brne	.+2      	; 0x448a <_Z17Serial0_availablev+0x10>
    4488:	20 e0       	ldi	r18, 0x00	; 0
}
    448a:	82 2f       	mov	r24, r18
    448c:	08 95       	ret

0000448e <_GLOBAL__sub_I___vector_20>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    448e:	eb e1       	ldi	r30, 0x1B	; 27
    4490:	f5 e0       	ldi	r31, 0x05	; 5
    4492:	13 82       	std	Z+3, r1	; 0x03
    4494:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    4496:	88 ee       	ldi	r24, 0xE8	; 232
    4498:	93 e0       	ldi	r25, 0x03	; 3
    449a:	a0 e0       	ldi	r26, 0x00	; 0
    449c:	b0 e0       	ldi	r27, 0x00	; 0
    449e:	84 83       	std	Z+4, r24	; 0x04
    44a0:	95 83       	std	Z+5, r25	; 0x05
    44a2:	a6 83       	std	Z+6, r26	; 0x06
    44a4:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    44a6:	87 e1       	ldi	r24, 0x17	; 23
    44a8:	92 e0       	ldi	r25, 0x02	; 2
    44aa:	91 83       	std	Z+1, r25	; 0x01
    44ac:	80 83       	st	Z, r24
    44ae:	85 ec       	ldi	r24, 0xC5	; 197
    44b0:	90 e0       	ldi	r25, 0x00	; 0
    44b2:	95 87       	std	Z+13, r25	; 0x0d
    44b4:	84 87       	std	Z+12, r24	; 0x0c
    44b6:	84 ec       	ldi	r24, 0xC4	; 196
    44b8:	90 e0       	ldi	r25, 0x00	; 0
    44ba:	97 87       	std	Z+15, r25	; 0x0f
    44bc:	86 87       	std	Z+14, r24	; 0x0e
    44be:	80 ec       	ldi	r24, 0xC0	; 192
    44c0:	90 e0       	ldi	r25, 0x00	; 0
    44c2:	91 8b       	std	Z+17, r25	; 0x11
    44c4:	80 8b       	std	Z+16, r24	; 0x10
    44c6:	81 ec       	ldi	r24, 0xC1	; 193
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	93 8b       	std	Z+19, r25	; 0x13
    44cc:	82 8b       	std	Z+18, r24	; 0x12
    44ce:	82 ec       	ldi	r24, 0xC2	; 194
    44d0:	90 e0       	ldi	r25, 0x00	; 0
    44d2:	95 8b       	std	Z+21, r25	; 0x15
    44d4:	84 8b       	std	Z+20, r24	; 0x14
    44d6:	86 ec       	ldi	r24, 0xC6	; 198
    44d8:	90 e0       	ldi	r25, 0x00	; 0
    44da:	97 8b       	std	Z+23, r25	; 0x17
    44dc:	86 8b       	std	Z+22, r24	; 0x16
    44de:	11 8e       	std	Z+25, r1	; 0x19
    44e0:	12 8e       	std	Z+26, r1	; 0x1a
    44e2:	13 8e       	std	Z+27, r1	; 0x1b
    44e4:	14 8e       	std	Z+28, r1	; 0x1c
    44e6:	08 95       	ret

000044e8 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    44e8:	08 95       	ret

000044ea <initVariant>:
    44ea:	08 95       	ret

000044ec <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    44ec:	0e 94 46 24 	call	0x488c	; 0x488c <init>

	initVariant();
    44f0:	0e 94 75 22 	call	0x44ea	; 0x44ea <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    44f4:	0e 94 21 0a 	call	0x1442	; 0x1442 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    44f8:	c2 e9       	ldi	r28, 0x92	; 146
    44fa:	d6 e2       	ldi	r29, 0x26	; 38
#endif
	
	setup();
    
	for (;;) {
		loop();
    44fc:	0e 94 af 10 	call	0x215e	; 0x215e <loop>
		if (serialEventRun) serialEventRun();
    4500:	20 97       	sbiw	r28, 0x00	; 0
    4502:	e1 f3       	breq	.-8      	; 0x44fc <main+0x10>
    4504:	0e 94 92 26 	call	0x4d24	; 0x4d24 <_Z14serialEventRunv>
    4508:	f9 cf       	rjmp	.-14     	; 0x44fc <main+0x10>

0000450a <_Znwj>:
    450a:	0c 94 d6 27 	jmp	0x4fac	; 0x4fac <malloc>

0000450e <_ZdlPv>:
    450e:	0c 94 6e 28 	jmp	0x50dc	; 0x50dc <free>

00004512 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    4512:	cf 92       	push	r12
    4514:	df 92       	push	r13
    4516:	ef 92       	push	r14
    4518:	ff 92       	push	r15
    451a:	0f 93       	push	r16
    451c:	1f 93       	push	r17
    451e:	cf 93       	push	r28
    4520:	df 93       	push	r29
    4522:	6c 01       	movw	r12, r24
    4524:	7a 01       	movw	r14, r20
    4526:	8b 01       	movw	r16, r22
    4528:	c0 e0       	ldi	r28, 0x00	; 0
    452a:	d0 e0       	ldi	r29, 0x00	; 0
    452c:	ce 15       	cp	r28, r14
    452e:	df 05       	cpc	r29, r15
    4530:	81 f0       	breq	.+32     	; 0x4552 <_ZN5Print5writeEPKhj+0x40>
    4532:	d8 01       	movw	r26, r16
    4534:	6d 91       	ld	r22, X+
    4536:	8d 01       	movw	r16, r26
    4538:	d6 01       	movw	r26, r12
    453a:	ed 91       	ld	r30, X+
    453c:	fc 91       	ld	r31, X
    453e:	01 90       	ld	r0, Z+
    4540:	f0 81       	ld	r31, Z
    4542:	e0 2d       	mov	r30, r0
    4544:	c6 01       	movw	r24, r12
    4546:	09 95       	icall
    4548:	89 2b       	or	r24, r25
    454a:	11 f0       	breq	.+4      	; 0x4550 <_ZN5Print5writeEPKhj+0x3e>
    454c:	21 96       	adiw	r28, 0x01	; 1
    454e:	ee cf       	rjmp	.-36     	; 0x452c <_ZN5Print5writeEPKhj+0x1a>
    4550:	7e 01       	movw	r14, r28
    4552:	c7 01       	movw	r24, r14
    4554:	df 91       	pop	r29
    4556:	cf 91       	pop	r28
    4558:	1f 91       	pop	r17
    455a:	0f 91       	pop	r16
    455c:	ff 90       	pop	r15
    455e:	ef 90       	pop	r14
    4560:	df 90       	pop	r13
    4562:	cf 90       	pop	r12
    4564:	08 95       	ret

00004566 <_ZN5Print5writeEPKc>:
    4566:	61 15       	cp	r22, r1
    4568:	71 05       	cpc	r23, r1
    456a:	79 f0       	breq	.+30     	; 0x458a <_ZN5Print5writeEPKc+0x24>
    456c:	fb 01       	movw	r30, r22
    456e:	01 90       	ld	r0, Z+
    4570:	00 20       	and	r0, r0
    4572:	e9 f7       	brne	.-6      	; 0x456e <_ZN5Print5writeEPKc+0x8>
    4574:	31 97       	sbiw	r30, 0x01	; 1
    4576:	af 01       	movw	r20, r30
    4578:	46 1b       	sub	r20, r22
    457a:	57 0b       	sbc	r21, r23
    457c:	dc 01       	movw	r26, r24
    457e:	ed 91       	ld	r30, X+
    4580:	fc 91       	ld	r31, X
    4582:	02 80       	ldd	r0, Z+2	; 0x02
    4584:	f3 81       	ldd	r31, Z+3	; 0x03
    4586:	e0 2d       	mov	r30, r0
    4588:	09 94       	ijmp
    458a:	80 e0       	ldi	r24, 0x00	; 0
    458c:	90 e0       	ldi	r25, 0x00	; 0
    458e:	08 95       	ret

00004590 <_ZN5Print5printEc>:
    4590:	dc 01       	movw	r26, r24
    4592:	ed 91       	ld	r30, X+
    4594:	fc 91       	ld	r31, X
    4596:	01 90       	ld	r0, Z+
    4598:	f0 81       	ld	r31, Z
    459a:	e0 2d       	mov	r30, r0
    459c:	09 94       	ijmp

0000459e <_ZN5Print7printlnEv>:
    459e:	64 e0       	ldi	r22, 0x04	; 4
    45a0:	72 e0       	ldi	r23, 0x02	; 2
    45a2:	0c 94 b3 22 	jmp	0x4566	; 0x4566 <_ZN5Print5writeEPKc>

000045a6 <_ZN5Print7printlnEPKc>:
    45a6:	0f 93       	push	r16
    45a8:	1f 93       	push	r17
    45aa:	cf 93       	push	r28
    45ac:	df 93       	push	r29
    45ae:	ec 01       	movw	r28, r24
    45b0:	0e 94 b3 22 	call	0x4566	; 0x4566 <_ZN5Print5writeEPKc>
    45b4:	8c 01       	movw	r16, r24
    45b6:	ce 01       	movw	r24, r28
    45b8:	0e 94 cf 22 	call	0x459e	; 0x459e <_ZN5Print7printlnEv>
    45bc:	80 0f       	add	r24, r16
    45be:	91 1f       	adc	r25, r17
    45c0:	df 91       	pop	r29
    45c2:	cf 91       	pop	r28
    45c4:	1f 91       	pop	r17
    45c6:	0f 91       	pop	r16
    45c8:	08 95       	ret

000045ca <_ZN5Print11printNumberEmh>:
    45ca:	8f 92       	push	r8
    45cc:	9f 92       	push	r9
    45ce:	af 92       	push	r10
    45d0:	bf 92       	push	r11
    45d2:	ef 92       	push	r14
    45d4:	ff 92       	push	r15
    45d6:	0f 93       	push	r16
    45d8:	1f 93       	push	r17
    45da:	cf 93       	push	r28
    45dc:	df 93       	push	r29
    45de:	cd b7       	in	r28, 0x3d	; 61
    45e0:	de b7       	in	r29, 0x3e	; 62
    45e2:	a1 97       	sbiw	r28, 0x21	; 33
    45e4:	0f b6       	in	r0, 0x3f	; 63
    45e6:	f8 94       	cli
    45e8:	de bf       	out	0x3e, r29	; 62
    45ea:	0f be       	out	0x3f, r0	; 63
    45ec:	cd bf       	out	0x3d, r28	; 61
    45ee:	7c 01       	movw	r14, r24
    45f0:	fa 01       	movw	r30, r20
    45f2:	cb 01       	movw	r24, r22
    45f4:	19 a2       	std	Y+33, r1	; 0x21
    45f6:	22 30       	cpi	r18, 0x02	; 2
    45f8:	08 f4       	brcc	.+2      	; 0x45fc <_ZN5Print11printNumberEmh+0x32>
    45fa:	2a e0       	ldi	r18, 0x0A	; 10
    45fc:	8e 01       	movw	r16, r28
    45fe:	0f 5d       	subi	r16, 0xDF	; 223
    4600:	1f 4f       	sbci	r17, 0xFF	; 255
    4602:	82 2e       	mov	r8, r18
    4604:	91 2c       	mov	r9, r1
    4606:	a1 2c       	mov	r10, r1
    4608:	b1 2c       	mov	r11, r1
    460a:	bf 01       	movw	r22, r30
    460c:	a5 01       	movw	r20, r10
    460e:	94 01       	movw	r18, r8
    4610:	0e 94 6e 27 	call	0x4edc	; 0x4edc <__udivmodsi4>
    4614:	f9 01       	movw	r30, r18
    4616:	ca 01       	movw	r24, r20
    4618:	01 50       	subi	r16, 0x01	; 1
    461a:	11 09       	sbc	r17, r1
    461c:	6a 30       	cpi	r22, 0x0A	; 10
    461e:	10 f4       	brcc	.+4      	; 0x4624 <_ZN5Print11printNumberEmh+0x5a>
    4620:	60 5d       	subi	r22, 0xD0	; 208
    4622:	01 c0       	rjmp	.+2      	; 0x4626 <_ZN5Print11printNumberEmh+0x5c>
    4624:	69 5c       	subi	r22, 0xC9	; 201
    4626:	d8 01       	movw	r26, r16
    4628:	6c 93       	st	X, r22
    462a:	23 2b       	or	r18, r19
    462c:	24 2b       	or	r18, r20
    462e:	25 2b       	or	r18, r21
    4630:	61 f7       	brne	.-40     	; 0x460a <_ZN5Print11printNumberEmh+0x40>
    4632:	b8 01       	movw	r22, r16
    4634:	c7 01       	movw	r24, r14
    4636:	0e 94 b3 22 	call	0x4566	; 0x4566 <_ZN5Print5writeEPKc>
    463a:	a1 96       	adiw	r28, 0x21	; 33
    463c:	0f b6       	in	r0, 0x3f	; 63
    463e:	f8 94       	cli
    4640:	de bf       	out	0x3e, r29	; 62
    4642:	0f be       	out	0x3f, r0	; 63
    4644:	cd bf       	out	0x3d, r28	; 61
    4646:	df 91       	pop	r29
    4648:	cf 91       	pop	r28
    464a:	1f 91       	pop	r17
    464c:	0f 91       	pop	r16
    464e:	ff 90       	pop	r15
    4650:	ef 90       	pop	r14
    4652:	bf 90       	pop	r11
    4654:	af 90       	pop	r10
    4656:	9f 90       	pop	r9
    4658:	8f 90       	pop	r8
    465a:	08 95       	ret

0000465c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    465c:	cf 92       	push	r12
    465e:	df 92       	push	r13
    4660:	ef 92       	push	r14
    4662:	ff 92       	push	r15
    4664:	0f 93       	push	r16
    4666:	1f 93       	push	r17
    4668:	cf 93       	push	r28
    466a:	df 93       	push	r29
  if (base == 0) {
    466c:	21 15       	cp	r18, r1
    466e:	31 05       	cpc	r19, r1
    4670:	81 f4       	brne	.+32     	; 0x4692 <_ZN5Print5printEli+0x36>
    return write(n);
    4672:	dc 01       	movw	r26, r24
    4674:	ed 91       	ld	r30, X+
    4676:	fc 91       	ld	r31, X
    4678:	01 90       	ld	r0, Z+
    467a:	f0 81       	ld	r31, Z
    467c:	e0 2d       	mov	r30, r0
    467e:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    4680:	df 91       	pop	r29
    4682:	cf 91       	pop	r28
    4684:	1f 91       	pop	r17
    4686:	0f 91       	pop	r16
    4688:	ff 90       	pop	r15
    468a:	ef 90       	pop	r14
    468c:	df 90       	pop	r13
    468e:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
    4690:	09 94       	ijmp
  } else if (base == 10) {
    4692:	2a 30       	cpi	r18, 0x0A	; 10
    4694:	31 05       	cpc	r19, r1
    4696:	01 f5       	brne	.+64     	; 0x46d8 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
    4698:	77 ff       	sbrs	r23, 7
    469a:	1d c0       	rjmp	.+58     	; 0x46d6 <_ZN5Print5printEli+0x7a>
    469c:	6a 01       	movw	r12, r20
    469e:	7b 01       	movw	r14, r22
    46a0:	ec 01       	movw	r28, r24
      int t = print('-');
    46a2:	6d e2       	ldi	r22, 0x2D	; 45
    46a4:	0e 94 c8 22 	call	0x4590	; 0x4590 <_ZN5Print5printEc>
    46a8:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
    46aa:	44 27       	eor	r20, r20
    46ac:	55 27       	eor	r21, r21
    46ae:	ba 01       	movw	r22, r20
    46b0:	4c 19       	sub	r20, r12
    46b2:	5d 09       	sbc	r21, r13
    46b4:	6e 09       	sbc	r22, r14
    46b6:	7f 09       	sbc	r23, r15
    46b8:	2a e0       	ldi	r18, 0x0A	; 10
    46ba:	ce 01       	movw	r24, r28
    46bc:	0e 94 e5 22 	call	0x45ca	; 0x45ca <_ZN5Print11printNumberEmh>
    46c0:	80 0f       	add	r24, r16
    46c2:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    46c4:	df 91       	pop	r29
    46c6:	cf 91       	pop	r28
    46c8:	1f 91       	pop	r17
    46ca:	0f 91       	pop	r16
    46cc:	ff 90       	pop	r15
    46ce:	ef 90       	pop	r14
    46d0:	df 90       	pop	r13
    46d2:	cf 90       	pop	r12
    46d4:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    46d6:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
    46d8:	df 91       	pop	r29
    46da:	cf 91       	pop	r28
    46dc:	1f 91       	pop	r17
    46de:	0f 91       	pop	r16
    46e0:	ff 90       	pop	r15
    46e2:	ef 90       	pop	r14
    46e4:	df 90       	pop	r13
    46e6:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    46e8:	0c 94 e5 22 	jmp	0x45ca	; 0x45ca <_ZN5Print11printNumberEmh>

000046ec <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    46ec:	9a 01       	movw	r18, r20
  return print((long) n, base);
    46ee:	ab 01       	movw	r20, r22
    46f0:	77 0f       	add	r23, r23
    46f2:	66 0b       	sbc	r22, r22
    46f4:	77 0b       	sbc	r23, r23
    46f6:	0c 94 2e 23 	jmp	0x465c	; 0x465c <_ZN5Print5printEli>

000046fa <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    46fa:	0f 93       	push	r16
    46fc:	1f 93       	push	r17
    46fe:	cf 93       	push	r28
    4700:	df 93       	push	r29
    4702:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
    4704:	0e 94 76 23 	call	0x46ec	; 0x46ec <_ZN5Print5printEii>
    4708:	8c 01       	movw	r16, r24
  n += println();
    470a:	ce 01       	movw	r24, r28
    470c:	0e 94 cf 22 	call	0x459e	; 0x459e <_ZN5Print7printlnEv>
  return n;
}
    4710:	80 0f       	add	r24, r16
    4712:	91 1f       	adc	r25, r17
    4714:	df 91       	pop	r29
    4716:	cf 91       	pop	r28
    4718:	1f 91       	pop	r17
    471a:	0f 91       	pop	r16
    471c:	08 95       	ret

0000471e <__vector_18>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
    471e:	1f 92       	push	r1
    4720:	0f 92       	push	r0
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	0f 92       	push	r0
    4726:	11 24       	eor	r1, r1
    4728:	2f 93       	push	r18
    472a:	3f 93       	push	r19
    472c:	8f 93       	push	r24
    472e:	9f 93       	push	r25
    4730:	af 93       	push	r26
    4732:	bf 93       	push	r27
    4734:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <timer0_millis>
    4738:	90 91 ba 05 	lds	r25, 0x05BA	; 0x8005ba <timer0_millis+0x1>
    473c:	a0 91 bb 05 	lds	r26, 0x05BB	; 0x8005bb <timer0_millis+0x2>
    4740:	b0 91 bc 05 	lds	r27, 0x05BC	; 0x8005bc <timer0_millis+0x3>
    4744:	30 91 b8 05 	lds	r19, 0x05B8	; 0x8005b8 <timer0_fract>
    4748:	23 e0       	ldi	r18, 0x03	; 3
    474a:	23 0f       	add	r18, r19
    474c:	2d 37       	cpi	r18, 0x7D	; 125
    474e:	20 f4       	brcc	.+8      	; 0x4758 <__vector_18+0x3a>
    4750:	01 96       	adiw	r24, 0x01	; 1
    4752:	a1 1d       	adc	r26, r1
    4754:	b1 1d       	adc	r27, r1
    4756:	05 c0       	rjmp	.+10     	; 0x4762 <__vector_18+0x44>
    4758:	26 e8       	ldi	r18, 0x86	; 134
    475a:	23 0f       	add	r18, r19
    475c:	02 96       	adiw	r24, 0x02	; 2
    475e:	a1 1d       	adc	r26, r1
    4760:	b1 1d       	adc	r27, r1
    4762:	20 93 b8 05 	sts	0x05B8, r18	; 0x8005b8 <timer0_fract>
    4766:	80 93 b9 05 	sts	0x05B9, r24	; 0x8005b9 <timer0_millis>
    476a:	90 93 ba 05 	sts	0x05BA, r25	; 0x8005ba <timer0_millis+0x1>
    476e:	a0 93 bb 05 	sts	0x05BB, r26	; 0x8005bb <timer0_millis+0x2>
    4772:	b0 93 bc 05 	sts	0x05BC, r27	; 0x8005bc <timer0_millis+0x3>
    4776:	80 91 bd 05 	lds	r24, 0x05BD	; 0x8005bd <timer0_overflow_count>
    477a:	90 91 be 05 	lds	r25, 0x05BE	; 0x8005be <timer0_overflow_count+0x1>
    477e:	a0 91 bf 05 	lds	r26, 0x05BF	; 0x8005bf <timer0_overflow_count+0x2>
    4782:	b0 91 c0 05 	lds	r27, 0x05C0	; 0x8005c0 <timer0_overflow_count+0x3>
    4786:	01 96       	adiw	r24, 0x01	; 1
    4788:	a1 1d       	adc	r26, r1
    478a:	b1 1d       	adc	r27, r1
    478c:	80 93 bd 05 	sts	0x05BD, r24	; 0x8005bd <timer0_overflow_count>
    4790:	90 93 be 05 	sts	0x05BE, r25	; 0x8005be <timer0_overflow_count+0x1>
    4794:	a0 93 bf 05 	sts	0x05BF, r26	; 0x8005bf <timer0_overflow_count+0x2>
    4798:	b0 93 c0 05 	sts	0x05C0, r27	; 0x8005c0 <timer0_overflow_count+0x3>
    479c:	bf 91       	pop	r27
    479e:	af 91       	pop	r26
    47a0:	9f 91       	pop	r25
    47a2:	8f 91       	pop	r24
    47a4:	3f 91       	pop	r19
    47a6:	2f 91       	pop	r18
    47a8:	0f 90       	pop	r0
    47aa:	0f be       	out	0x3f, r0	; 63
    47ac:	0f 90       	pop	r0
    47ae:	1f 90       	pop	r1
    47b0:	18 95       	reti

000047b2 <millis>:
    47b2:	2f b7       	in	r18, 0x3f	; 63
    47b4:	f8 94       	cli
    47b6:	60 91 b9 05 	lds	r22, 0x05B9	; 0x8005b9 <timer0_millis>
    47ba:	70 91 ba 05 	lds	r23, 0x05BA	; 0x8005ba <timer0_millis+0x1>
    47be:	80 91 bb 05 	lds	r24, 0x05BB	; 0x8005bb <timer0_millis+0x2>
    47c2:	90 91 bc 05 	lds	r25, 0x05BC	; 0x8005bc <timer0_millis+0x3>
    47c6:	2f bf       	out	0x3f, r18	; 63
    47c8:	08 95       	ret

000047ca <micros>:
    47ca:	3f b7       	in	r19, 0x3f	; 63
    47cc:	f8 94       	cli
    47ce:	80 91 bd 05 	lds	r24, 0x05BD	; 0x8005bd <timer0_overflow_count>
    47d2:	90 91 be 05 	lds	r25, 0x05BE	; 0x8005be <timer0_overflow_count+0x1>
    47d6:	a0 91 bf 05 	lds	r26, 0x05BF	; 0x8005bf <timer0_overflow_count+0x2>
    47da:	b0 91 c0 05 	lds	r27, 0x05C0	; 0x8005c0 <timer0_overflow_count+0x3>
    47de:	26 b5       	in	r18, 0x26	; 38
    47e0:	a8 9b       	sbis	0x15, 0	; 21
    47e2:	05 c0       	rjmp	.+10     	; 0x47ee <micros+0x24>
    47e4:	2f 3f       	cpi	r18, 0xFF	; 255
    47e6:	19 f0       	breq	.+6      	; 0x47ee <micros+0x24>
    47e8:	01 96       	adiw	r24, 0x01	; 1
    47ea:	a1 1d       	adc	r26, r1
    47ec:	b1 1d       	adc	r27, r1
    47ee:	3f bf       	out	0x3f, r19	; 63
    47f0:	ba 2f       	mov	r27, r26
    47f2:	a9 2f       	mov	r26, r25
    47f4:	98 2f       	mov	r25, r24
    47f6:	88 27       	eor	r24, r24
    47f8:	82 0f       	add	r24, r18
    47fa:	91 1d       	adc	r25, r1
    47fc:	a1 1d       	adc	r26, r1
    47fe:	b1 1d       	adc	r27, r1
    4800:	bc 01       	movw	r22, r24
    4802:	cd 01       	movw	r24, r26
    4804:	42 e0       	ldi	r20, 0x02	; 2
    4806:	66 0f       	add	r22, r22
    4808:	77 1f       	adc	r23, r23
    480a:	88 1f       	adc	r24, r24
    480c:	99 1f       	adc	r25, r25
    480e:	4a 95       	dec	r20
    4810:	d1 f7       	brne	.-12     	; 0x4806 <micros+0x3c>
    4812:	08 95       	ret

00004814 <delay>:
    4814:	8f 92       	push	r8
    4816:	9f 92       	push	r9
    4818:	af 92       	push	r10
    481a:	bf 92       	push	r11
    481c:	cf 92       	push	r12
    481e:	df 92       	push	r13
    4820:	ef 92       	push	r14
    4822:	ff 92       	push	r15
    4824:	6b 01       	movw	r12, r22
    4826:	7c 01       	movw	r14, r24
    4828:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
    482c:	4b 01       	movw	r8, r22
    482e:	5c 01       	movw	r10, r24
    4830:	c1 14       	cp	r12, r1
    4832:	d1 04       	cpc	r13, r1
    4834:	e1 04       	cpc	r14, r1
    4836:	f1 04       	cpc	r15, r1
    4838:	01 f1       	breq	.+64     	; 0x487a <delay+0x66>
    483a:	0e 94 74 22 	call	0x44e8	; 0x44e8 <yield>
    483e:	0e 94 e5 23 	call	0x47ca	; 0x47ca <micros>
    4842:	dc 01       	movw	r26, r24
    4844:	cb 01       	movw	r24, r22
    4846:	88 19       	sub	r24, r8
    4848:	99 09       	sbc	r25, r9
    484a:	aa 09       	sbc	r26, r10
    484c:	bb 09       	sbc	r27, r11
    484e:	88 3e       	cpi	r24, 0xE8	; 232
    4850:	93 40       	sbci	r25, 0x03	; 3
    4852:	a1 05       	cpc	r26, r1
    4854:	b1 05       	cpc	r27, r1
    4856:	60 f3       	brcs	.-40     	; 0x4830 <delay+0x1c>
    4858:	21 e0       	ldi	r18, 0x01	; 1
    485a:	c2 1a       	sub	r12, r18
    485c:	d1 08       	sbc	r13, r1
    485e:	e1 08       	sbc	r14, r1
    4860:	f1 08       	sbc	r15, r1
    4862:	88 ee       	ldi	r24, 0xE8	; 232
    4864:	88 0e       	add	r8, r24
    4866:	83 e0       	ldi	r24, 0x03	; 3
    4868:	98 1e       	adc	r9, r24
    486a:	a1 1c       	adc	r10, r1
    486c:	b1 1c       	adc	r11, r1
    486e:	c1 14       	cp	r12, r1
    4870:	d1 04       	cpc	r13, r1
    4872:	e1 04       	cpc	r14, r1
    4874:	f1 04       	cpc	r15, r1
    4876:	19 f7       	brne	.-58     	; 0x483e <delay+0x2a>
    4878:	db cf       	rjmp	.-74     	; 0x4830 <delay+0x1c>
    487a:	ff 90       	pop	r15
    487c:	ef 90       	pop	r14
    487e:	df 90       	pop	r13
    4880:	cf 90       	pop	r12
    4882:	bf 90       	pop	r11
    4884:	af 90       	pop	r10
    4886:	9f 90       	pop	r9
    4888:	8f 90       	pop	r8
    488a:	08 95       	ret

0000488c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    488c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    488e:	84 b5       	in	r24, 0x24	; 36
    4890:	82 60       	ori	r24, 0x02	; 2
    4892:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    4894:	84 b5       	in	r24, 0x24	; 36
    4896:	81 60       	ori	r24, 0x01	; 1
    4898:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    489a:	85 b5       	in	r24, 0x25	; 37
    489c:	82 60       	ori	r24, 0x02	; 2
    489e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    48a0:	85 b5       	in	r24, 0x25	; 37
    48a2:	81 60       	ori	r24, 0x01	; 1
    48a4:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    48a6:	ee e6       	ldi	r30, 0x6E	; 110
    48a8:	f0 e0       	ldi	r31, 0x00	; 0
    48aa:	80 81       	ld	r24, Z
    48ac:	81 60       	ori	r24, 0x01	; 1
    48ae:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    48b0:	e1 e8       	ldi	r30, 0x81	; 129
    48b2:	f0 e0       	ldi	r31, 0x00	; 0
    48b4:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    48b6:	80 81       	ld	r24, Z
    48b8:	82 60       	ori	r24, 0x02	; 2
    48ba:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    48bc:	80 81       	ld	r24, Z
    48be:	81 60       	ori	r24, 0x01	; 1
    48c0:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    48c2:	e0 e8       	ldi	r30, 0x80	; 128
    48c4:	f0 e0       	ldi	r31, 0x00	; 0
    48c6:	80 81       	ld	r24, Z
    48c8:	81 60       	ori	r24, 0x01	; 1
    48ca:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    48cc:	e1 eb       	ldi	r30, 0xB1	; 177
    48ce:	f0 e0       	ldi	r31, 0x00	; 0
    48d0:	80 81       	ld	r24, Z
    48d2:	84 60       	ori	r24, 0x04	; 4
    48d4:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    48d6:	e0 eb       	ldi	r30, 0xB0	; 176
    48d8:	f0 e0       	ldi	r31, 0x00	; 0
    48da:	80 81       	ld	r24, Z
    48dc:	81 60       	ori	r24, 0x01	; 1
    48de:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    48e0:	ea e7       	ldi	r30, 0x7A	; 122
    48e2:	f0 e0       	ldi	r31, 0x00	; 0
    48e4:	80 81       	ld	r24, Z
    48e6:	84 60       	ori	r24, 0x04	; 4
    48e8:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    48ea:	80 81       	ld	r24, Z
    48ec:	82 60       	ori	r24, 0x02	; 2
    48ee:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    48f0:	80 81       	ld	r24, Z
    48f2:	81 60       	ori	r24, 0x01	; 1
    48f4:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    48f6:	80 81       	ld	r24, Z
    48f8:	80 68       	ori	r24, 0x80	; 128
    48fa:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    48fc:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    4900:	08 95       	ret

00004902 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    4902:	83 30       	cpi	r24, 0x03	; 3
    4904:	81 f0       	breq	.+32     	; 0x4926 <turnOffPWM+0x24>
    4906:	28 f4       	brcc	.+10     	; 0x4912 <turnOffPWM+0x10>
    4908:	81 30       	cpi	r24, 0x01	; 1
    490a:	99 f0       	breq	.+38     	; 0x4932 <turnOffPWM+0x30>
    490c:	82 30       	cpi	r24, 0x02	; 2
    490e:	a1 f0       	breq	.+40     	; 0x4938 <turnOffPWM+0x36>
    4910:	08 95       	ret
    4912:	87 30       	cpi	r24, 0x07	; 7
    4914:	a9 f0       	breq	.+42     	; 0x4940 <turnOffPWM+0x3e>
    4916:	88 30       	cpi	r24, 0x08	; 8
    4918:	b9 f0       	breq	.+46     	; 0x4948 <turnOffPWM+0x46>
    491a:	84 30       	cpi	r24, 0x04	; 4
    491c:	d1 f4       	brne	.+52     	; 0x4952 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    491e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    4922:	8f 7d       	andi	r24, 0xDF	; 223
    4924:	03 c0       	rjmp	.+6      	; 0x492c <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    4926:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    492a:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    492c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    4930:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    4932:	84 b5       	in	r24, 0x24	; 36
    4934:	8f 77       	andi	r24, 0x7F	; 127
    4936:	02 c0       	rjmp	.+4      	; 0x493c <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    4938:	84 b5       	in	r24, 0x24	; 36
    493a:	8f 7d       	andi	r24, 0xDF	; 223
    493c:	84 bd       	out	0x24, r24	; 36
    493e:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    4940:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    4944:	8f 77       	andi	r24, 0x7F	; 127
    4946:	03 c0       	rjmp	.+6      	; 0x494e <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    4948:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    494c:	8f 7d       	andi	r24, 0xDF	; 223
    494e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    4952:	08 95       	ret

00004954 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    4954:	cf 93       	push	r28
    4956:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    4958:	90 e0       	ldi	r25, 0x00	; 0
    495a:	fc 01       	movw	r30, r24
    495c:	e5 5b       	subi	r30, 0xB5	; 181
    495e:	f8 4f       	sbci	r31, 0xF8	; 248
    4960:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    4962:	fc 01       	movw	r30, r24
    4964:	e5 59       	subi	r30, 0x95	; 149
    4966:	f8 4f       	sbci	r31, 0xF8	; 248
    4968:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    496a:	88 23       	and	r24, r24
    496c:	61 f1       	breq	.+88     	; 0x49c6 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    496e:	90 e0       	ldi	r25, 0x00	; 0
    4970:	88 0f       	add	r24, r24
    4972:	99 1f       	adc	r25, r25
    4974:	fc 01       	movw	r30, r24
    4976:	e1 56       	subi	r30, 0x61	; 97
    4978:	f8 4f       	sbci	r31, 0xF8	; 248
    497a:	c5 91       	lpm	r28, Z+
    497c:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    497e:	fc 01       	movw	r30, r24
    4980:	eb 56       	subi	r30, 0x6B	; 107
    4982:	f8 4f       	sbci	r31, 0xF8	; 248
    4984:	a5 91       	lpm	r26, Z+
    4986:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    4988:	61 11       	cpse	r22, r1
    498a:	09 c0       	rjmp	.+18     	; 0x499e <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    498c:	9f b7       	in	r25, 0x3f	; 63
                cli();
    498e:	f8 94       	cli
		*reg &= ~bit;
    4990:	88 81       	ld	r24, Y
    4992:	20 95       	com	r18
    4994:	82 23       	and	r24, r18
    4996:	88 83       	st	Y, r24
		*out &= ~bit;
    4998:	ec 91       	ld	r30, X
    499a:	2e 23       	and	r18, r30
    499c:	0b c0       	rjmp	.+22     	; 0x49b4 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    499e:	62 30       	cpi	r22, 0x02	; 2
    49a0:	61 f4       	brne	.+24     	; 0x49ba <pinMode+0x66>
		uint8_t oldSREG = SREG;
    49a2:	9f b7       	in	r25, 0x3f	; 63
                cli();
    49a4:	f8 94       	cli
		*reg &= ~bit;
    49a6:	88 81       	ld	r24, Y
    49a8:	32 2f       	mov	r19, r18
    49aa:	30 95       	com	r19
    49ac:	83 23       	and	r24, r19
    49ae:	88 83       	st	Y, r24
		*out |= bit;
    49b0:	ec 91       	ld	r30, X
    49b2:	2e 2b       	or	r18, r30
    49b4:	2c 93       	st	X, r18
		SREG = oldSREG;
    49b6:	9f bf       	out	0x3f, r25	; 63
    49b8:	06 c0       	rjmp	.+12     	; 0x49c6 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    49ba:	8f b7       	in	r24, 0x3f	; 63
                cli();
    49bc:	f8 94       	cli
		*reg |= bit;
    49be:	e8 81       	ld	r30, Y
    49c0:	2e 2b       	or	r18, r30
    49c2:	28 83       	st	Y, r18
		SREG = oldSREG;
    49c4:	8f bf       	out	0x3f, r24	; 63
	}
}
    49c6:	df 91       	pop	r29
    49c8:	cf 91       	pop	r28
    49ca:	08 95       	ret

000049cc <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    49cc:	1f 93       	push	r17
    49ce:	cf 93       	push	r28
    49d0:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    49d2:	28 2f       	mov	r18, r24
    49d4:	30 e0       	ldi	r19, 0x00	; 0
    49d6:	f9 01       	movw	r30, r18
    49d8:	e5 5d       	subi	r30, 0xD5	; 213
    49da:	f8 4f       	sbci	r31, 0xF8	; 248
    49dc:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    49de:	f9 01       	movw	r30, r18
    49e0:	e5 5b       	subi	r30, 0xB5	; 181
    49e2:	f8 4f       	sbci	r31, 0xF8	; 248
    49e4:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    49e6:	f9 01       	movw	r30, r18
    49e8:	e5 59       	subi	r30, 0x95	; 149
    49ea:	f8 4f       	sbci	r31, 0xF8	; 248
    49ec:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    49ee:	cc 23       	and	r28, r28
    49f0:	c1 f0       	breq	.+48     	; 0x4a22 <digitalWrite+0x56>
    49f2:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    49f4:	81 11       	cpse	r24, r1
    49f6:	0e 94 81 24 	call	0x4902	; 0x4902 <turnOffPWM>

	out = portOutputRegister(port);
    49fa:	ec 2f       	mov	r30, r28
    49fc:	f0 e0       	ldi	r31, 0x00	; 0
    49fe:	ee 0f       	add	r30, r30
    4a00:	ff 1f       	adc	r31, r31
    4a02:	eb 56       	subi	r30, 0x6B	; 107
    4a04:	f8 4f       	sbci	r31, 0xF8	; 248
    4a06:	a5 91       	lpm	r26, Z+
    4a08:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    4a0a:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4a0c:	f8 94       	cli

	if (val == LOW) {
    4a0e:	11 11       	cpse	r17, r1
    4a10:	04 c0       	rjmp	.+8      	; 0x4a1a <digitalWrite+0x4e>
		*out &= ~bit;
    4a12:	8c 91       	ld	r24, X
    4a14:	d0 95       	com	r29
    4a16:	d8 23       	and	r29, r24
    4a18:	02 c0       	rjmp	.+4      	; 0x4a1e <digitalWrite+0x52>
	} else {
		*out |= bit;
    4a1a:	ec 91       	ld	r30, X
    4a1c:	de 2b       	or	r29, r30
    4a1e:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    4a20:	9f bf       	out	0x3f, r25	; 63
}
    4a22:	df 91       	pop	r29
    4a24:	cf 91       	pop	r28
    4a26:	1f 91       	pop	r17
    4a28:	08 95       	ret

00004a2a <digitalRead>:

int digitalRead(uint8_t pin)
{
    4a2a:	cf 93       	push	r28
    4a2c:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    4a2e:	28 2f       	mov	r18, r24
    4a30:	30 e0       	ldi	r19, 0x00	; 0
    4a32:	f9 01       	movw	r30, r18
    4a34:	e5 5d       	subi	r30, 0xD5	; 213
    4a36:	f8 4f       	sbci	r31, 0xF8	; 248
    4a38:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    4a3a:	f9 01       	movw	r30, r18
    4a3c:	e5 5b       	subi	r30, 0xB5	; 181
    4a3e:	f8 4f       	sbci	r31, 0xF8	; 248
    4a40:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    4a42:	f9 01       	movw	r30, r18
    4a44:	e5 59       	subi	r30, 0x95	; 149
    4a46:	f8 4f       	sbci	r31, 0xF8	; 248
    4a48:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
    4a4a:	cc 23       	and	r28, r28
    4a4c:	91 f0       	breq	.+36     	; 0x4a72 <digitalRead+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    4a4e:	81 11       	cpse	r24, r1
    4a50:	0e 94 81 24 	call	0x4902	; 0x4902 <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
    4a54:	ec 2f       	mov	r30, r28
    4a56:	f0 e0       	ldi	r31, 0x00	; 0
    4a58:	ee 0f       	add	r30, r30
    4a5a:	ff 1f       	adc	r31, r31
    4a5c:	e5 57       	subi	r30, 0x75	; 117
    4a5e:	f8 4f       	sbci	r31, 0xF8	; 248
    4a60:	a5 91       	lpm	r26, Z+
    4a62:	b4 91       	lpm	r27, Z
    4a64:	ec 91       	ld	r30, X
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
    4a66:	ed 23       	and	r30, r29
    4a68:	81 e0       	ldi	r24, 0x01	; 1
    4a6a:	90 e0       	ldi	r25, 0x00	; 0
    4a6c:	21 f4       	brne	.+8      	; 0x4a76 <digitalRead+0x4c>
    4a6e:	80 e0       	ldi	r24, 0x00	; 0
    4a70:	02 c0       	rjmp	.+4      	; 0x4a76 <digitalRead+0x4c>
    4a72:	80 e0       	ldi	r24, 0x00	; 0
    4a74:	90 e0       	ldi	r25, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
    4a76:	df 91       	pop	r29
    4a78:	cf 91       	pop	r28
    4a7a:	08 95       	ret

00004a7c <_Z6randoml>:
    srandom(seed);
  }
}

long random(long howbig)
{
    4a7c:	cf 92       	push	r12
    4a7e:	df 92       	push	r13
    4a80:	ef 92       	push	r14
    4a82:	ff 92       	push	r15
  if (howbig == 0) {
    4a84:	61 15       	cp	r22, r1
    4a86:	71 05       	cpc	r23, r1
    4a88:	81 05       	cpc	r24, r1
    4a8a:	91 05       	cpc	r25, r1
    4a8c:	49 f0       	breq	.+18     	; 0x4aa0 <_Z6randoml+0x24>
    4a8e:	6b 01       	movw	r12, r22
    4a90:	7c 01       	movw	r14, r24
    return 0;
  }
  return random() % howbig;
    4a92:	0e 94 42 29 	call	0x5284	; 0x5284 <random>
    4a96:	a7 01       	movw	r20, r14
    4a98:	96 01       	movw	r18, r12
    4a9a:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    4a9e:	03 c0       	rjmp	.+6      	; 0x4aa6 <_Z6randoml+0x2a>
}

long random(long howbig)
{
  if (howbig == 0) {
    return 0;
    4aa0:	60 e0       	ldi	r22, 0x00	; 0
    4aa2:	70 e0       	ldi	r23, 0x00	; 0
    4aa4:	cb 01       	movw	r24, r22
  }
  return random() % howbig;
}
    4aa6:	ff 90       	pop	r15
    4aa8:	ef 90       	pop	r14
    4aaa:	df 90       	pop	r13
    4aac:	cf 90       	pop	r12
    4aae:	08 95       	ret

00004ab0 <_Z6randomll>:

long random(long howsmall, long howbig)
{
    4ab0:	cf 92       	push	r12
    4ab2:	df 92       	push	r13
    4ab4:	ef 92       	push	r14
    4ab6:	ff 92       	push	r15
    4ab8:	0f 93       	push	r16
    4aba:	1f 93       	push	r17
  if (howsmall >= howbig) {
    4abc:	62 17       	cp	r22, r18
    4abe:	73 07       	cpc	r23, r19
    4ac0:	84 07       	cpc	r24, r20
    4ac2:	95 07       	cpc	r25, r21
    4ac4:	84 f4       	brge	.+32     	; 0x4ae6 <_Z6randomll+0x36>
    4ac6:	89 01       	movw	r16, r18
    4ac8:	9a 01       	movw	r18, r20
    4aca:	6b 01       	movw	r12, r22
    4acc:	7c 01       	movw	r14, r24
    return howsmall;
  }
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
    4ace:	c9 01       	movw	r24, r18
    4ad0:	b8 01       	movw	r22, r16
    4ad2:	6c 19       	sub	r22, r12
    4ad4:	7d 09       	sbc	r23, r13
    4ad6:	8e 09       	sbc	r24, r14
    4ad8:	9f 09       	sbc	r25, r15
    4ada:	0e 94 3e 25 	call	0x4a7c	; 0x4a7c <_Z6randoml>
    4ade:	6c 0d       	add	r22, r12
    4ae0:	7d 1d       	adc	r23, r13
    4ae2:	8e 1d       	adc	r24, r14
    4ae4:	9f 1d       	adc	r25, r15
}
    4ae6:	1f 91       	pop	r17
    4ae8:	0f 91       	pop	r16
    4aea:	ff 90       	pop	r15
    4aec:	ef 90       	pop	r14
    4aee:	df 90       	pop	r13
    4af0:	cf 90       	pop	r12
    4af2:	08 95       	ret

00004af4 <_Z3maplllll>:

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
    4af4:	4f 92       	push	r4
    4af6:	5f 92       	push	r5
    4af8:	6f 92       	push	r6
    4afa:	7f 92       	push	r7
    4afc:	af 92       	push	r10
    4afe:	bf 92       	push	r11
    4b00:	cf 92       	push	r12
    4b02:	df 92       	push	r13
    4b04:	ef 92       	push	r14
    4b06:	ff 92       	push	r15
    4b08:	0f 93       	push	r16
    4b0a:	1f 93       	push	r17
    4b0c:	cf 93       	push	r28
    4b0e:	df 93       	push	r29
    4b10:	cd b7       	in	r28, 0x3d	; 61
    4b12:	de b7       	in	r29, 0x3e	; 62
    4b14:	29 01       	movw	r4, r18
    4b16:	3a 01       	movw	r6, r20
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    4b18:	9b 01       	movw	r18, r22
    4b1a:	ac 01       	movw	r20, r24
    4b1c:	24 19       	sub	r18, r4
    4b1e:	35 09       	sbc	r19, r5
    4b20:	46 09       	sbc	r20, r6
    4b22:	57 09       	sbc	r21, r7
    4b24:	89 89       	ldd	r24, Y+17	; 0x11
    4b26:	9a 89       	ldd	r25, Y+18	; 0x12
    4b28:	ab 89       	ldd	r26, Y+19	; 0x13
    4b2a:	bc 89       	ldd	r27, Y+20	; 0x14
    4b2c:	bc 01       	movw	r22, r24
    4b2e:	cd 01       	movw	r24, r26
    4b30:	6a 19       	sub	r22, r10
    4b32:	7b 09       	sbc	r23, r11
    4b34:	8c 09       	sbc	r24, r12
    4b36:	9d 09       	sbc	r25, r13
    4b38:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <__mulsi3>
    4b3c:	a8 01       	movw	r20, r16
    4b3e:	97 01       	movw	r18, r14
    4b40:	24 19       	sub	r18, r4
    4b42:	35 09       	sbc	r19, r5
    4b44:	46 09       	sbc	r20, r6
    4b46:	57 09       	sbc	r21, r7
    4b48:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    4b4c:	ca 01       	movw	r24, r20
    4b4e:	b9 01       	movw	r22, r18
    4b50:	6a 0d       	add	r22, r10
    4b52:	7b 1d       	adc	r23, r11
    4b54:	8c 1d       	adc	r24, r12
    4b56:	9d 1d       	adc	r25, r13
}
    4b58:	df 91       	pop	r29
    4b5a:	cf 91       	pop	r28
    4b5c:	1f 91       	pop	r17
    4b5e:	0f 91       	pop	r16
    4b60:	ff 90       	pop	r15
    4b62:	ef 90       	pop	r14
    4b64:	df 90       	pop	r13
    4b66:	cf 90       	pop	r12
    4b68:	bf 90       	pop	r11
    4b6a:	af 90       	pop	r10
    4b6c:	7f 90       	pop	r7
    4b6e:	6f 90       	pop	r6
    4b70:	5f 90       	pop	r5
    4b72:	4f 90       	pop	r4
    4b74:	08 95       	ret

00004b76 <_ZN6StringD1Ev>:

String & String::operator = (StringSumHelper &&rval)
{
	if (this != &rval) move(rval);
	return *this;
}
    4b76:	fc 01       	movw	r30, r24
    4b78:	80 81       	ld	r24, Z
    4b7a:	91 81       	ldd	r25, Z+1	; 0x01
    4b7c:	0c 94 6e 28 	jmp	0x50dc	; 0x50dc <free>

00004b80 <_ZN6String10invalidateEv>:
    4b80:	cf 93       	push	r28
    4b82:	df 93       	push	r29
    4b84:	ec 01       	movw	r28, r24
    4b86:	88 81       	ld	r24, Y
    4b88:	99 81       	ldd	r25, Y+1	; 0x01
    4b8a:	00 97       	sbiw	r24, 0x00	; 0
    4b8c:	11 f0       	breq	.+4      	; 0x4b92 <_ZN6String10invalidateEv+0x12>
    4b8e:	0e 94 6e 28 	call	0x50dc	; 0x50dc <free>
    4b92:	19 82       	std	Y+1, r1	; 0x01
    4b94:	18 82       	st	Y, r1
    4b96:	1d 82       	std	Y+5, r1	; 0x05
    4b98:	1c 82       	std	Y+4, r1	; 0x04
    4b9a:	1b 82       	std	Y+3, r1	; 0x03
    4b9c:	1a 82       	std	Y+2, r1	; 0x02
    4b9e:	df 91       	pop	r29
    4ba0:	cf 91       	pop	r28
    4ba2:	08 95       	ret

00004ba4 <_ZN6String12changeBufferEj>:
    4ba4:	0f 93       	push	r16
    4ba6:	1f 93       	push	r17
    4ba8:	cf 93       	push	r28
    4baa:	df 93       	push	r29
    4bac:	ec 01       	movw	r28, r24
    4bae:	8b 01       	movw	r16, r22
    4bb0:	6f 5f       	subi	r22, 0xFF	; 255
    4bb2:	7f 4f       	sbci	r23, 0xFF	; 255
    4bb4:	88 81       	ld	r24, Y
    4bb6:	99 81       	ldd	r25, Y+1	; 0x01
    4bb8:	0e 94 99 29 	call	0x5332	; 0x5332 <realloc>
    4bbc:	00 97       	sbiw	r24, 0x00	; 0
    4bbe:	31 f0       	breq	.+12     	; 0x4bcc <_ZN6String12changeBufferEj+0x28>
    4bc0:	99 83       	std	Y+1, r25	; 0x01
    4bc2:	88 83       	st	Y, r24
    4bc4:	1b 83       	std	Y+3, r17	; 0x03
    4bc6:	0a 83       	std	Y+2, r16	; 0x02
    4bc8:	81 e0       	ldi	r24, 0x01	; 1
    4bca:	01 c0       	rjmp	.+2      	; 0x4bce <_ZN6String12changeBufferEj+0x2a>
    4bcc:	80 e0       	ldi	r24, 0x00	; 0
    4bce:	df 91       	pop	r29
    4bd0:	cf 91       	pop	r28
    4bd2:	1f 91       	pop	r17
    4bd4:	0f 91       	pop	r16
    4bd6:	08 95       	ret

00004bd8 <_ZN6String7reserveEj>:
    4bd8:	cf 93       	push	r28
    4bda:	df 93       	push	r29
    4bdc:	ec 01       	movw	r28, r24
    4bde:	88 81       	ld	r24, Y
    4be0:	99 81       	ldd	r25, Y+1	; 0x01
    4be2:	89 2b       	or	r24, r25
    4be4:	29 f0       	breq	.+10     	; 0x4bf0 <_ZN6String7reserveEj+0x18>
    4be6:	8a 81       	ldd	r24, Y+2	; 0x02
    4be8:	9b 81       	ldd	r25, Y+3	; 0x03
    4bea:	86 17       	cp	r24, r22
    4bec:	97 07       	cpc	r25, r23
    4bee:	60 f4       	brcc	.+24     	; 0x4c08 <_ZN6String7reserveEj+0x30>
    4bf0:	ce 01       	movw	r24, r28
    4bf2:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <_ZN6String12changeBufferEj>
    4bf6:	88 23       	and	r24, r24
    4bf8:	41 f0       	breq	.+16     	; 0x4c0a <_ZN6String7reserveEj+0x32>
    4bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    4bfc:	9d 81       	ldd	r25, Y+5	; 0x05
    4bfe:	89 2b       	or	r24, r25
    4c00:	19 f4       	brne	.+6      	; 0x4c08 <_ZN6String7reserveEj+0x30>
    4c02:	e8 81       	ld	r30, Y
    4c04:	f9 81       	ldd	r31, Y+1	; 0x01
    4c06:	10 82       	st	Z, r1
    4c08:	81 e0       	ldi	r24, 0x01	; 1
    4c0a:	df 91       	pop	r29
    4c0c:	cf 91       	pop	r28
    4c0e:	08 95       	ret

00004c10 <_ZN6String4copyEPKcj>:
    4c10:	ef 92       	push	r14
    4c12:	ff 92       	push	r15
    4c14:	0f 93       	push	r16
    4c16:	1f 93       	push	r17
    4c18:	cf 93       	push	r28
    4c1a:	df 93       	push	r29
    4c1c:	ec 01       	movw	r28, r24
    4c1e:	7b 01       	movw	r14, r22
    4c20:	8a 01       	movw	r16, r20
    4c22:	ba 01       	movw	r22, r20
    4c24:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <_ZN6String7reserveEj>
    4c28:	81 11       	cpse	r24, r1
    4c2a:	04 c0       	rjmp	.+8      	; 0x4c34 <_ZN6String4copyEPKcj+0x24>
    4c2c:	ce 01       	movw	r24, r28
    4c2e:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <_ZN6String10invalidateEv>
    4c32:	07 c0       	rjmp	.+14     	; 0x4c42 <_ZN6String4copyEPKcj+0x32>
    4c34:	1d 83       	std	Y+5, r17	; 0x05
    4c36:	0c 83       	std	Y+4, r16	; 0x04
    4c38:	b7 01       	movw	r22, r14
    4c3a:	88 81       	ld	r24, Y
    4c3c:	99 81       	ldd	r25, Y+1	; 0x01
    4c3e:	0e 94 91 2a 	call	0x5522	; 0x5522 <strcpy>
    4c42:	ce 01       	movw	r24, r28
    4c44:	df 91       	pop	r29
    4c46:	cf 91       	pop	r28
    4c48:	1f 91       	pop	r17
    4c4a:	0f 91       	pop	r16
    4c4c:	ff 90       	pop	r15
    4c4e:	ef 90       	pop	r14
    4c50:	08 95       	ret

00004c52 <_ZN6StringC1EPKc>:
    4c52:	fc 01       	movw	r30, r24
    4c54:	11 82       	std	Z+1, r1	; 0x01
    4c56:	10 82       	st	Z, r1
    4c58:	13 82       	std	Z+3, r1	; 0x03
    4c5a:	12 82       	std	Z+2, r1	; 0x02
    4c5c:	15 82       	std	Z+5, r1	; 0x05
    4c5e:	14 82       	std	Z+4, r1	; 0x04
    4c60:	61 15       	cp	r22, r1
    4c62:	71 05       	cpc	r23, r1
    4c64:	51 f0       	breq	.+20     	; 0x4c7a <_ZN6StringC1EPKc+0x28>
    4c66:	fb 01       	movw	r30, r22
    4c68:	01 90       	ld	r0, Z+
    4c6a:	00 20       	and	r0, r0
    4c6c:	e9 f7       	brne	.-6      	; 0x4c68 <_ZN6StringC1EPKc+0x16>
    4c6e:	31 97       	sbiw	r30, 0x01	; 1
    4c70:	af 01       	movw	r20, r30
    4c72:	46 1b       	sub	r20, r22
    4c74:	57 0b       	sbc	r21, r23
    4c76:	0c 94 08 26 	jmp	0x4c10	; 0x4c10 <_ZN6String4copyEPKcj>
    4c7a:	08 95       	ret

00004c7c <_ZN6StringaSEPKc>:
#endif

String & String::operator = (const char *cstr)
{
    4c7c:	cf 93       	push	r28
    4c7e:	df 93       	push	r29
    4c80:	ec 01       	movw	r28, r24
	if (cstr) copy(cstr, strlen(cstr));
    4c82:	61 15       	cp	r22, r1
    4c84:	71 05       	cpc	r23, r1
    4c86:	59 f0       	breq	.+22     	; 0x4c9e <_ZN6StringaSEPKc+0x22>
    4c88:	fb 01       	movw	r30, r22
    4c8a:	01 90       	ld	r0, Z+
    4c8c:	00 20       	and	r0, r0
    4c8e:	e9 f7       	brne	.-6      	; 0x4c8a <_ZN6StringaSEPKc+0xe>
    4c90:	31 97       	sbiw	r30, 0x01	; 1
    4c92:	af 01       	movw	r20, r30
    4c94:	46 1b       	sub	r20, r22
    4c96:	57 0b       	sbc	r21, r23
    4c98:	0e 94 08 26 	call	0x4c10	; 0x4c10 <_ZN6String4copyEPKcj>
    4c9c:	02 c0       	rjmp	.+4      	; 0x4ca2 <_ZN6StringaSEPKc+0x26>
	else invalidate();
    4c9e:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <_ZN6String10invalidateEv>
	
	return *this;
}
    4ca2:	ce 01       	movw	r24, r28
    4ca4:	df 91       	pop	r29
    4ca6:	cf 91       	pop	r28
    4ca8:	08 95       	ret

00004caa <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    4caa:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    4cac:	91 8d       	ldd	r25, Z+25	; 0x19
    4cae:	22 8d       	ldd	r18, Z+26	; 0x1a
    4cb0:	89 2f       	mov	r24, r25
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	80 5c       	subi	r24, 0xC0	; 192
    4cb6:	9f 4f       	sbci	r25, 0xFF	; 255
    4cb8:	82 1b       	sub	r24, r18
    4cba:	91 09       	sbc	r25, r1
}
    4cbc:	8f 73       	andi	r24, 0x3F	; 63
    4cbe:	99 27       	eor	r25, r25
    4cc0:	08 95       	ret

00004cc2 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    4cc2:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    4cc4:	91 8d       	ldd	r25, Z+25	; 0x19
    4cc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cc8:	98 17       	cp	r25, r24
    4cca:	31 f0       	breq	.+12     	; 0x4cd8 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    4ccc:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cce:	e8 0f       	add	r30, r24
    4cd0:	f1 1d       	adc	r31, r1
    4cd2:	85 8d       	ldd	r24, Z+29	; 0x1d
    4cd4:	90 e0       	ldi	r25, 0x00	; 0
    4cd6:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    4cd8:	8f ef       	ldi	r24, 0xFF	; 255
    4cda:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    4cdc:	08 95       	ret

00004cde <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    4cde:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    4ce0:	91 8d       	ldd	r25, Z+25	; 0x19
    4ce2:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ce4:	98 17       	cp	r25, r24
    4ce6:	61 f0       	breq	.+24     	; 0x4d00 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    4ce8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cea:	df 01       	movw	r26, r30
    4cec:	a8 0f       	add	r26, r24
    4cee:	b1 1d       	adc	r27, r1
    4cf0:	5d 96       	adiw	r26, 0x1d	; 29
    4cf2:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    4cf4:	92 8d       	ldd	r25, Z+26	; 0x1a
    4cf6:	9f 5f       	subi	r25, 0xFF	; 255
    4cf8:	9f 73       	andi	r25, 0x3F	; 63
    4cfa:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    4cfc:	90 e0       	ldi	r25, 0x00	; 0
    4cfe:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    4d00:	8f ef       	ldi	r24, 0xFF	; 255
    4d02:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    4d04:	08 95       	ret

00004d06 <_ZN14HardwareSerial17availableForWriteEv>:
{
#if (SERIAL_TX_BUFFER_SIZE>256)
  uint8_t oldSREG = SREG;
  cli();
#endif
  tx_buffer_index_t head = _tx_buffer_head;
    4d06:	fc 01       	movw	r30, r24
    4d08:	53 8d       	ldd	r21, Z+27	; 0x1b
  tx_buffer_index_t tail = _tx_buffer_tail;
    4d0a:	44 8d       	ldd	r20, Z+28	; 0x1c
    4d0c:	25 2f       	mov	r18, r21
    4d0e:	30 e0       	ldi	r19, 0x00	; 0
    4d10:	84 2f       	mov	r24, r20
    4d12:	90 e0       	ldi	r25, 0x00	; 0
#if (SERIAL_TX_BUFFER_SIZE>256)
  SREG = oldSREG;
#endif
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    4d14:	82 1b       	sub	r24, r18
    4d16:	93 0b       	sbc	r25, r19
    4d18:	54 17       	cp	r21, r20
    4d1a:	10 f0       	brcs	.+4      	; 0x4d20 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    4d1c:	cf 96       	adiw	r24, 0x3f	; 63
    4d1e:	08 95       	ret
  return tail - head - 1;
    4d20:	01 97       	sbiw	r24, 0x01	; 1
}
    4d22:	08 95       	ret

00004d24 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    4d24:	8d e3       	ldi	r24, 0x3D	; 61
    4d26:	92 e2       	ldi	r25, 0x22	; 34
    4d28:	89 2b       	or	r24, r25
    4d2a:	49 f0       	breq	.+18     	; 0x4d3e <_Z14serialEventRunv+0x1a>
    4d2c:	80 e0       	ldi	r24, 0x00	; 0
    4d2e:	90 e0       	ldi	r25, 0x00	; 0
    4d30:	89 2b       	or	r24, r25
    4d32:	29 f0       	breq	.+10     	; 0x4d3e <_Z14serialEventRunv+0x1a>
    4d34:	0e 94 3d 22 	call	0x447a	; 0x447a <_Z17Serial0_availablev>
    4d38:	81 11       	cpse	r24, r1
    4d3a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    4d3e:	08 95       	ret

00004d40 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    4d40:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    4d42:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d44:	df 01       	movw	r26, r30
    4d46:	a8 0f       	add	r26, r24
    4d48:	b1 1d       	adc	r27, r1
    4d4a:	a3 5a       	subi	r26, 0xA3	; 163
    4d4c:	bf 4f       	sbci	r27, 0xFF	; 255
    4d4e:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    4d50:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	01 96       	adiw	r24, 0x01	; 1
    4d56:	8f 73       	andi	r24, 0x3F	; 63
    4d58:	99 27       	eor	r25, r25
    4d5a:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    4d5c:	a6 89       	ldd	r26, Z+22	; 0x16
    4d5e:	b7 89       	ldd	r27, Z+23	; 0x17
    4d60:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    4d62:	a0 89       	ldd	r26, Z+16	; 0x10
    4d64:	b1 89       	ldd	r27, Z+17	; 0x11
    4d66:	8c 91       	ld	r24, X
    4d68:	80 64       	ori	r24, 0x40	; 64
    4d6a:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    4d6c:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d70:	98 13       	cpse	r25, r24
    4d72:	06 c0       	rjmp	.+12     	; 0x4d80 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    4d74:	02 88       	ldd	r0, Z+18	; 0x12
    4d76:	f3 89       	ldd	r31, Z+19	; 0x13
    4d78:	e0 2d       	mov	r30, r0
    4d7a:	80 81       	ld	r24, Z
    4d7c:	8f 7d       	andi	r24, 0xDF	; 223
    4d7e:	80 83       	st	Z, r24
    4d80:	08 95       	ret

00004d82 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    4d82:	ef 92       	push	r14
    4d84:	ff 92       	push	r15
    4d86:	0f 93       	push	r16
    4d88:	1f 93       	push	r17
    4d8a:	cf 93       	push	r28
    4d8c:	df 93       	push	r29
    4d8e:	ec 01       	movw	r28, r24
  _written = true;
    4d90:	81 e0       	ldi	r24, 0x01	; 1
    4d92:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    4d94:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4d96:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4d98:	98 13       	cpse	r25, r24
    4d9a:	05 c0       	rjmp	.+10     	; 0x4da6 <_ZN14HardwareSerial5writeEh+0x24>
    4d9c:	e8 89       	ldd	r30, Y+16	; 0x10
    4d9e:	f9 89       	ldd	r31, Y+17	; 0x11
    4da0:	80 81       	ld	r24, Z
    4da2:	85 fd       	sbrc	r24, 5
    4da4:	24 c0       	rjmp	.+72     	; 0x4dee <_ZN14HardwareSerial5writeEh+0x6c>
    4da6:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    4da8:	0b 8d       	ldd	r16, Y+27	; 0x1b
    4daa:	10 e0       	ldi	r17, 0x00	; 0
    4dac:	0f 5f       	subi	r16, 0xFF	; 255
    4dae:	1f 4f       	sbci	r17, 0xFF	; 255
    4db0:	0f 73       	andi	r16, 0x3F	; 63
    4db2:	11 27       	eor	r17, r17
    4db4:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    4db6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4db8:	e8 12       	cpse	r14, r24
    4dba:	0c c0       	rjmp	.+24     	; 0x4dd4 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    4dbc:	0f b6       	in	r0, 0x3f	; 63
    4dbe:	07 fc       	sbrc	r0, 7
    4dc0:	fa cf       	rjmp	.-12     	; 0x4db6 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    4dc2:	e8 89       	ldd	r30, Y+16	; 0x10
    4dc4:	f9 89       	ldd	r31, Y+17	; 0x11
    4dc6:	80 81       	ld	r24, Z
    4dc8:	85 ff       	sbrs	r24, 5
    4dca:	f5 cf       	rjmp	.-22     	; 0x4db6 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    4dcc:	ce 01       	movw	r24, r28
    4dce:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    4dd2:	f1 cf       	rjmp	.-30     	; 0x4db6 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    4dd4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4dd6:	fe 01       	movw	r30, r28
    4dd8:	e8 0f       	add	r30, r24
    4dda:	f1 1d       	adc	r31, r1
    4ddc:	e3 5a       	subi	r30, 0xA3	; 163
    4dde:	ff 4f       	sbci	r31, 0xFF	; 255
    4de0:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
    4de2:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    4de4:	ea 89       	ldd	r30, Y+18	; 0x12
    4de6:	fb 89       	ldd	r31, Y+19	; 0x13
    4de8:	80 81       	ld	r24, Z
    4dea:	80 62       	ori	r24, 0x20	; 32
    4dec:	07 c0       	rjmp	.+14     	; 0x4dfc <_ZN14HardwareSerial5writeEh+0x7a>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    4dee:	ee 89       	ldd	r30, Y+22	; 0x16
    4df0:	ff 89       	ldd	r31, Y+23	; 0x17
    4df2:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    4df4:	e8 89       	ldd	r30, Y+16	; 0x10
    4df6:	f9 89       	ldd	r31, Y+17	; 0x11
    4df8:	80 81       	ld	r24, Z
    4dfa:	80 64       	ori	r24, 0x40	; 64
    4dfc:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    4dfe:	81 e0       	ldi	r24, 0x01	; 1
    4e00:	90 e0       	ldi	r25, 0x00	; 0
    4e02:	df 91       	pop	r29
    4e04:	cf 91       	pop	r28
    4e06:	1f 91       	pop	r17
    4e08:	0f 91       	pop	r16
    4e0a:	ff 90       	pop	r15
    4e0c:	ef 90       	pop	r14
    4e0e:	08 95       	ret

00004e10 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    4e10:	cf 93       	push	r28
    4e12:	df 93       	push	r29
    4e14:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    4e16:	88 8d       	ldd	r24, Y+24	; 0x18
    4e18:	88 23       	and	r24, r24
    4e1a:	c9 f0       	breq	.+50     	; 0x4e4e <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    4e1c:	ea 89       	ldd	r30, Y+18	; 0x12
    4e1e:	fb 89       	ldd	r31, Y+19	; 0x13
    4e20:	80 81       	ld	r24, Z
    4e22:	85 fd       	sbrc	r24, 5
    4e24:	05 c0       	rjmp	.+10     	; 0x4e30 <_ZN14HardwareSerial5flushEv+0x20>
    4e26:	a8 89       	ldd	r26, Y+16	; 0x10
    4e28:	b9 89       	ldd	r27, Y+17	; 0x11
    4e2a:	8c 91       	ld	r24, X
    4e2c:	86 fd       	sbrc	r24, 6
    4e2e:	0f c0       	rjmp	.+30     	; 0x4e4e <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    4e30:	0f b6       	in	r0, 0x3f	; 63
    4e32:	07 fc       	sbrc	r0, 7
    4e34:	f5 cf       	rjmp	.-22     	; 0x4e20 <_ZN14HardwareSerial5flushEv+0x10>
    4e36:	80 81       	ld	r24, Z
    4e38:	85 ff       	sbrs	r24, 5
    4e3a:	f2 cf       	rjmp	.-28     	; 0x4e20 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    4e3c:	a8 89       	ldd	r26, Y+16	; 0x10
    4e3e:	b9 89       	ldd	r27, Y+17	; 0x11
    4e40:	8c 91       	ld	r24, X
    4e42:	85 ff       	sbrs	r24, 5
    4e44:	ed cf       	rjmp	.-38     	; 0x4e20 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    4e46:	ce 01       	movw	r24, r28
    4e48:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    4e4c:	e7 cf       	rjmp	.-50     	; 0x4e1c <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    4e4e:	df 91       	pop	r29
    4e50:	cf 91       	pop	r28
    4e52:	08 95       	ret

00004e54 <__mulsi3>:
    4e54:	db 01       	movw	r26, r22
    4e56:	8f 93       	push	r24
    4e58:	9f 93       	push	r25
    4e5a:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    4e5e:	bf 91       	pop	r27
    4e60:	af 91       	pop	r26
    4e62:	a2 9f       	mul	r26, r18
    4e64:	80 0d       	add	r24, r0
    4e66:	91 1d       	adc	r25, r1
    4e68:	a3 9f       	mul	r26, r19
    4e6a:	90 0d       	add	r25, r0
    4e6c:	b2 9f       	mul	r27, r18
    4e6e:	90 0d       	add	r25, r0
    4e70:	11 24       	eor	r1, r1
    4e72:	08 95       	ret

00004e74 <__udivmodqi4>:
    4e74:	99 1b       	sub	r25, r25
    4e76:	79 e0       	ldi	r23, 0x09	; 9
    4e78:	04 c0       	rjmp	.+8      	; 0x4e82 <__udivmodqi4_ep>

00004e7a <__udivmodqi4_loop>:
    4e7a:	99 1f       	adc	r25, r25
    4e7c:	96 17       	cp	r25, r22
    4e7e:	08 f0       	brcs	.+2      	; 0x4e82 <__udivmodqi4_ep>
    4e80:	96 1b       	sub	r25, r22

00004e82 <__udivmodqi4_ep>:
    4e82:	88 1f       	adc	r24, r24
    4e84:	7a 95       	dec	r23
    4e86:	c9 f7       	brne	.-14     	; 0x4e7a <__udivmodqi4_loop>
    4e88:	80 95       	com	r24
    4e8a:	08 95       	ret

00004e8c <__udivmodhi4>:
    4e8c:	aa 1b       	sub	r26, r26
    4e8e:	bb 1b       	sub	r27, r27
    4e90:	51 e1       	ldi	r21, 0x11	; 17
    4e92:	07 c0       	rjmp	.+14     	; 0x4ea2 <__udivmodhi4_ep>

00004e94 <__udivmodhi4_loop>:
    4e94:	aa 1f       	adc	r26, r26
    4e96:	bb 1f       	adc	r27, r27
    4e98:	a6 17       	cp	r26, r22
    4e9a:	b7 07       	cpc	r27, r23
    4e9c:	10 f0       	brcs	.+4      	; 0x4ea2 <__udivmodhi4_ep>
    4e9e:	a6 1b       	sub	r26, r22
    4ea0:	b7 0b       	sbc	r27, r23

00004ea2 <__udivmodhi4_ep>:
    4ea2:	88 1f       	adc	r24, r24
    4ea4:	99 1f       	adc	r25, r25
    4ea6:	5a 95       	dec	r21
    4ea8:	a9 f7       	brne	.-22     	; 0x4e94 <__udivmodhi4_loop>
    4eaa:	80 95       	com	r24
    4eac:	90 95       	com	r25
    4eae:	bc 01       	movw	r22, r24
    4eb0:	cd 01       	movw	r24, r26
    4eb2:	08 95       	ret

00004eb4 <__divmodhi4>:
    4eb4:	97 fb       	bst	r25, 7
    4eb6:	07 2e       	mov	r0, r23
    4eb8:	16 f4       	brtc	.+4      	; 0x4ebe <__divmodhi4+0xa>
    4eba:	00 94       	com	r0
    4ebc:	07 d0       	rcall	.+14     	; 0x4ecc <__divmodhi4_neg1>
    4ebe:	77 fd       	sbrc	r23, 7
    4ec0:	09 d0       	rcall	.+18     	; 0x4ed4 <__divmodhi4_neg2>
    4ec2:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <__udivmodhi4>
    4ec6:	07 fc       	sbrc	r0, 7
    4ec8:	05 d0       	rcall	.+10     	; 0x4ed4 <__divmodhi4_neg2>
    4eca:	3e f4       	brtc	.+14     	; 0x4eda <__divmodhi4_exit>

00004ecc <__divmodhi4_neg1>:
    4ecc:	90 95       	com	r25
    4ece:	81 95       	neg	r24
    4ed0:	9f 4f       	sbci	r25, 0xFF	; 255
    4ed2:	08 95       	ret

00004ed4 <__divmodhi4_neg2>:
    4ed4:	70 95       	com	r23
    4ed6:	61 95       	neg	r22
    4ed8:	7f 4f       	sbci	r23, 0xFF	; 255

00004eda <__divmodhi4_exit>:
    4eda:	08 95       	ret

00004edc <__udivmodsi4>:
    4edc:	a1 e2       	ldi	r26, 0x21	; 33
    4ede:	1a 2e       	mov	r1, r26
    4ee0:	aa 1b       	sub	r26, r26
    4ee2:	bb 1b       	sub	r27, r27
    4ee4:	fd 01       	movw	r30, r26
    4ee6:	0d c0       	rjmp	.+26     	; 0x4f02 <__udivmodsi4_ep>

00004ee8 <__udivmodsi4_loop>:
    4ee8:	aa 1f       	adc	r26, r26
    4eea:	bb 1f       	adc	r27, r27
    4eec:	ee 1f       	adc	r30, r30
    4eee:	ff 1f       	adc	r31, r31
    4ef0:	a2 17       	cp	r26, r18
    4ef2:	b3 07       	cpc	r27, r19
    4ef4:	e4 07       	cpc	r30, r20
    4ef6:	f5 07       	cpc	r31, r21
    4ef8:	20 f0       	brcs	.+8      	; 0x4f02 <__udivmodsi4_ep>
    4efa:	a2 1b       	sub	r26, r18
    4efc:	b3 0b       	sbc	r27, r19
    4efe:	e4 0b       	sbc	r30, r20
    4f00:	f5 0b       	sbc	r31, r21

00004f02 <__udivmodsi4_ep>:
    4f02:	66 1f       	adc	r22, r22
    4f04:	77 1f       	adc	r23, r23
    4f06:	88 1f       	adc	r24, r24
    4f08:	99 1f       	adc	r25, r25
    4f0a:	1a 94       	dec	r1
    4f0c:	69 f7       	brne	.-38     	; 0x4ee8 <__udivmodsi4_loop>
    4f0e:	60 95       	com	r22
    4f10:	70 95       	com	r23
    4f12:	80 95       	com	r24
    4f14:	90 95       	com	r25
    4f16:	9b 01       	movw	r18, r22
    4f18:	ac 01       	movw	r20, r24
    4f1a:	bd 01       	movw	r22, r26
    4f1c:	cf 01       	movw	r24, r30
    4f1e:	08 95       	ret

00004f20 <__divmodsi4>:
    4f20:	05 2e       	mov	r0, r21
    4f22:	97 fb       	bst	r25, 7
    4f24:	1e f4       	brtc	.+6      	; 0x4f2c <__divmodsi4+0xc>
    4f26:	00 94       	com	r0
    4f28:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <__negsi2>
    4f2c:	57 fd       	sbrc	r21, 7
    4f2e:	07 d0       	rcall	.+14     	; 0x4f3e <__divmodsi4_neg2>
    4f30:	0e 94 6e 27 	call	0x4edc	; 0x4edc <__udivmodsi4>
    4f34:	07 fc       	sbrc	r0, 7
    4f36:	03 d0       	rcall	.+6      	; 0x4f3e <__divmodsi4_neg2>
    4f38:	4e f4       	brtc	.+18     	; 0x4f4c <__divmodsi4_exit>
    4f3a:	0c 94 a7 27 	jmp	0x4f4e	; 0x4f4e <__negsi2>

00004f3e <__divmodsi4_neg2>:
    4f3e:	50 95       	com	r21
    4f40:	40 95       	com	r20
    4f42:	30 95       	com	r19
    4f44:	21 95       	neg	r18
    4f46:	3f 4f       	sbci	r19, 0xFF	; 255
    4f48:	4f 4f       	sbci	r20, 0xFF	; 255
    4f4a:	5f 4f       	sbci	r21, 0xFF	; 255

00004f4c <__divmodsi4_exit>:
    4f4c:	08 95       	ret

00004f4e <__negsi2>:
    4f4e:	90 95       	com	r25
    4f50:	80 95       	com	r24
    4f52:	70 95       	com	r23
    4f54:	61 95       	neg	r22
    4f56:	7f 4f       	sbci	r23, 0xFF	; 255
    4f58:	8f 4f       	sbci	r24, 0xFF	; 255
    4f5a:	9f 4f       	sbci	r25, 0xFF	; 255
    4f5c:	08 95       	ret

00004f5e <__tablejump2__>:
    4f5e:	ee 0f       	add	r30, r30
    4f60:	ff 1f       	adc	r31, r31
    4f62:	05 90       	lpm	r0, Z+
    4f64:	f4 91       	lpm	r31, Z
    4f66:	e0 2d       	mov	r30, r0
    4f68:	09 94       	ijmp

00004f6a <__umulhisi3>:
    4f6a:	a2 9f       	mul	r26, r18
    4f6c:	b0 01       	movw	r22, r0
    4f6e:	b3 9f       	mul	r27, r19
    4f70:	c0 01       	movw	r24, r0
    4f72:	a3 9f       	mul	r26, r19
    4f74:	70 0d       	add	r23, r0
    4f76:	81 1d       	adc	r24, r1
    4f78:	11 24       	eor	r1, r1
    4f7a:	91 1d       	adc	r25, r1
    4f7c:	b2 9f       	mul	r27, r18
    4f7e:	70 0d       	add	r23, r0
    4f80:	81 1d       	adc	r24, r1
    4f82:	11 24       	eor	r1, r1
    4f84:	91 1d       	adc	r25, r1
    4f86:	08 95       	ret

00004f88 <__usmulhisi3>:
    4f88:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__umulhisi3>

00004f8c <__usmulhisi3_tail>:
    4f8c:	b7 ff       	sbrs	r27, 7
    4f8e:	08 95       	ret
    4f90:	82 1b       	sub	r24, r18
    4f92:	93 0b       	sbc	r25, r19
    4f94:	08 95       	ret

00004f96 <__muluhisi3>:
    4f96:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__umulhisi3>
    4f9a:	a5 9f       	mul	r26, r21
    4f9c:	90 0d       	add	r25, r0
    4f9e:	b4 9f       	mul	r27, r20
    4fa0:	90 0d       	add	r25, r0
    4fa2:	a4 9f       	mul	r26, r20
    4fa4:	80 0d       	add	r24, r0
    4fa6:	91 1d       	adc	r25, r1
    4fa8:	11 24       	eor	r1, r1
    4faa:	08 95       	ret

00004fac <malloc>:
    4fac:	0f 93       	push	r16
    4fae:	1f 93       	push	r17
    4fb0:	cf 93       	push	r28
    4fb2:	df 93       	push	r29
    4fb4:	82 30       	cpi	r24, 0x02	; 2
    4fb6:	91 05       	cpc	r25, r1
    4fb8:	10 f4       	brcc	.+4      	; 0x4fbe <malloc+0x12>
    4fba:	82 e0       	ldi	r24, 0x02	; 2
    4fbc:	90 e0       	ldi	r25, 0x00	; 0
    4fbe:	e0 91 c3 05 	lds	r30, 0x05C3	; 0x8005c3 <__flp>
    4fc2:	f0 91 c4 05 	lds	r31, 0x05C4	; 0x8005c4 <__flp+0x1>
    4fc6:	20 e0       	ldi	r18, 0x00	; 0
    4fc8:	30 e0       	ldi	r19, 0x00	; 0
    4fca:	a0 e0       	ldi	r26, 0x00	; 0
    4fcc:	b0 e0       	ldi	r27, 0x00	; 0
    4fce:	30 97       	sbiw	r30, 0x00	; 0
    4fd0:	19 f1       	breq	.+70     	; 0x5018 <malloc+0x6c>
    4fd2:	40 81       	ld	r20, Z
    4fd4:	51 81       	ldd	r21, Z+1	; 0x01
    4fd6:	02 81       	ldd	r16, Z+2	; 0x02
    4fd8:	13 81       	ldd	r17, Z+3	; 0x03
    4fda:	48 17       	cp	r20, r24
    4fdc:	59 07       	cpc	r21, r25
    4fde:	c8 f0       	brcs	.+50     	; 0x5012 <malloc+0x66>
    4fe0:	84 17       	cp	r24, r20
    4fe2:	95 07       	cpc	r25, r21
    4fe4:	69 f4       	brne	.+26     	; 0x5000 <malloc+0x54>
    4fe6:	10 97       	sbiw	r26, 0x00	; 0
    4fe8:	31 f0       	breq	.+12     	; 0x4ff6 <malloc+0x4a>
    4fea:	12 96       	adiw	r26, 0x02	; 2
    4fec:	0c 93       	st	X, r16
    4fee:	12 97       	sbiw	r26, 0x02	; 2
    4ff0:	13 96       	adiw	r26, 0x03	; 3
    4ff2:	1c 93       	st	X, r17
    4ff4:	27 c0       	rjmp	.+78     	; 0x5044 <malloc+0x98>
    4ff6:	00 93 c3 05 	sts	0x05C3, r16	; 0x8005c3 <__flp>
    4ffa:	10 93 c4 05 	sts	0x05C4, r17	; 0x8005c4 <__flp+0x1>
    4ffe:	22 c0       	rjmp	.+68     	; 0x5044 <malloc+0x98>
    5000:	21 15       	cp	r18, r1
    5002:	31 05       	cpc	r19, r1
    5004:	19 f0       	breq	.+6      	; 0x500c <malloc+0x60>
    5006:	42 17       	cp	r20, r18
    5008:	53 07       	cpc	r21, r19
    500a:	18 f4       	brcc	.+6      	; 0x5012 <malloc+0x66>
    500c:	9a 01       	movw	r18, r20
    500e:	bd 01       	movw	r22, r26
    5010:	ef 01       	movw	r28, r30
    5012:	df 01       	movw	r26, r30
    5014:	f8 01       	movw	r30, r16
    5016:	db cf       	rjmp	.-74     	; 0x4fce <malloc+0x22>
    5018:	21 15       	cp	r18, r1
    501a:	31 05       	cpc	r19, r1
    501c:	f9 f0       	breq	.+62     	; 0x505c <malloc+0xb0>
    501e:	28 1b       	sub	r18, r24
    5020:	39 0b       	sbc	r19, r25
    5022:	24 30       	cpi	r18, 0x04	; 4
    5024:	31 05       	cpc	r19, r1
    5026:	80 f4       	brcc	.+32     	; 0x5048 <malloc+0x9c>
    5028:	8a 81       	ldd	r24, Y+2	; 0x02
    502a:	9b 81       	ldd	r25, Y+3	; 0x03
    502c:	61 15       	cp	r22, r1
    502e:	71 05       	cpc	r23, r1
    5030:	21 f0       	breq	.+8      	; 0x503a <malloc+0x8e>
    5032:	fb 01       	movw	r30, r22
    5034:	93 83       	std	Z+3, r25	; 0x03
    5036:	82 83       	std	Z+2, r24	; 0x02
    5038:	04 c0       	rjmp	.+8      	; 0x5042 <malloc+0x96>
    503a:	90 93 c4 05 	sts	0x05C4, r25	; 0x8005c4 <__flp+0x1>
    503e:	80 93 c3 05 	sts	0x05C3, r24	; 0x8005c3 <__flp>
    5042:	fe 01       	movw	r30, r28
    5044:	32 96       	adiw	r30, 0x02	; 2
    5046:	44 c0       	rjmp	.+136    	; 0x50d0 <malloc+0x124>
    5048:	fe 01       	movw	r30, r28
    504a:	e2 0f       	add	r30, r18
    504c:	f3 1f       	adc	r31, r19
    504e:	81 93       	st	Z+, r24
    5050:	91 93       	st	Z+, r25
    5052:	22 50       	subi	r18, 0x02	; 2
    5054:	31 09       	sbc	r19, r1
    5056:	39 83       	std	Y+1, r19	; 0x01
    5058:	28 83       	st	Y, r18
    505a:	3a c0       	rjmp	.+116    	; 0x50d0 <malloc+0x124>
    505c:	20 91 c1 05 	lds	r18, 0x05C1	; 0x8005c1 <__brkval>
    5060:	30 91 c2 05 	lds	r19, 0x05C2	; 0x8005c2 <__brkval+0x1>
    5064:	23 2b       	or	r18, r19
    5066:	41 f4       	brne	.+16     	; 0x5078 <malloc+0xcc>
    5068:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    506c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    5070:	30 93 c2 05 	sts	0x05C2, r19	; 0x8005c2 <__brkval+0x1>
    5074:	20 93 c1 05 	sts	0x05C1, r18	; 0x8005c1 <__brkval>
    5078:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    507c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    5080:	21 15       	cp	r18, r1
    5082:	31 05       	cpc	r19, r1
    5084:	41 f4       	brne	.+16     	; 0x5096 <malloc+0xea>
    5086:	2d b7       	in	r18, 0x3d	; 61
    5088:	3e b7       	in	r19, 0x3e	; 62
    508a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    508e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    5092:	24 1b       	sub	r18, r20
    5094:	35 0b       	sbc	r19, r21
    5096:	e0 91 c1 05 	lds	r30, 0x05C1	; 0x8005c1 <__brkval>
    509a:	f0 91 c2 05 	lds	r31, 0x05C2	; 0x8005c2 <__brkval+0x1>
    509e:	e2 17       	cp	r30, r18
    50a0:	f3 07       	cpc	r31, r19
    50a2:	a0 f4       	brcc	.+40     	; 0x50cc <malloc+0x120>
    50a4:	2e 1b       	sub	r18, r30
    50a6:	3f 0b       	sbc	r19, r31
    50a8:	28 17       	cp	r18, r24
    50aa:	39 07       	cpc	r19, r25
    50ac:	78 f0       	brcs	.+30     	; 0x50cc <malloc+0x120>
    50ae:	ac 01       	movw	r20, r24
    50b0:	4e 5f       	subi	r20, 0xFE	; 254
    50b2:	5f 4f       	sbci	r21, 0xFF	; 255
    50b4:	24 17       	cp	r18, r20
    50b6:	35 07       	cpc	r19, r21
    50b8:	48 f0       	brcs	.+18     	; 0x50cc <malloc+0x120>
    50ba:	4e 0f       	add	r20, r30
    50bc:	5f 1f       	adc	r21, r31
    50be:	50 93 c2 05 	sts	0x05C2, r21	; 0x8005c2 <__brkval+0x1>
    50c2:	40 93 c1 05 	sts	0x05C1, r20	; 0x8005c1 <__brkval>
    50c6:	81 93       	st	Z+, r24
    50c8:	91 93       	st	Z+, r25
    50ca:	02 c0       	rjmp	.+4      	; 0x50d0 <malloc+0x124>
    50cc:	e0 e0       	ldi	r30, 0x00	; 0
    50ce:	f0 e0       	ldi	r31, 0x00	; 0
    50d0:	cf 01       	movw	r24, r30
    50d2:	df 91       	pop	r29
    50d4:	cf 91       	pop	r28
    50d6:	1f 91       	pop	r17
    50d8:	0f 91       	pop	r16
    50da:	08 95       	ret

000050dc <free>:
    50dc:	cf 93       	push	r28
    50de:	df 93       	push	r29
    50e0:	00 97       	sbiw	r24, 0x00	; 0
    50e2:	09 f4       	brne	.+2      	; 0x50e6 <free+0xa>
    50e4:	81 c0       	rjmp	.+258    	; 0x51e8 <free+0x10c>
    50e6:	fc 01       	movw	r30, r24
    50e8:	32 97       	sbiw	r30, 0x02	; 2
    50ea:	13 82       	std	Z+3, r1	; 0x03
    50ec:	12 82       	std	Z+2, r1	; 0x02
    50ee:	a0 91 c3 05 	lds	r26, 0x05C3	; 0x8005c3 <__flp>
    50f2:	b0 91 c4 05 	lds	r27, 0x05C4	; 0x8005c4 <__flp+0x1>
    50f6:	10 97       	sbiw	r26, 0x00	; 0
    50f8:	81 f4       	brne	.+32     	; 0x511a <free+0x3e>
    50fa:	20 81       	ld	r18, Z
    50fc:	31 81       	ldd	r19, Z+1	; 0x01
    50fe:	82 0f       	add	r24, r18
    5100:	93 1f       	adc	r25, r19
    5102:	20 91 c1 05 	lds	r18, 0x05C1	; 0x8005c1 <__brkval>
    5106:	30 91 c2 05 	lds	r19, 0x05C2	; 0x8005c2 <__brkval+0x1>
    510a:	28 17       	cp	r18, r24
    510c:	39 07       	cpc	r19, r25
    510e:	51 f5       	brne	.+84     	; 0x5164 <free+0x88>
    5110:	f0 93 c2 05 	sts	0x05C2, r31	; 0x8005c2 <__brkval+0x1>
    5114:	e0 93 c1 05 	sts	0x05C1, r30	; 0x8005c1 <__brkval>
    5118:	67 c0       	rjmp	.+206    	; 0x51e8 <free+0x10c>
    511a:	ed 01       	movw	r28, r26
    511c:	20 e0       	ldi	r18, 0x00	; 0
    511e:	30 e0       	ldi	r19, 0x00	; 0
    5120:	ce 17       	cp	r28, r30
    5122:	df 07       	cpc	r29, r31
    5124:	40 f4       	brcc	.+16     	; 0x5136 <free+0x5a>
    5126:	4a 81       	ldd	r20, Y+2	; 0x02
    5128:	5b 81       	ldd	r21, Y+3	; 0x03
    512a:	9e 01       	movw	r18, r28
    512c:	41 15       	cp	r20, r1
    512e:	51 05       	cpc	r21, r1
    5130:	f1 f0       	breq	.+60     	; 0x516e <free+0x92>
    5132:	ea 01       	movw	r28, r20
    5134:	f5 cf       	rjmp	.-22     	; 0x5120 <free+0x44>
    5136:	d3 83       	std	Z+3, r29	; 0x03
    5138:	c2 83       	std	Z+2, r28	; 0x02
    513a:	40 81       	ld	r20, Z
    513c:	51 81       	ldd	r21, Z+1	; 0x01
    513e:	84 0f       	add	r24, r20
    5140:	95 1f       	adc	r25, r21
    5142:	c8 17       	cp	r28, r24
    5144:	d9 07       	cpc	r29, r25
    5146:	59 f4       	brne	.+22     	; 0x515e <free+0x82>
    5148:	88 81       	ld	r24, Y
    514a:	99 81       	ldd	r25, Y+1	; 0x01
    514c:	84 0f       	add	r24, r20
    514e:	95 1f       	adc	r25, r21
    5150:	02 96       	adiw	r24, 0x02	; 2
    5152:	91 83       	std	Z+1, r25	; 0x01
    5154:	80 83       	st	Z, r24
    5156:	8a 81       	ldd	r24, Y+2	; 0x02
    5158:	9b 81       	ldd	r25, Y+3	; 0x03
    515a:	93 83       	std	Z+3, r25	; 0x03
    515c:	82 83       	std	Z+2, r24	; 0x02
    515e:	21 15       	cp	r18, r1
    5160:	31 05       	cpc	r19, r1
    5162:	29 f4       	brne	.+10     	; 0x516e <free+0x92>
    5164:	f0 93 c4 05 	sts	0x05C4, r31	; 0x8005c4 <__flp+0x1>
    5168:	e0 93 c3 05 	sts	0x05C3, r30	; 0x8005c3 <__flp>
    516c:	3d c0       	rjmp	.+122    	; 0x51e8 <free+0x10c>
    516e:	e9 01       	movw	r28, r18
    5170:	fb 83       	std	Y+3, r31	; 0x03
    5172:	ea 83       	std	Y+2, r30	; 0x02
    5174:	49 91       	ld	r20, Y+
    5176:	59 91       	ld	r21, Y+
    5178:	c4 0f       	add	r28, r20
    517a:	d5 1f       	adc	r29, r21
    517c:	ec 17       	cp	r30, r28
    517e:	fd 07       	cpc	r31, r29
    5180:	61 f4       	brne	.+24     	; 0x519a <free+0xbe>
    5182:	80 81       	ld	r24, Z
    5184:	91 81       	ldd	r25, Z+1	; 0x01
    5186:	84 0f       	add	r24, r20
    5188:	95 1f       	adc	r25, r21
    518a:	02 96       	adiw	r24, 0x02	; 2
    518c:	e9 01       	movw	r28, r18
    518e:	99 83       	std	Y+1, r25	; 0x01
    5190:	88 83       	st	Y, r24
    5192:	82 81       	ldd	r24, Z+2	; 0x02
    5194:	93 81       	ldd	r25, Z+3	; 0x03
    5196:	9b 83       	std	Y+3, r25	; 0x03
    5198:	8a 83       	std	Y+2, r24	; 0x02
    519a:	e0 e0       	ldi	r30, 0x00	; 0
    519c:	f0 e0       	ldi	r31, 0x00	; 0
    519e:	12 96       	adiw	r26, 0x02	; 2
    51a0:	8d 91       	ld	r24, X+
    51a2:	9c 91       	ld	r25, X
    51a4:	13 97       	sbiw	r26, 0x03	; 3
    51a6:	00 97       	sbiw	r24, 0x00	; 0
    51a8:	19 f0       	breq	.+6      	; 0x51b0 <free+0xd4>
    51aa:	fd 01       	movw	r30, r26
    51ac:	dc 01       	movw	r26, r24
    51ae:	f7 cf       	rjmp	.-18     	; 0x519e <free+0xc2>
    51b0:	8d 91       	ld	r24, X+
    51b2:	9c 91       	ld	r25, X
    51b4:	11 97       	sbiw	r26, 0x01	; 1
    51b6:	9d 01       	movw	r18, r26
    51b8:	2e 5f       	subi	r18, 0xFE	; 254
    51ba:	3f 4f       	sbci	r19, 0xFF	; 255
    51bc:	82 0f       	add	r24, r18
    51be:	93 1f       	adc	r25, r19
    51c0:	20 91 c1 05 	lds	r18, 0x05C1	; 0x8005c1 <__brkval>
    51c4:	30 91 c2 05 	lds	r19, 0x05C2	; 0x8005c2 <__brkval+0x1>
    51c8:	28 17       	cp	r18, r24
    51ca:	39 07       	cpc	r19, r25
    51cc:	69 f4       	brne	.+26     	; 0x51e8 <free+0x10c>
    51ce:	30 97       	sbiw	r30, 0x00	; 0
    51d0:	29 f4       	brne	.+10     	; 0x51dc <free+0x100>
    51d2:	10 92 c4 05 	sts	0x05C4, r1	; 0x8005c4 <__flp+0x1>
    51d6:	10 92 c3 05 	sts	0x05C3, r1	; 0x8005c3 <__flp>
    51da:	02 c0       	rjmp	.+4      	; 0x51e0 <free+0x104>
    51dc:	13 82       	std	Z+3, r1	; 0x03
    51de:	12 82       	std	Z+2, r1	; 0x02
    51e0:	b0 93 c2 05 	sts	0x05C2, r27	; 0x8005c2 <__brkval+0x1>
    51e4:	a0 93 c1 05 	sts	0x05C1, r26	; 0x8005c1 <__brkval>
    51e8:	df 91       	pop	r29
    51ea:	cf 91       	pop	r28
    51ec:	08 95       	ret

000051ee <random_r>:
    51ee:	8f 92       	push	r8
    51f0:	9f 92       	push	r9
    51f2:	af 92       	push	r10
    51f4:	bf 92       	push	r11
    51f6:	cf 92       	push	r12
    51f8:	df 92       	push	r13
    51fa:	ef 92       	push	r14
    51fc:	ff 92       	push	r15
    51fe:	cf 93       	push	r28
    5200:	df 93       	push	r29
    5202:	ec 01       	movw	r28, r24
    5204:	68 81       	ld	r22, Y
    5206:	79 81       	ldd	r23, Y+1	; 0x01
    5208:	8a 81       	ldd	r24, Y+2	; 0x02
    520a:	9b 81       	ldd	r25, Y+3	; 0x03
    520c:	61 15       	cp	r22, r1
    520e:	71 05       	cpc	r23, r1
    5210:	81 05       	cpc	r24, r1
    5212:	91 05       	cpc	r25, r1
    5214:	21 f4       	brne	.+8      	; 0x521e <random_r+0x30>
    5216:	64 e2       	ldi	r22, 0x24	; 36
    5218:	79 ed       	ldi	r23, 0xD9	; 217
    521a:	8b e5       	ldi	r24, 0x5B	; 91
    521c:	97 e0       	ldi	r25, 0x07	; 7
    521e:	2d e1       	ldi	r18, 0x1D	; 29
    5220:	33 ef       	ldi	r19, 0xF3	; 243
    5222:	41 e0       	ldi	r20, 0x01	; 1
    5224:	50 e0       	ldi	r21, 0x00	; 0
    5226:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    522a:	49 01       	movw	r8, r18
    522c:	5a 01       	movw	r10, r20
    522e:	9b 01       	movw	r18, r22
    5230:	ac 01       	movw	r20, r24
    5232:	a7 ea       	ldi	r26, 0xA7	; 167
    5234:	b1 e4       	ldi	r27, 0x41	; 65
    5236:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    523a:	6b 01       	movw	r12, r22
    523c:	7c 01       	movw	r14, r24
    523e:	ac ee       	ldi	r26, 0xEC	; 236
    5240:	b4 ef       	ldi	r27, 0xF4	; 244
    5242:	a5 01       	movw	r20, r10
    5244:	94 01       	movw	r18, r8
    5246:	0e 94 9b 2a 	call	0x5536	; 0x5536 <__mulohisi3>
    524a:	dc 01       	movw	r26, r24
    524c:	cb 01       	movw	r24, r22
    524e:	8c 0d       	add	r24, r12
    5250:	9d 1d       	adc	r25, r13
    5252:	ae 1d       	adc	r26, r14
    5254:	bf 1d       	adc	r27, r15
    5256:	b7 ff       	sbrs	r27, 7
    5258:	03 c0       	rjmp	.+6      	; 0x5260 <random_r+0x72>
    525a:	01 97       	sbiw	r24, 0x01	; 1
    525c:	a1 09       	sbc	r26, r1
    525e:	b0 48       	sbci	r27, 0x80	; 128
    5260:	88 83       	st	Y, r24
    5262:	99 83       	std	Y+1, r25	; 0x01
    5264:	aa 83       	std	Y+2, r26	; 0x02
    5266:	bb 83       	std	Y+3, r27	; 0x03
    5268:	bc 01       	movw	r22, r24
    526a:	cd 01       	movw	r24, r26
    526c:	9f 77       	andi	r25, 0x7F	; 127
    526e:	df 91       	pop	r29
    5270:	cf 91       	pop	r28
    5272:	ff 90       	pop	r15
    5274:	ef 90       	pop	r14
    5276:	df 90       	pop	r13
    5278:	cf 90       	pop	r12
    527a:	bf 90       	pop	r11
    527c:	af 90       	pop	r10
    527e:	9f 90       	pop	r9
    5280:	8f 90       	pop	r8
    5282:	08 95       	ret

00005284 <random>:
    5284:	8f 92       	push	r8
    5286:	9f 92       	push	r9
    5288:	af 92       	push	r10
    528a:	bf 92       	push	r11
    528c:	cf 92       	push	r12
    528e:	df 92       	push	r13
    5290:	ef 92       	push	r14
    5292:	ff 92       	push	r15
    5294:	60 91 06 01 	lds	r22, 0x0106	; 0x800106 <next>
    5298:	70 91 07 01 	lds	r23, 0x0107	; 0x800107 <next+0x1>
    529c:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <next+0x2>
    52a0:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <next+0x3>
    52a4:	61 15       	cp	r22, r1
    52a6:	71 05       	cpc	r23, r1
    52a8:	81 05       	cpc	r24, r1
    52aa:	91 05       	cpc	r25, r1
    52ac:	21 f4       	brne	.+8      	; 0x52b6 <random+0x32>
    52ae:	64 e2       	ldi	r22, 0x24	; 36
    52b0:	79 ed       	ldi	r23, 0xD9	; 217
    52b2:	8b e5       	ldi	r24, 0x5B	; 91
    52b4:	97 e0       	ldi	r25, 0x07	; 7
    52b6:	2d e1       	ldi	r18, 0x1D	; 29
    52b8:	33 ef       	ldi	r19, 0xF3	; 243
    52ba:	41 e0       	ldi	r20, 0x01	; 1
    52bc:	50 e0       	ldi	r21, 0x00	; 0
    52be:	0e 94 90 27 	call	0x4f20	; 0x4f20 <__divmodsi4>
    52c2:	49 01       	movw	r8, r18
    52c4:	5a 01       	movw	r10, r20
    52c6:	9b 01       	movw	r18, r22
    52c8:	ac 01       	movw	r20, r24
    52ca:	a7 ea       	ldi	r26, 0xA7	; 167
    52cc:	b1 e4       	ldi	r27, 0x41	; 65
    52ce:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    52d2:	6b 01       	movw	r12, r22
    52d4:	7c 01       	movw	r14, r24
    52d6:	ac ee       	ldi	r26, 0xEC	; 236
    52d8:	b4 ef       	ldi	r27, 0xF4	; 244
    52da:	a5 01       	movw	r20, r10
    52dc:	94 01       	movw	r18, r8
    52de:	0e 94 9b 2a 	call	0x5536	; 0x5536 <__mulohisi3>
    52e2:	dc 01       	movw	r26, r24
    52e4:	cb 01       	movw	r24, r22
    52e6:	8c 0d       	add	r24, r12
    52e8:	9d 1d       	adc	r25, r13
    52ea:	ae 1d       	adc	r26, r14
    52ec:	bf 1d       	adc	r27, r15
    52ee:	b7 ff       	sbrs	r27, 7
    52f0:	03 c0       	rjmp	.+6      	; 0x52f8 <random+0x74>
    52f2:	01 97       	sbiw	r24, 0x01	; 1
    52f4:	a1 09       	sbc	r26, r1
    52f6:	b0 48       	sbci	r27, 0x80	; 128
    52f8:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <next>
    52fc:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <next+0x1>
    5300:	a0 93 08 01 	sts	0x0108, r26	; 0x800108 <next+0x2>
    5304:	b0 93 09 01 	sts	0x0109, r27	; 0x800109 <next+0x3>
    5308:	bc 01       	movw	r22, r24
    530a:	cd 01       	movw	r24, r26
    530c:	9f 77       	andi	r25, 0x7F	; 127
    530e:	ff 90       	pop	r15
    5310:	ef 90       	pop	r14
    5312:	df 90       	pop	r13
    5314:	cf 90       	pop	r12
    5316:	bf 90       	pop	r11
    5318:	af 90       	pop	r10
    531a:	9f 90       	pop	r9
    531c:	8f 90       	pop	r8
    531e:	08 95       	ret

00005320 <srandom>:
    5320:	60 93 06 01 	sts	0x0106, r22	; 0x800106 <next>
    5324:	70 93 07 01 	sts	0x0107, r23	; 0x800107 <next+0x1>
    5328:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <next+0x2>
    532c:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <next+0x3>
    5330:	08 95       	ret

00005332 <realloc>:
    5332:	a0 e0       	ldi	r26, 0x00	; 0
    5334:	b0 e0       	ldi	r27, 0x00	; 0
    5336:	ef e9       	ldi	r30, 0x9F	; 159
    5338:	f9 e2       	ldi	r31, 0x29	; 41
    533a:	0c 94 a4 2a 	jmp	0x5548	; 0x5548 <__prologue_saves__+0x8>
    533e:	ec 01       	movw	r28, r24
    5340:	00 97       	sbiw	r24, 0x00	; 0
    5342:	21 f4       	brne	.+8      	; 0x534c <realloc+0x1a>
    5344:	cb 01       	movw	r24, r22
    5346:	0e 94 d6 27 	call	0x4fac	; 0x4fac <malloc>
    534a:	b4 c0       	rjmp	.+360    	; 0x54b4 <realloc+0x182>
    534c:	fc 01       	movw	r30, r24
    534e:	e6 0f       	add	r30, r22
    5350:	f7 1f       	adc	r31, r23
    5352:	9c 01       	movw	r18, r24
    5354:	22 50       	subi	r18, 0x02	; 2
    5356:	31 09       	sbc	r19, r1
    5358:	e2 17       	cp	r30, r18
    535a:	f3 07       	cpc	r31, r19
    535c:	08 f4       	brcc	.+2      	; 0x5360 <realloc+0x2e>
    535e:	a8 c0       	rjmp	.+336    	; 0x54b0 <realloc+0x17e>
    5360:	d9 01       	movw	r26, r18
    5362:	0d 91       	ld	r16, X+
    5364:	1c 91       	ld	r17, X
    5366:	11 97       	sbiw	r26, 0x01	; 1
    5368:	06 17       	cp	r16, r22
    536a:	17 07       	cpc	r17, r23
    536c:	b0 f0       	brcs	.+44     	; 0x539a <realloc+0x68>
    536e:	05 30       	cpi	r16, 0x05	; 5
    5370:	11 05       	cpc	r17, r1
    5372:	08 f4       	brcc	.+2      	; 0x5376 <realloc+0x44>
    5374:	9b c0       	rjmp	.+310    	; 0x54ac <realloc+0x17a>
    5376:	c8 01       	movw	r24, r16
    5378:	04 97       	sbiw	r24, 0x04	; 4
    537a:	86 17       	cp	r24, r22
    537c:	97 07       	cpc	r25, r23
    537e:	08 f4       	brcc	.+2      	; 0x5382 <realloc+0x50>
    5380:	95 c0       	rjmp	.+298    	; 0x54ac <realloc+0x17a>
    5382:	02 50       	subi	r16, 0x02	; 2
    5384:	11 09       	sbc	r17, r1
    5386:	06 1b       	sub	r16, r22
    5388:	17 0b       	sbc	r17, r23
    538a:	01 93       	st	Z+, r16
    538c:	11 93       	st	Z+, r17
    538e:	6d 93       	st	X+, r22
    5390:	7c 93       	st	X, r23
    5392:	cf 01       	movw	r24, r30
    5394:	0e 94 6e 28 	call	0x50dc	; 0x50dc <free>
    5398:	89 c0       	rjmp	.+274    	; 0x54ac <realloc+0x17a>
    539a:	5b 01       	movw	r10, r22
    539c:	a0 1a       	sub	r10, r16
    539e:	b1 0a       	sbc	r11, r17
    53a0:	4c 01       	movw	r8, r24
    53a2:	80 0e       	add	r8, r16
    53a4:	91 1e       	adc	r9, r17
    53a6:	a0 91 c3 05 	lds	r26, 0x05C3	; 0x8005c3 <__flp>
    53aa:	b0 91 c4 05 	lds	r27, 0x05C4	; 0x8005c4 <__flp+0x1>
    53ae:	61 2c       	mov	r6, r1
    53b0:	71 2c       	mov	r7, r1
    53b2:	e1 2c       	mov	r14, r1
    53b4:	f1 2c       	mov	r15, r1
    53b6:	10 97       	sbiw	r26, 0x00	; 0
    53b8:	09 f4       	brne	.+2      	; 0x53bc <realloc+0x8a>
    53ba:	46 c0       	rjmp	.+140    	; 0x5448 <realloc+0x116>
    53bc:	8d 91       	ld	r24, X+
    53be:	9c 91       	ld	r25, X
    53c0:	11 97       	sbiw	r26, 0x01	; 1
    53c2:	a8 15       	cp	r26, r8
    53c4:	b9 05       	cpc	r27, r9
    53c6:	b1 f5       	brne	.+108    	; 0x5434 <realloc+0x102>
    53c8:	6c 01       	movw	r12, r24
    53ca:	42 e0       	ldi	r20, 0x02	; 2
    53cc:	c4 0e       	add	r12, r20
    53ce:	d1 1c       	adc	r13, r1
    53d0:	ca 14       	cp	r12, r10
    53d2:	db 04       	cpc	r13, r11
    53d4:	78 f1       	brcs	.+94     	; 0x5434 <realloc+0x102>
    53d6:	4c 01       	movw	r8, r24
    53d8:	8a 18       	sub	r8, r10
    53da:	9b 08       	sbc	r9, r11
    53dc:	64 01       	movw	r12, r8
    53de:	42 e0       	ldi	r20, 0x02	; 2
    53e0:	c4 0e       	add	r12, r20
    53e2:	d1 1c       	adc	r13, r1
    53e4:	12 96       	adiw	r26, 0x02	; 2
    53e6:	bc 90       	ld	r11, X
    53e8:	12 97       	sbiw	r26, 0x02	; 2
    53ea:	13 96       	adiw	r26, 0x03	; 3
    53ec:	ac 91       	ld	r26, X
    53ee:	b5 e0       	ldi	r27, 0x05	; 5
    53f0:	cb 16       	cp	r12, r27
    53f2:	d1 04       	cpc	r13, r1
    53f4:	40 f0       	brcs	.+16     	; 0x5406 <realloc+0xd4>
    53f6:	b2 82       	std	Z+2, r11	; 0x02
    53f8:	a3 83       	std	Z+3, r26	; 0x03
    53fa:	91 82       	std	Z+1, r9	; 0x01
    53fc:	80 82       	st	Z, r8
    53fe:	d9 01       	movw	r26, r18
    5400:	6d 93       	st	X+, r22
    5402:	7c 93       	st	X, r23
    5404:	09 c0       	rjmp	.+18     	; 0x5418 <realloc+0xe6>
    5406:	0e 5f       	subi	r16, 0xFE	; 254
    5408:	1f 4f       	sbci	r17, 0xFF	; 255
    540a:	80 0f       	add	r24, r16
    540c:	91 1f       	adc	r25, r17
    540e:	f9 01       	movw	r30, r18
    5410:	91 83       	std	Z+1, r25	; 0x01
    5412:	80 83       	st	Z, r24
    5414:	eb 2d       	mov	r30, r11
    5416:	fa 2f       	mov	r31, r26
    5418:	e1 14       	cp	r14, r1
    541a:	f1 04       	cpc	r15, r1
    541c:	31 f0       	breq	.+12     	; 0x542a <realloc+0xf8>
    541e:	d7 01       	movw	r26, r14
    5420:	13 96       	adiw	r26, 0x03	; 3
    5422:	fc 93       	st	X, r31
    5424:	ee 93       	st	-X, r30
    5426:	12 97       	sbiw	r26, 0x02	; 2
    5428:	41 c0       	rjmp	.+130    	; 0x54ac <realloc+0x17a>
    542a:	f0 93 c4 05 	sts	0x05C4, r31	; 0x8005c4 <__flp+0x1>
    542e:	e0 93 c3 05 	sts	0x05C3, r30	; 0x8005c3 <__flp>
    5432:	3c c0       	rjmp	.+120    	; 0x54ac <realloc+0x17a>
    5434:	68 16       	cp	r6, r24
    5436:	79 06       	cpc	r7, r25
    5438:	08 f4       	brcc	.+2      	; 0x543c <realloc+0x10a>
    543a:	3c 01       	movw	r6, r24
    543c:	7d 01       	movw	r14, r26
    543e:	12 96       	adiw	r26, 0x02	; 2
    5440:	0d 90       	ld	r0, X+
    5442:	bc 91       	ld	r27, X
    5444:	a0 2d       	mov	r26, r0
    5446:	b7 cf       	rjmp	.-146    	; 0x53b6 <realloc+0x84>
    5448:	80 91 c1 05 	lds	r24, 0x05C1	; 0x8005c1 <__brkval>
    544c:	90 91 c2 05 	lds	r25, 0x05C2	; 0x8005c2 <__brkval+0x1>
    5450:	88 16       	cp	r8, r24
    5452:	99 06       	cpc	r9, r25
    5454:	e1 f4       	brne	.+56     	; 0x548e <realloc+0x15c>
    5456:	66 16       	cp	r6, r22
    5458:	77 06       	cpc	r7, r23
    545a:	c8 f4       	brcc	.+50     	; 0x548e <realloc+0x15c>
    545c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    5460:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
    5464:	00 97       	sbiw	r24, 0x00	; 0
    5466:	41 f4       	brne	.+16     	; 0x5478 <realloc+0x146>
    5468:	8d b7       	in	r24, 0x3d	; 61
    546a:	9e b7       	in	r25, 0x3e	; 62
    546c:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    5470:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    5474:	84 1b       	sub	r24, r20
    5476:	95 0b       	sbc	r25, r21
    5478:	e8 17       	cp	r30, r24
    547a:	f9 07       	cpc	r31, r25
    547c:	c8 f4       	brcc	.+50     	; 0x54b0 <realloc+0x17e>
    547e:	f0 93 c2 05 	sts	0x05C2, r31	; 0x8005c2 <__brkval+0x1>
    5482:	e0 93 c1 05 	sts	0x05C1, r30	; 0x8005c1 <__brkval>
    5486:	f9 01       	movw	r30, r18
    5488:	71 83       	std	Z+1, r23	; 0x01
    548a:	60 83       	st	Z, r22
    548c:	0f c0       	rjmp	.+30     	; 0x54ac <realloc+0x17a>
    548e:	cb 01       	movw	r24, r22
    5490:	0e 94 d6 27 	call	0x4fac	; 0x4fac <malloc>
    5494:	7c 01       	movw	r14, r24
    5496:	00 97       	sbiw	r24, 0x00	; 0
    5498:	59 f0       	breq	.+22     	; 0x54b0 <realloc+0x17e>
    549a:	a8 01       	movw	r20, r16
    549c:	be 01       	movw	r22, r28
    549e:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <memcpy>
    54a2:	ce 01       	movw	r24, r28
    54a4:	0e 94 6e 28 	call	0x50dc	; 0x50dc <free>
    54a8:	c7 01       	movw	r24, r14
    54aa:	04 c0       	rjmp	.+8      	; 0x54b4 <realloc+0x182>
    54ac:	ce 01       	movw	r24, r28
    54ae:	02 c0       	rjmp	.+4      	; 0x54b4 <realloc+0x182>
    54b0:	80 e0       	ldi	r24, 0x00	; 0
    54b2:	90 e0       	ldi	r25, 0x00	; 0
    54b4:	cd b7       	in	r28, 0x3d	; 61
    54b6:	de b7       	in	r29, 0x3e	; 62
    54b8:	ee e0       	ldi	r30, 0x0E	; 14
    54ba:	0c 94 c0 2a 	jmp	0x5580	; 0x5580 <__epilogue_restores__+0x8>

000054be <abort>:
    54be:	81 e0       	ldi	r24, 0x01	; 1
    54c0:	90 e0       	ldi	r25, 0x00	; 0
    54c2:	f8 94       	cli
    54c4:	0c 94 d7 2a 	jmp	0x55ae	; 0x55ae <__do_global_dtors>

000054c8 <strcpy_P>:
    54c8:	fb 01       	movw	r30, r22
    54ca:	dc 01       	movw	r26, r24
    54cc:	05 90       	lpm	r0, Z+
    54ce:	0d 92       	st	X+, r0
    54d0:	00 20       	and	r0, r0
    54d2:	e1 f7       	brne	.-8      	; 0x54cc <strcpy_P+0x4>
    54d4:	08 95       	ret

000054d6 <memcpy>:
    54d6:	fb 01       	movw	r30, r22
    54d8:	dc 01       	movw	r26, r24
    54da:	02 c0       	rjmp	.+4      	; 0x54e0 <memcpy+0xa>
    54dc:	01 90       	ld	r0, Z+
    54de:	0d 92       	st	X+, r0
    54e0:	41 50       	subi	r20, 0x01	; 1
    54e2:	50 40       	sbci	r21, 0x00	; 0
    54e4:	d8 f7       	brcc	.-10     	; 0x54dc <memcpy+0x6>
    54e6:	08 95       	ret

000054e8 <memmove>:
    54e8:	68 17       	cp	r22, r24
    54ea:	79 07       	cpc	r23, r25
    54ec:	68 f4       	brcc	.+26     	; 0x5508 <memmove+0x20>
    54ee:	fb 01       	movw	r30, r22
    54f0:	dc 01       	movw	r26, r24
    54f2:	e4 0f       	add	r30, r20
    54f4:	f5 1f       	adc	r31, r21
    54f6:	a4 0f       	add	r26, r20
    54f8:	b5 1f       	adc	r27, r21
    54fa:	02 c0       	rjmp	.+4      	; 0x5500 <memmove+0x18>
    54fc:	02 90       	ld	r0, -Z
    54fe:	0e 92       	st	-X, r0
    5500:	41 50       	subi	r20, 0x01	; 1
    5502:	50 40       	sbci	r21, 0x00	; 0
    5504:	d8 f7       	brcc	.-10     	; 0x54fc <memmove+0x14>
    5506:	08 95       	ret
    5508:	0c 94 6b 2a 	jmp	0x54d6	; 0x54d6 <memcpy>

0000550c <strcat>:
    550c:	fb 01       	movw	r30, r22
    550e:	dc 01       	movw	r26, r24
    5510:	0d 90       	ld	r0, X+
    5512:	00 20       	and	r0, r0
    5514:	e9 f7       	brne	.-6      	; 0x5510 <strcat+0x4>
    5516:	11 97       	sbiw	r26, 0x01	; 1
    5518:	01 90       	ld	r0, Z+
    551a:	0d 92       	st	X+, r0
    551c:	00 20       	and	r0, r0
    551e:	e1 f7       	brne	.-8      	; 0x5518 <strcat+0xc>
    5520:	08 95       	ret

00005522 <strcpy>:
    5522:	fb 01       	movw	r30, r22
    5524:	dc 01       	movw	r26, r24
    5526:	01 90       	ld	r0, Z+
    5528:	0d 92       	st	X+, r0
    552a:	00 20       	and	r0, r0
    552c:	e1 f7       	brne	.-8      	; 0x5526 <strcpy+0x4>
    552e:	08 95       	ret

00005530 <__mulshisi3>:
    5530:	b7 ff       	sbrs	r27, 7
    5532:	0c 94 cb 27 	jmp	0x4f96	; 0x4f96 <__muluhisi3>

00005536 <__mulohisi3>:
    5536:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <__muluhisi3>
    553a:	82 1b       	sub	r24, r18
    553c:	93 0b       	sbc	r25, r19
    553e:	08 95       	ret

00005540 <__prologue_saves__>:
    5540:	2f 92       	push	r2
    5542:	3f 92       	push	r3
    5544:	4f 92       	push	r4
    5546:	5f 92       	push	r5
    5548:	6f 92       	push	r6
    554a:	7f 92       	push	r7
    554c:	8f 92       	push	r8
    554e:	9f 92       	push	r9
    5550:	af 92       	push	r10
    5552:	bf 92       	push	r11
    5554:	cf 92       	push	r12
    5556:	df 92       	push	r13
    5558:	ef 92       	push	r14
    555a:	ff 92       	push	r15
    555c:	0f 93       	push	r16
    555e:	1f 93       	push	r17
    5560:	cf 93       	push	r28
    5562:	df 93       	push	r29
    5564:	cd b7       	in	r28, 0x3d	; 61
    5566:	de b7       	in	r29, 0x3e	; 62
    5568:	ca 1b       	sub	r28, r26
    556a:	db 0b       	sbc	r29, r27
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
    5576:	09 94       	ijmp

00005578 <__epilogue_restores__>:
    5578:	2a 88       	ldd	r2, Y+18	; 0x12
    557a:	39 88       	ldd	r3, Y+17	; 0x11
    557c:	48 88       	ldd	r4, Y+16	; 0x10
    557e:	5f 84       	ldd	r5, Y+15	; 0x0f
    5580:	6e 84       	ldd	r6, Y+14	; 0x0e
    5582:	7d 84       	ldd	r7, Y+13	; 0x0d
    5584:	8c 84       	ldd	r8, Y+12	; 0x0c
    5586:	9b 84       	ldd	r9, Y+11	; 0x0b
    5588:	aa 84       	ldd	r10, Y+10	; 0x0a
    558a:	b9 84       	ldd	r11, Y+9	; 0x09
    558c:	c8 84       	ldd	r12, Y+8	; 0x08
    558e:	df 80       	ldd	r13, Y+7	; 0x07
    5590:	ee 80       	ldd	r14, Y+6	; 0x06
    5592:	fd 80       	ldd	r15, Y+5	; 0x05
    5594:	0c 81       	ldd	r16, Y+4	; 0x04
    5596:	1b 81       	ldd	r17, Y+3	; 0x03
    5598:	aa 81       	ldd	r26, Y+2	; 0x02
    559a:	b9 81       	ldd	r27, Y+1	; 0x01
    559c:	ce 0f       	add	r28, r30
    559e:	d1 1d       	adc	r29, r1
    55a0:	0f b6       	in	r0, 0x3f	; 63
    55a2:	f8 94       	cli
    55a4:	de bf       	out	0x3e, r29	; 62
    55a6:	0f be       	out	0x3f, r0	; 63
    55a8:	cd bf       	out	0x3d, r28	; 61
    55aa:	ed 01       	movw	r28, r26
    55ac:	08 95       	ret

000055ae <__do_global_dtors>:
    55ae:	13 e0       	ldi	r17, 0x03	; 3
    55b0:	c9 ed       	ldi	r28, 0xD9	; 217
    55b2:	d3 e0       	ldi	r29, 0x03	; 3
    55b4:	04 c0       	rjmp	.+8      	; 0x55be <__do_global_dtors+0x10>
    55b6:	fe 01       	movw	r30, r28
    55b8:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <__tablejump2__>
    55bc:	21 96       	adiw	r28, 0x01	; 1
    55be:	ca 3d       	cpi	r28, 0xDA	; 218
    55c0:	d1 07       	cpc	r29, r17
    55c2:	c9 f7       	brne	.-14     	; 0x55b6 <__do_global_dtors+0x8>
    55c4:	f8 94       	cli

000055c6 <__stop_program>:
    55c6:	ff cf       	rjmp	.-2      	; 0x55c6 <__stop_program>
